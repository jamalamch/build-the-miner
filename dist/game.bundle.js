(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["exagaming"] = factory();
	else
		root["exagaming"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(8612);

var $apply = __webpack_require__(1768);
var $call = __webpack_require__(8928);
var $reflectApply = __webpack_require__(9770);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ 1768:
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ 8928:
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ 319:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(8612);
var $TypeError = __webpack_require__(4453);

var $call = __webpack_require__(8928);
var $actualApply = __webpack_require__(5116);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ 9770:
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ 7379:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(210);

var callBindBasic = __webpack_require__(319);

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


/***/ }),

/***/ 6504:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(319);
var gOPD = __webpack_require__(7296);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ 9187:
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ 4429:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 3981:
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 1648:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 4726:
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 6712:
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 3464:
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 4453:
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 3915:
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 8892:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ 6729:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 7648:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(7648);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(8892);

var $Error = __webpack_require__(1648);
var $EvalError = __webpack_require__(3981);
var $RangeError = __webpack_require__(4726);
var $ReferenceError = __webpack_require__(6712);
var $SyntaxError = __webpack_require__(3464);
var $TypeError = __webpack_require__(4453);
var $URIError = __webpack_require__(3915);

var abs = __webpack_require__(9738);
var floor = __webpack_require__(6329);
var max = __webpack_require__(2264);
var min = __webpack_require__(5730);
var pow = __webpack_require__(707);
var round = __webpack_require__(3862);
var sign = __webpack_require__(9550);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(7296);
var $defineProperty = __webpack_require__(4429);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(1405)();

var getProto = __webpack_require__(1618);
var $ObjectGPO = __webpack_require__(8899);
var $ReflectGPO = __webpack_require__(443);

var $apply = __webpack_require__(1768);
var $call = __webpack_require__(8928);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(8612);
var hasOwn = __webpack_require__(8824);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 8899:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(8892);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ 443:
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ 1618:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(443);
var originalGetProto = __webpack_require__(8899);

var getDunderProto = __webpack_require__(6504);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ 690:
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ 7296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(690);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 1405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(5419);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 5419:
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 8824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(8612);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 1766:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Handle stopping all sounds globally.
     */
    stop: function() {
      var self = this || Howler;

      // Loop through all Howls and stop them.
      for (var i=0; i<self._howls.length; i++) {
        self._howls[i].stop();
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var ua = self._navigator ? self._navigator.userAgent : '';
      var checkOpera = ua.match(/OPR\/(\d+)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
      var safariVersion = ua.match(/Version\/(.*?) /);
      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        while (self._html5AudioPool.length < self.html5PoolSize) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
            break;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);
          document.removeEventListener('keydown', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);
      document.addEventListener('keydown', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';

        // Handle updating the state of the audio context after suspending.
        var handleSuspension = function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        };

        // Either the state gets suspended or it is interrupted.
        // Either way, we need to update the state to suspended.
        self.ctx.suspend().then(handleSuspension, handleSuspension);
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhr = {
        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
      };

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload && self._preload !== 'none') {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                  } else {
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;
          self._state = 'loading';

          var listener = function() {
            self._state = 'loaded';
            
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = Math.min(Math.max(0, parseFloat(from)), 1);
      to = Math.min(Math.max(0, parseFloat(to)), 1);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Make sure the volume is in the right bounds.
        if (diff < 0) {
          vol = Math.max(to, vol);
        } else {
          vol = Math.min(to, vol);
        }

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;

              // If playing, restart playback to ensure looping updates.
              if (self.playing(ids[i])) {
                self.pause(ids[i], true);
                self.play(ids[i], true);
              }
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        if (self._sounds.length) {
          id = self._sounds[0]._id;
        }
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return 0;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }

            self._emit('seek', id);
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (!node.bufferSource) {
        return self;
      }

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Listen for the 'ended' event on the sound to account for edge-case where
        // a finite sound has a duration of Infinity.
        self._endFn = self._endListener.bind(self);
        self._node.addEventListener('ended', self._endFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    },

    /**
     * HTML5 Audio ended listener callback.
     */
    _endListener: function() {
      var self = this;
      var parent = self._parent;

      // Only handle the `ended`` event if the duration is Infinity.
      if (parent._duration === Infinity) {
        // Update the parent duration to match the real audio duration.
        // Round up the duration to account for the lower precision in HTML5 Audio.
        parent._duration = Math.ceil(self._node.duration * 10) / 10;

        // Update the sprite that corresponds to the real duration.
        if (parent._sprite.__default[1] === Infinity) {
          parent._sprite.__default[1] = parent._duration * 1000;
        }

        // Run the regular ended method.
        parent._ended(self);
      }

      // Clear the event listener since the duration is now correct.
      self._node.removeEventListener('ended', self._endFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open(self._xhr.method, url, true);
      xhr.withCredentials = self._xhr.withCredentials;
      xhr.responseType = 'arraybuffer';

      // Apply any custom headers to the request.
      if (self._xhr.headers) {
        Object.keys(self._xhr.headers).forEach(function(key) {
          xhr.setRequestHeader(key, self._xhr.headers[key]);
        });
      }

      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // Add support for CommonJS libraries such as browserify.
  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Add to global in Node.js (for testing, etc).
  if (typeof __webpack_require__.g !== 'undefined') {
    __webpack_require__.g.HowlerGlobal = HowlerGlobal;
    __webpack_require__.g.Howler = Howler;
    __webpack_require__.g.Howl = Howl;
    __webpack_require__.g.Sound = Sound;
  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Create a new panner node if one doesn't already exist.
        var panner = sound._panner;
        if (!panner) {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
          panner = sound._panner
        }

        // Update the panner values or create a new panner if none exists.
        panner.coneInnerAngle = pa.coneInnerAngle;
        panner.coneOuterAngle = pa.coneOuterAngle;
        panner.coneOuterGain = pa.coneOuterGain;
        panner.distanceModel = pa.distanceModel;
        panner.maxDistance = pa.maxDistance;
        panner.refDistance = pa.refDistance;
        panner.rolloffFactor = pa.rolloffFactor;
        panner.panningModel = pa.panningModel;
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();


/***/ }),

/***/ 9738:
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ 6329:
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ 3678:
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ 2264:
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ 5730:
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ 707:
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ 3862:
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ 9550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(3678);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ 631:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(4654);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 5798:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ 129:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(8261);
var parse = __webpack_require__(5235);
var formats = __webpack_require__(5798);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 5235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(2769);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 8261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(7478);
var utils = __webpack_require__(2769);
var formats = __webpack_require__(5798);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 2769:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(5798);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ 8660:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof __webpack_require__.g === "object" ? __webpack_require__.g :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ 5747:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var inspect = __webpack_require__(631);

var $TypeError = __webpack_require__(4453);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			}
			return curr;
		}
	}
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};

/** @type {import('.')} */
module.exports = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				};
			}
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),

/***/ 3595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(210);
var callBound = __webpack_require__(7379);
var inspect = __webpack_require__(631);

var $TypeError = __webpack_require__(4453);
var $Map = GetIntrinsic('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound('Map.prototype.size', true);

/** @type {import('.')} */
module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
	/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {Map<K, V> | undefined} */ var $m;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			if ($m) {
				var result = $mapDelete($m, key);
				if ($mapSize($m) === 0) {
					$m = void undefined;
				}
				return result;
			}
			return false;
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($m) {
				return $mapGet($m, key);
			}
		},
		has: function (key) {
			if ($m) {
				return $mapHas($m, key);
			}
			return false;
		},
		set: function (key, value) {
			if (!$m) {
				// @ts-expect-error TS can't handle narrowing a variable inside a closure
				$m = new $Map();
			}
			$mapSet($m, key, value);
		}
	};

	// @ts-expect-error TODO: figure out why TS is erroring here
	return channel;
};


/***/ }),

/***/ 9034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(210);
var callBound = __webpack_require__(7379);
var inspect = __webpack_require__(631);
var getSideChannelMap = __webpack_require__(3595);

var $TypeError = __webpack_require__(4453);
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
module.exports = $WeakMap
	? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapDelete($wm, key);
					}
				} else if (getSideChannelMap) {
					if ($m) {
						return $m['delete'](key);
					}
				}
				return false;
			},
			get: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				}
				return $m && $m.get(key);
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				}
				return !!$m && $m.has(key);
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) {
						$m = getSideChannelMap();
					}
					// eslint-disable-next-line no-extra-parens
					/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
				}
			}
		};

		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	}
	: getSideChannelMap;


/***/ }),

/***/ 7478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $TypeError = __webpack_require__(4453);
var inspect = __webpack_require__(631);
var getSideChannelList = __webpack_require__(5747);
var getSideChannelMap = __webpack_require__(3595);
var getSideChannelWeakMap = __webpack_require__(9034);

var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @typedef {ReturnType<typeof getSideChannel>} Channel */

	/** @type {Channel | undefined} */ var $channelData;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			return !!$channelData && $channelData['delete'](key);
		},
		get: function (key) {
			return $channelData && $channelData.get(key);
		},
		has: function (key) {
			return !!$channelData && $channelData.has(key);
		},
		set: function (key, value) {
			if (!$channelData) {
				$channelData = makeChannel();
			}

			$channelData.set(key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),

/***/ 8100:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collector = void 0;
/**
 * Base class for collectors.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class Collector {
    /**
     * Create a new collector.
     *
     * @param signal The signal to emit.
     */
    constructor(signal) {
        // eslint-disable-next-line dot-notation
        this.emit = (...args) => {
            // eslint-disable-next-line dot-notation
            signal["emitCollecting"](this, args);
        };
    }
}
exports.Collector = Collector;


/***/ }),

/***/ 5032:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorArray = void 0;
const Collector_1 = __webpack_require__(8100);
/**
 * Returns the result of the all signal handlers from a signal emission in an array.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorArray extends Collector_1.Collector {
    constructor() {
        super(...arguments);
        this.result = [];
    }
    handleResult(result) {
        this.result.push(result);
        return true;
    }
    /**
     * Get the list of results from the signal handlers.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        this.result.length = 0;
    }
}
exports.CollectorArray = CollectorArray;


/***/ }),

/***/ 8484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorLast = void 0;
const Collector_1 = __webpack_require__(8100);
/**
 * Returns the result of the last signal handler from a signal emission.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorLast extends Collector_1.Collector {
    handleResult(result) {
        this.result = result;
        return true;
    }
    /**
     * Get the result of the last signal handler.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        delete this.result;
    }
}
exports.CollectorLast = CollectorLast;


/***/ }),

/***/ 688:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorUntil0 = void 0;
const Collector_1 = __webpack_require__(8100);
/**
 * Keep signal emissions going while all handlers return true.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorUntil0 extends Collector_1.Collector {
    constructor() {
        super(...arguments);
        this.result = false;
    }
    handleResult(result) {
        this.result = result;
        return this.result;
    }
    /**
     * Get the result of the last signal handler.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        this.result = false;
    }
}
exports.CollectorUntil0 = CollectorUntil0;


/***/ }),

/***/ 1764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorWhile0 = void 0;
const Collector_1 = __webpack_require__(8100);
/**
 * Keep signal emissions going while all handlers return false.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorWhile0 extends Collector_1.Collector {
    constructor() {
        super(...arguments);
        this.result = false;
    }
    handleResult(result) {
        this.result = result;
        return !this.result;
    }
    /**
     * Get the result of the last signal handler.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        this.result = false;
    }
}
exports.CollectorWhile0 = CollectorWhile0;


/***/ }),

/***/ 7919:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Signal = void 0;
const SignalConnection_1 = __webpack_require__(2513);
const SignalLink_1 = __webpack_require__(470);
/**
 * A signal is a way to publish and subscribe to events.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class Signal {
    constructor() {
        this.head = new SignalLink_1.SignalLink();
        this.hasNewLinks = false;
        this.emitDepth = 0;
        this.connectionsCount = 0;
    }
    /**
     * @returns The number of connections on this signal.
     */
    getConnectionsCount() {
        return this.connectionsCount;
    }
    /**
     * @returns true if this signal has connections.
     */
    hasConnections() {
        return this.connectionsCount > 0;
    }
    /**
     * Subscribe to this signal.
     *
     * @param callback This callback will be run when emit() is called.
     * @param order Handlers with a higher order value will be called later.
     */
    connect(callback, order = 0) {
        this.connectionsCount++;
        const link = this.head.insert(callback, order);
        if (this.emitDepth > 0) {
            this.hasNewLinks = true;
            link.newLink = true;
        }
        return new SignalConnection_1.SignalConnectionImpl(link, () => this.decrementConnectionCount());
    }
    decrementConnectionCount() {
        this.connectionsCount--;
    }
    /**
     * Unsubscribe from this signal with the original callback instance.
     * While you can use this method, the SignalConnection returned by connect() will not be updated!
     *
     * @param callback The callback you passed to connect().
     */
    disconnect(callback) {
        for (let link = this.head.next; link !== this.head; link = link.next) {
            if (link.callback === callback) {
                this.decrementConnectionCount();
                link.unlink();
                return true;
            }
        }
        return false;
    }
    /**
     * Disconnect all handlers from this signal event.
     */
    disconnectAll() {
        while (this.head.next !== this.head) {
            this.head.next.unlink();
        }
        this.connectionsCount = 0;
    }
    /**
     * Publish this signal event (call all handlers).
     */
    emit(...args) {
        this.emitDepth++;
        for (let link = this.head.next; link !== this.head; link = link.next) {
            if (link.isEnabled() && link.callback)
                link.callback.apply(null, args);
        }
        this.emitDepth--;
        this.unsetNewLink();
    }
    emitCollecting(collector, args) {
        this.emitDepth++;
        for (let link = this.head.next; link !== this.head; link = link.next) {
            if (link.isEnabled() && link.callback) {
                const result = link.callback.apply(null, args);
                if (!collector.handleResult(result))
                    break;
            }
        }
        this.emitDepth--;
        this.unsetNewLink();
    }
    unsetNewLink() {
        if (this.hasNewLinks && this.emitDepth === 0) {
            for (let link = this.head.next; link !== this.head; link = link.next)
                link.newLink = false;
            this.hasNewLinks = false;
        }
    }
}
exports.Signal = Signal;


/***/ }),

/***/ 2513:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalConnectionImpl = void 0;
/**
 * Implementation of SignalConnection, for internal use only.
 * @private
 */
class SignalConnectionImpl {
    /**
     * @param link The actual link of the connection.
     * @param parentCleanup Callback to cleanup the parent signal when a connection is disconnected
     */
    constructor(link, parentCleanup) {
        this.link = link;
        this.parentCleanup = parentCleanup;
    }
    disconnect() {
        if (this.link !== null) {
            this.link.unlink();
            this.link = null;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.parentCleanup();
            this.parentCleanup = null;
            return true;
        }
        return false;
    }
    set enabled(enable) {
        if (this.link)
            this.link.setEnabled(enable);
    }
    get enabled() {
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        return this.link !== null && this.link.isEnabled();
    }
}
exports.SignalConnectionImpl = SignalConnectionImpl;


/***/ }),

/***/ 1669:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalConnections = void 0;
/**
 * Represents a list of connections to a signal for easy disconnect.
 */
class SignalConnections {
    constructor() {
        this.list = [];
    }
    /**
     * Add a connection to the list.
     * @param connection
     */
    add(connection) {
        this.list.push(connection);
    }
    /**
     * Disconnect all connections in the list and empty the list.
     */
    disconnectAll() {
        for (const connection of this.list) {
            connection.disconnect();
        }
        this.list = [];
    }
    /**
     * @returns The number of connections in this list.
     */
    getCount() {
        return this.list.length;
    }
    /**
     * @returns true if this list is empty.
     */
    isEmpty() {
        return this.list.length === 0;
    }
}
exports.SignalConnections = SignalConnections;


/***/ }),

/***/ 470:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalLink = void 0;
/**
 * SignalLink implements a doubly-linked ring with nodes containing the signal handlers.
 * @private
 */
class SignalLink {
    constructor(prev = null, next = null, order = 0) {
        this.enabled = true;
        this.newLink = false;
        this.callback = null;
        this.prev = prev !== null && prev !== void 0 ? prev : this;
        this.next = next !== null && next !== void 0 ? next : this;
        this.order = order;
    }
    isEnabled() {
        return this.enabled && !this.newLink;
    }
    setEnabled(flag) {
        this.enabled = flag;
    }
    unlink() {
        this.callback = null;
        this.next.prev = this.prev;
        this.prev.next = this.next;
    }
    insert(callback, order) {
        let after = this.prev;
        while (after !== this) {
            if (after.order <= order)
                break;
            after = after.prev;
        }
        const link = new SignalLink(after, after.next, order);
        link.callback = callback;
        after.next = link;
        link.next.prev = link;
        return link;
    }
}
exports.SignalLink = SignalLink;


/***/ }),

/***/ 4242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
__webpack_unused_export__ = exports.MZ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = void 0;
var Collector_1 = __webpack_require__(8100);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return Collector_1.Collector; } });
var CollectorArray_1 = __webpack_require__(5032);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return CollectorArray_1.CollectorArray; } });
var CollectorLast_1 = __webpack_require__(8484);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return CollectorLast_1.CollectorLast; } });
var CollectorUntil0_1 = __webpack_require__(688);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return CollectorUntil0_1.CollectorUntil0; } });
var CollectorWhile0_1 = __webpack_require__(1764);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return CollectorWhile0_1.CollectorWhile0; } });
var Signal_1 = __webpack_require__(7919);
Object.defineProperty(exports, "MZ", ({ enumerable: true, get: function () { return Signal_1.Signal; } }));
var SignalConnections_1 = __webpack_require__(1669);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return SignalConnections_1.SignalConnections; } });


/***/ }),

/***/ 2511:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ 8575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(2511);

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(129);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.Qc = urlParse;
exports.DB = urlResolve;
__webpack_unused_export__ = urlResolveObject;
exports.WU = urlFormat;

__webpack_unused_export__ = Url;


/***/ }),

/***/ 5671:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_566__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_566__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_566__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_566__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_566__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_566__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_566__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_566__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_566__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_566__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_566__(__nested_webpack_require_566__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AuxFunctions = (function () {
    function AuxFunctions() {
    }
    AuxFunctions.numberToR = function (p_num) {
        return (p_num & 0xff0000) >> 16;
    };
    AuxFunctions.numberToG = function (p_num) {
        return (p_num & 0xff00) >> 8;
    };
    AuxFunctions.numberToB = function (p_num) {
        return (p_num & 0xff);
    };
    AuxFunctions.getObjectLength = function (p_object) {
        var totalProperties = 0;
        for (var pName in p_object)
            totalProperties++;
        return totalProperties;
    };
    AuxFunctions.concatObjects = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var finalObject = {};
        var currentObject;
        for (var i = 0; i < args.length; i++) {
            currentObject = args[i];
            for (var prop in currentObject) {
                if (currentObject[prop] == null) {
                    delete finalObject[prop];
                }
                else {
                    finalObject[prop] = currentObject[prop];
                }
            }
        }
        return finalObject;
    };
    return AuxFunctions;
}());
exports.AuxFunctions = AuxFunctions;


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_4245__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TweenListObj_1 = __nested_webpack_require_4245__(2);
var PropertyInfoObject_1 = __nested_webpack_require_4245__(3);
var AuxFunctions_1 = __nested_webpack_require_4245__(0);
var SpecialPropertySplitter_1 = __nested_webpack_require_4245__(4);
var Equations_1 = __nested_webpack_require_4245__(5);
var SpecialProperty_1 = __nested_webpack_require_4245__(6);
var SpecialPropertyModifier_1 = __nested_webpack_require_4245__(7);
var Tweener = (function () {
    function Tweener() {
        throw new Error("Tweener is a static class and should not be instantiated.");
    }
    Tweener.addTween = function (p_scopes, p_parameters) {
        if (p_scopes === void 0) { p_scopes = null; }
        if (p_parameters === void 0) { p_parameters = null; }
        if (p_scopes === null)
            return false;
        var i, j, istr;
        var rScopes;
        if (p_scopes instanceof Array) {
            rScopes = p_scopes.concat();
        }
        else {
            rScopes = [p_scopes];
        }
        var p_obj = TweenListObj_1.TweenListObj.makePropertiesChain(p_parameters);
        if (!Tweener._inited)
            Tweener.init();
        if (!Tweener._engineExists)
            Tweener.startEngine();
        var rTime = (isNaN(p_obj.time) ? 0 : p_obj.time);
        var rDelay = (isNaN(p_obj.delay) ? 0 : p_obj.delay);
        var rProperties = [];
        var restrictedWords = {
            overwrite: true,
            time: true,
            delay: true,
            useFrames: true,
            skipUpdates: true,
            transition: true,
            transitionParams: true,
            onStart: true,
            onUpdate: true,
            onComplete: true,
            onOverwrite: true,
            onError: true,
            rounded: true,
            onStartParams: true,
            onUpdateParams: true,
            onCompleteParams: true,
            onOverwriteParams: true,
            onStartScope: true,
            onUpdateScope: true,
            onCompleteScope: true,
            onOverwriteScope: true,
            onErrorScope: true
        };
        var modifiedProperties = {};
        for (istr in p_obj) {
            if (!restrictedWords[istr]) {
                if (Tweener._specialPropertySplitterList[istr]) {
                    var splitProperties = Tweener._specialPropertySplitterList[istr].splitValues(p_obj[istr], Tweener._specialPropertySplitterList[istr].parameters);
                    for (i = 0; i < splitProperties.length; i++) {
                        if (Tweener._specialPropertySplitterList[splitProperties[i].name]) {
                            var splitProperties2 = Tweener._specialPropertySplitterList[splitProperties[i].name].splitValues(splitProperties[i].value, Tweener._specialPropertySplitterList[splitProperties[i].name].parameters);
                            for (j = 0; j < splitProperties2.length; j++) {
                                rProperties[splitProperties2[j].name] = {
                                    valueStart: undefined,
                                    valueComplete: splitProperties2[j].value,
                                    arrayIndex: splitProperties2[j].arrayIndex,
                                    isSpecialProperty: false
                                };
                            }
                        }
                        else {
                            rProperties[splitProperties[i].name] = {
                                valueStart: undefined,
                                valueComplete: splitProperties[i].value,
                                arrayIndex: splitProperties[i].arrayIndex,
                                isSpecialProperty: false
                            };
                        }
                    }
                }
                else if (Tweener._specialPropertyModifierList[istr] != undefined) {
                    var tempModifiedProperties = Tweener._specialPropertyModifierList[istr].modifyValues(p_obj[istr]);
                    for (i = 0; i < tempModifiedProperties.length; i++) {
                        modifiedProperties[tempModifiedProperties[i].name] = {
                            modifierParameters: tempModifiedProperties[i].parameters,
                            modifierFunction: Tweener._specialPropertyModifierList[istr].getValue
                        };
                    }
                }
                else {
                    rProperties[istr] = { valueStart: undefined, valueComplete: p_obj[istr] };
                }
            }
        }
        for (istr in rProperties) {
            if (Tweener._specialPropertyList[istr] != undefined) {
                rProperties[istr].isSpecialProperty = true;
            }
            else {
                if (rScopes[0][istr] == undefined) {
                    Tweener.printError("The property '" + istr + "' doesn't seem to be a normal object property of " + rScopes[0] + " or a registered special property.");
                }
            }
        }
        for (istr in modifiedProperties) {
            if (rProperties[istr] != undefined) {
                rProperties[istr].modifierParameters = modifiedProperties[istr].modifierParameters;
                rProperties[istr].modifierFunction = modifiedProperties[istr].modifierFunction;
            }
        }
        var rTransition;
        if (typeof p_obj.transition == "string") {
            var trans = p_obj.transition.toLowerCase();
            rTransition = Tweener._transitionList[trans];
        }
        else {
            rTransition = p_obj.transition;
        }
        if (!(rTransition))
            rTransition = Tweener._transitionList["easeoutexpo"];
        var nProperties;
        var nTween;
        var myT;
        for (i = 0; i < rScopes.length; i++) {
            nProperties = new Object();
            for (istr in rProperties) {
                nProperties[istr] = new PropertyInfoObject_1.PropertyInfoObj(rProperties[istr].valueStart, rProperties[istr].valueComplete, rProperties[istr].valueComplete, rProperties[istr].arrayIndex, {}, rProperties[istr].isSpecialProperty, rProperties[istr].modifierFunction, rProperties[istr].modifierParameters);
            }
            if (p_obj.useFrames == true) {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTimeFrame + (rDelay / Tweener._timeScale), Tweener._currentTimeFrame + ((rDelay + rTime) / Tweener._timeScale), true, rTransition, p_obj.transitionParams);
            }
            else {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTime + ((rDelay * 1000) / Tweener._timeScale), Tweener._currentTime + (((rDelay * 1000) + (rTime * 1000)) / Tweener._timeScale), false, rTransition, p_obj.transitionParams);
            }
            nTween.properties = nProperties;
            nTween.onStart = p_obj.onStart;
            nTween.onUpdate = p_obj.onUpdate;
            nTween.onComplete = p_obj.onComplete;
            nTween.onOverwrite = p_obj.onOverwrite;
            nTween.onError = p_obj.onError;
            nTween.onStartParams = p_obj.onStartParams;
            nTween.onUpdateParams = p_obj.onUpdateParams;
            nTween.onCompleteParams = p_obj.onCompleteParams;
            nTween.onOverwriteParams = p_obj.onOverwriteParams;
            nTween.onStartScope = p_obj.onStartScope;
            nTween.onUpdateScope = p_obj.onUpdateScope;
            nTween.onCompleteScope = p_obj.onCompleteScope;
            nTween.onOverwriteScope = p_obj.onOverwriteScope;
            nTween.onErrorScope = p_obj.onErrorScope;
            nTween.rounded = p_obj.rounded;
            nTween.skipUpdates = p_obj.skipUpdates;
            if (p_obj.overwrite == undefined ? Tweener.autoOverwrite : p_obj.overwrite)
                Tweener.removeTweensByTime(nTween.scope, nTween.properties, nTween.timeStart, nTween.timeComplete);
            Tweener._tweenList.push(nTween);
            if (rTime == 0 && rDelay == 0) {
                myT = Tweener._tweenList.length - 1;
                Tweener.updateTweenByIndex(myT);
                Tweener.removeTweenByIndex(myT);
            }
        }
        return true;
    };
    Tweener.addCaller = function (p_scopes, p_parameters) {
        if (p_scopes === void 0) { p_scopes = null; }
        if (p_parameters === void 0) { p_parameters = null; }
        if (!(p_scopes))
            return false;
        var i;
        var rScopes;
        if (p_scopes instanceof Array) {
            rScopes = p_scopes.concat();
        }
        else {
            rScopes = [p_scopes];
        }
        var p_obj = p_parameters;
        if (!Tweener._inited)
            Tweener.init();
        if (!Tweener._engineExists)
            Tweener.startEngine();
        var rTime = (isNaN(p_obj.time) ? 0 : p_obj.time);
        var rDelay = (isNaN(p_obj.delay) ? 0 : p_obj.delay);
        var rTransition;
        if (typeof p_obj.transition == "string") {
            var trans = p_obj.transition.toLowerCase();
            rTransition = Tweener._transitionList[trans];
        }
        else {
            rTransition = p_obj.transition;
        }
        if (!(rTransition))
            rTransition = Tweener._transitionList["easeoutexpo"];
        var nTween;
        var myT;
        for (i = 0; i < rScopes.length; i++) {
            if (p_obj.useFrames == true) {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTimeFrame + (rDelay / Tweener._timeScale), Tweener._currentTimeFrame + ((rDelay + rTime) / Tweener._timeScale), true, rTransition, p_obj.transitionParams);
            }
            else {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTime + ((rDelay * 1000) / Tweener._timeScale), Tweener._currentTime + (((rDelay * 1000) + (rTime * 1000)) / Tweener._timeScale), false, rTransition, p_obj.transitionParams);
            }
            nTween.properties = null;
            nTween.onStart = p_obj.onStart;
            nTween.onUpdate = p_obj.onUpdate;
            nTween.onComplete = p_obj.onComplete;
            nTween.onOverwrite = p_obj.onOverwrite;
            nTween.onStartParams = p_obj.onStartParams;
            nTween.onUpdateParams = p_obj.onUpdateParams;
            nTween.onCompleteParams = p_obj.onCompleteParams;
            nTween.onOverwriteParams = p_obj.onOverwriteParams;
            nTween.onStartScope = p_obj.onStartScope;
            nTween.onUpdateScope = p_obj.onUpdateScope;
            nTween.onCompleteScope = p_obj.onCompleteScope;
            nTween.onOverwriteScope = p_obj.onOverwriteScope;
            nTween.onErrorScope = p_obj.onErrorScope;
            nTween.isCaller = true;
            nTween.count = p_obj.count;
            nTween.waitFrames = p_obj.waitFrames;
            Tweener._tweenList.push(nTween);
            if (rTime == 0 && rDelay == 0) {
                myT = Tweener._tweenList.length - 1;
                Tweener.updateTweenByIndex(myT);
                Tweener.removeTweenByIndex(myT);
            }
        }
        return true;
    };
    Tweener.removeTweensByTime = function (p_scope, p_properties, p_timeStart, p_timeComplete) {
        var removed = false;
        var removedLocally;
        var i;
        var tl = Tweener._tweenList.length;
        var pName;
        for (i = 0; i < tl; i++) {
            if (Tweener._tweenList[i] && p_scope == Tweener._tweenList[i].scope) {
                if (p_timeComplete > Tweener._tweenList[i].timeStart && p_timeStart < Tweener._tweenList[i].timeComplete) {
                    removedLocally = false;
                    for (pName in Tweener._tweenList[i].properties) {
                        if (p_properties[pName]) {
                            if (Tweener._tweenList[i].onOverwrite) {
                                var eventScope = Tweener._tweenList[i].onOverwriteScope ? Tweener._tweenList[i].onOverwriteScope : Tweener._tweenList[i].scope;
                                try {
                                    Tweener._tweenList[i].onOverwrite.apply(eventScope, Tweener._tweenList[i].onOverwriteParams);
                                }
                                catch (e) {
                                    Tweener.handleError(Tweener._tweenList[i], e, "onOverwrite");
                                }
                            }
                            Tweener._tweenList[i].properties[pName] = undefined;
                            delete Tweener._tweenList[i].properties[pName];
                            removedLocally = true;
                            removed = true;
                        }
                    }
                    if (removedLocally) {
                        if (AuxFunctions_1.AuxFunctions.getObjectLength(Tweener._tweenList[i].properties) == 0)
                            Tweener.removeTweenByIndex(i);
                    }
                }
            }
        }
        return removed;
    };
    Tweener.removeTweens = function (p_scope) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var properties = [];
        var i;
        for (i = 0; i < args.length; i++) {
            if (typeof (args[i]) == "string" && properties.indexOf(args[i]) == -1) {
                if (Tweener._specialPropertySplitterList[args[i]]) {
                    var sps = Tweener._specialPropertySplitterList[args[i]];
                    var specialProps = sps.splitValues(p_scope, null);
                    for (var j = 0; j < specialProps.length; j++) {
                        properties.push(specialProps[j].name);
                    }
                }
                else {
                    properties.push(args[i]);
                }
            }
        }
        return Tweener.affectTweens(Tweener.removeTweenByIndex, p_scope, properties);
    };
    Tweener.removeAllTweens = function () {
        if (!(Tweener._tweenList))
            return false;
        var removed = false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            Tweener.removeTweenByIndex(i);
            removed = true;
        }
        return removed;
    };
    Tweener.pauseTweens = function (p_scope) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var properties = new Array();
        var i;
        for (i = 0; i < args.length; i++) {
            if (typeof (args[i]) == "string" && properties.indexOf(args[i]) == -1)
                properties.push(args[i]);
        }
        return Tweener.affectTweens(Tweener.pauseTweenByIndex, p_scope, properties);
    };
    Tweener.pauseAllTweens = function () {
        if (!(Tweener._tweenList))
            return false;
        var paused = false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            Tweener.pauseTweenByIndex(i);
            paused = true;
        }
        return paused;
    };
    Tweener.resumeTweens = function (p_scope) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var properties = new Array();
        var i;
        for (i = 0; i < args.length; i++) {
            if (typeof (args[i]) == "string" && properties.indexOf(args[i]) == -1)
                properties.push(args[i]);
        }
        return Tweener.affectTweens(Tweener.resumeTweenByIndex, p_scope, properties);
    };
    Tweener.resumeAllTweens = function () {
        if (!(Tweener._tweenList))
            return false;
        var resumed = false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            Tweener.resumeTweenByIndex(i);
            resumed = true;
        }
        return resumed;
    };
    Tweener.affectTweens = function (p_affectFunction, p_scope, p_properties) {
        var affected = false;
        var i;
        if (!(Tweener._tweenList))
            return false;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                if (p_properties.length == 0) {
                    p_affectFunction(i);
                    affected = true;
                }
                else {
                    var affectedProperties = new Array();
                    var j = void 0;
                    for (j = 0; j < p_properties.length; j++) {
                        if (Tweener._tweenList[i].properties[p_properties[j]]) {
                            affectedProperties.push(p_properties[j]);
                        }
                    }
                    if (affectedProperties.length > 0) {
                        var objectProperties = AuxFunctions_1.AuxFunctions.getObjectLength(Tweener._tweenList[i].properties);
                        if (objectProperties == affectedProperties.length) {
                            p_affectFunction(i);
                            affected = true;
                        }
                        else {
                            var slicedTweenIndex = Tweener.splitTweens(i, affectedProperties);
                            p_affectFunction(slicedTweenIndex);
                            affected = true;
                        }
                    }
                }
            }
        }
        return affected;
    };
    Tweener.splitTweens = function (p_tween, p_properties) {
        var originalTween = Tweener._tweenList[p_tween];
        var newTween = originalTween.clone(false);
        var i;
        var pName;
        for (i = 0; i < p_properties.length; i++) {
            pName = p_properties[i];
            if (originalTween.properties[pName]) {
                originalTween.properties[pName] = undefined;
                delete originalTween.properties[pName];
            }
        }
        var found;
        for (pName in newTween.properties) {
            found = false;
            for (i = 0; i < p_properties.length; i++) {
                if (p_properties[i] == pName) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                newTween.properties[pName] = undefined;
                delete newTween.properties[pName];
            }
        }
        Tweener._tweenList.push(newTween);
        return (Tweener._tweenList.length - 1);
    };
    Tweener.updateTweens = function () {
        if (Tweener._tweenList.length == 0)
            return false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] == undefined || !Tweener._tweenList[i].isPaused) {
                if (!Tweener.updateTweenByIndex(i))
                    Tweener.removeTweenByIndex(i);
                if (Tweener._tweenList[i] == null) {
                    Tweener.removeTweenByIndex(i, true);
                    i--;
                }
            }
        }
        return true;
    };
    Tweener.removeTweenByIndex = function (i, p_finalRemoval) {
        if (p_finalRemoval === void 0) { p_finalRemoval = false; }
        Tweener._tweenList[i] = null;
        if (p_finalRemoval)
            Tweener._tweenList.splice(i, 1);
        return true;
    };
    Tweener.pauseTweenByIndex = function (p_tween) {
        var tTweening = Tweener._tweenList[p_tween];
        if (tTweening == null || tTweening.isPaused)
            return false;
        tTweening.timePaused = Tweener.getCurrentTweeningTime(tTweening);
        tTweening.isPaused = true;
        return true;
    };
    Tweener.resumeTweenByIndex = function (p_tween) {
        var tTweening = Tweener._tweenList[p_tween];
        if (tTweening == null || !tTweening.isPaused)
            return false;
        var cTime = Tweener.getCurrentTweeningTime(tTweening);
        tTweening.timeStart += cTime - tTweening.timePaused;
        tTweening.timeComplete += cTime - tTweening.timePaused;
        tTweening.timePaused = undefined;
        tTweening.isPaused = false;
        return true;
    };
    Tweener.updateTweenByIndex = function (i) {
        var tTweening = Tweener._tweenList[i];
        if (tTweening == null || !(tTweening.scope))
            return false;
        var isOver = false;
        var mustUpdate;
        var nv;
        var t;
        var b;
        var c;
        var d;
        var pName;
        var eventScope;
        var tScope;
        var cTime = Tweener.getCurrentTweeningTime(tTweening);
        var tProperty;
        if (cTime >= tTweening.timeStart) {
            tScope = tTweening.scope;
            if (tTweening.isCaller) {
                do {
                    t = ((tTweening.timeComplete - tTweening.timeStart) / tTweening.count) * (tTweening.timesCalled + 1);
                    b = tTweening.timeStart;
                    c = tTweening.timeComplete - tTweening.timeStart;
                    d = tTweening.timeComplete - tTweening.timeStart;
                    nv = tTweening.transition(t, b, c, d);
                    if (cTime >= nv) {
                        if (tTweening.onUpdate) {
                            eventScope = tTweening.onUpdateScope ? tTweening.onUpdateScope : tScope;
                            try {
                                tTweening.onUpdate.apply(eventScope, tTweening.onUpdateParams);
                            }
                            catch (e1) {
                                Tweener.handleError(tTweening, e1, "onUpdate");
                            }
                        }
                        tTweening.timesCalled++;
                        if (tTweening.timesCalled >= tTweening.count) {
                            isOver = true;
                            break;
                        }
                        if (tTweening.waitFrames)
                            break;
                    }
                } while (cTime >= nv);
            }
            else {
                mustUpdate = tTweening.skipUpdates < 1 || !tTweening.skipUpdates || tTweening.updatesSkipped >= tTweening.skipUpdates;
                if (cTime >= tTweening.timeComplete) {
                    isOver = true;
                    mustUpdate = true;
                }
                if (!tTweening.hasStarted) {
                    if (tTweening.onStart) {
                        eventScope = tTweening.onStartScope ? tTweening.onStartScope : tScope;
                        try {
                            tTweening.onStart.apply(eventScope, tTweening.onStartParams);
                        }
                        catch (e2) {
                            Tweener.handleError(tTweening, e2, "onStart");
                        }
                    }
                    var pv = void 0;
                    for (pName in tTweening.properties) {
                        if (tTweening.properties[pName].isSpecialProperty) {
                            if (Tweener._specialPropertyList[pName].preProcess) {
                                tTweening.properties[pName].valueComplete = Tweener._specialPropertyList[pName].preProcess(tScope, Tweener._specialPropertyList[pName].parameters, tTweening.properties[pName].originalValueComplete, tTweening.properties[pName].extra);
                            }
                            pv = Tweener._specialPropertyList[pName].getValue(tScope, Tweener._specialPropertyList[pName].parameters, tTweening.properties[pName].extra);
                        }
                        else {
                            pv = tScope[pName];
                        }
                        tTweening.properties[pName].valueStart = isNaN(pv) ? tTweening.properties[pName].valueComplete : pv;
                    }
                    mustUpdate = true;
                    tTweening.hasStarted = true;
                }
                if (mustUpdate) {
                    for (pName in tTweening.properties) {
                        tProperty = tTweening.properties[pName];
                        if (isOver) {
                            nv = tProperty.valueComplete;
                        }
                        else {
                            if (tProperty.hasModifier) {
                                t = cTime - tTweening.timeStart;
                                d = tTweening.timeComplete - tTweening.timeStart;
                                nv = tTweening.transition(t, 0, 1, d, tTweening.transitionParams);
                                nv = tProperty.modifierFunction(tProperty.valueStart, tProperty.valueComplete, nv, tProperty.modifierParameters);
                            }
                            else {
                                t = cTime - tTweening.timeStart;
                                b = tProperty.valueStart;
                                c = tProperty.valueComplete - tProperty.valueStart;
                                d = tTweening.timeComplete - tTweening.timeStart;
                                nv = tTweening.transition(t, b, c, d, tTweening.transitionParams);
                            }
                        }
                        if (tTweening.rounded)
                            nv = Math.round(nv);
                        if (tProperty.isSpecialProperty) {
                            Tweener._specialPropertyList[pName].setValue(tScope, nv, Tweener._specialPropertyList[pName].parameters, tTweening.properties[pName].extra);
                        }
                        else {
                            tScope[pName] = nv;
                        }
                    }
                    tTweening.updatesSkipped = 0;
                    if (tTweening.onUpdate) {
                        eventScope = tTweening.onUpdateScope ? tTweening.onUpdateScope : tScope;
                        try {
                            tTweening.onUpdate.apply(eventScope, tTweening.onUpdateParams);
                        }
                        catch (e3) {
                            Tweener.handleError(tTweening, e3, "onUpdate");
                        }
                    }
                }
                else {
                    tTweening.updatesSkipped++;
                }
            }
            if (isOver && tTweening.onComplete) {
                eventScope = tTweening.onCompleteScope ? tTweening.onCompleteScope : tScope;
                try {
                    tTweening.onComplete.apply(eventScope, tTweening.onCompleteParams);
                }
                catch (e4) {
                    Tweener.handleError(tTweening, e4, "onComplete");
                }
            }
            return (!isOver);
        }
        return (true);
    };
    Tweener.init = function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        Tweener._inited = true;
        Tweener._transitionList = new Object();
        Equations_1.Equations.init();
        Tweener._specialPropertyList = new Object();
        Tweener._specialPropertyModifierList = new Object();
        Tweener._specialPropertySplitterList = new Object();
    };
    Tweener.registerTransition = function (p_name, p_function) {
        if (!Tweener._inited)
            Tweener.init();
        Tweener._transitionList[p_name] = p_function;
    };
    Tweener.registerSpecialProperty = function (p_name, p_getFunction, p_setFunction, p_parameters, p_preProcessFunction) {
        if (p_parameters === void 0) { p_parameters = null; }
        if (p_preProcessFunction === void 0) { p_preProcessFunction = null; }
        if (!Tweener._inited)
            Tweener.init();
        var sp = new SpecialProperty_1.SpecialProperty(p_getFunction, p_setFunction, p_parameters, p_preProcessFunction);
        Tweener._specialPropertyList[p_name] = sp;
    };
    Tweener.registerSpecialPropertyModifier = function (p_name, p_modifyFunction, p_getFunction) {
        if (!Tweener._inited)
            Tweener.init();
        var spm = new SpecialPropertyModifier_1.SpecialPropertyModifier(p_modifyFunction, p_getFunction);
        Tweener._specialPropertyModifierList[p_name] = spm;
    };
    Tweener.registerSpecialPropertySplitter = function (p_name, p_splitFunction, p_parameters) {
        if (p_parameters === void 0) { p_parameters = null; }
        if (!Tweener._inited)
            Tweener.init();
        var sps = new SpecialPropertySplitter_1.SpecialPropertySplitter(p_splitFunction, p_parameters);
        Tweener._specialPropertySplitterList[p_name] = sps;
    };
    Tweener.startEngine = function () {
        Tweener._engineExists = true;
        Tweener._tweenList = [];
        if (window.requestAnimationFrame == null)
            window.requestAnimationFrame = (function () {
                return window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window["mozRequestAnimationFrame"] ||
                    window["oRequestAnimationFrame"] ||
                    window["msRequestAnimationFrame"] ||
                    function (callback, element) {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();
        window.requestAnimationFrame(Tweener.onEnterFrame);
        Tweener._currentTimeFrame = 0;
        Tweener.updateTime();
    };
    Tweener.stopEngine = function () {
        Tweener._engineExists = false;
        Tweener._tweenList = null;
        Tweener._currentTime = 0;
        Tweener._currentTimeFrame = 0;
    };
    Tweener.updateTime = function () {
        Tweener._currentTime = new Date().getTime();
    };
    Tweener.updateFrame = function () {
        Tweener._currentTimeFrame++;
    };
    Tweener.onEnterFrame = function () {
        Tweener.updateTime();
        Tweener.updateFrame();
        var hasUpdated = false;
        hasUpdated = Tweener.updateTweens();
        if (!hasUpdated) {
            Tweener.stopEngine();
        }
        else {
            requestAnimationFrame(Tweener.onEnterFrame);
        }
    };
    Tweener.setTimeScale = function (p_time) {
        var i;
        var cTime;
        if (isNaN(p_time))
            p_time = 1;
        if (p_time < 0.00001)
            p_time = 0.00001;
        if (p_time != Tweener._timeScale) {
            if (Tweener._tweenList != null) {
                for (i = 0; i < Tweener._tweenList.length; i++) {
                    cTime = Tweener.getCurrentTweeningTime(Tweener._tweenList[i]);
                    Tweener._tweenList[i].timeStart = cTime - ((cTime - Tweener._tweenList[i].timeStart) * Tweener._timeScale / p_time);
                    Tweener._tweenList[i].timeComplete = cTime - ((cTime - Tweener._tweenList[i].timeComplete) * Tweener._timeScale / p_time);
                    if (Tweener._tweenList[i].timePaused != undefined)
                        Tweener._tweenList[i].timePaused = cTime - ((cTime - Tweener._tweenList[i].timePaused) * Tweener._timeScale / p_time);
                }
            }
            Tweener._timeScale = p_time;
        }
    };
    Tweener.isTweening = function (p_scope) {
        if (!(Tweener._tweenList))
            return false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                return true;
            }
        }
        return false;
    };
    Tweener.getTweens = function (p_scope) {
        if (!(Tweener._tweenList))
            return [];
        var i;
        var pName;
        var tList = new Array();
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                for (pName in Tweener._tweenList[i].properties)
                    tList.push(pName);
            }
        }
        return tList;
    };
    Tweener.getTweenCount = function (p_scope) {
        if (!(Tweener._tweenList))
            return 0;
        var i;
        var c = 0;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                c += AuxFunctions_1.AuxFunctions.getObjectLength(Tweener._tweenList[i].properties);
            }
        }
        return c;
    };
    Tweener.handleError = function (pTweening, pError, pCallBackName) {
        if (pTweening.onError && (pTweening.onError instanceof Function)) {
            var eventScope = pTweening.onErrorScope ? pTweening.onErrorScope : pTweening.scope;
            try {
                pTweening.onError.apply(eventScope, [pTweening.scope, pError]);
            }
            catch (metaError) {
                Tweener.printError(pTweening.scope + " raised an error while executing the 'onError' handler. Original error:\n " + pError.stack + "\nonError error: " + metaError.stack);
            }
        }
        else {
            if (!(pTweening.onError)) {
                Tweener.printError(pTweening.scope + " raised an error while executing the '" + pCallBackName + "'handler. \n" + pError.stack);
            }
        }
    };
    Tweener.getCurrentTweeningTime = function (p_tweening) {
        return p_tweening.useFrames ? Tweener._currentTimeFrame : Tweener._currentTime;
    };
    Tweener.getVersion = function () {
        return "JS 0.0.1";
    };
    Tweener.printError = function (p_message) {
        console.log("## [Tweener] Error: " + p_message);
    };
    Tweener._engineExists = false;
    Tweener._inited = false;
    Tweener._timeScale = 1;
    Tweener.autoOverwrite = true;
    return Tweener;
}());
exports.Tweener = Tweener;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_38071__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AuxFunctions_1 = __nested_webpack_require_38071__(0);
var TweenListObj = (function () {
    function TweenListObj(p_scope, p_timeStart, p_timeComplete, p_useFrames, p_transition, p_transitionParams) {
        this.scope = p_scope;
        this.timeStart = p_timeStart;
        this.timeComplete = p_timeComplete;
        this.useFrames = p_useFrames;
        this.transition = p_transition;
        this.transitionParams = p_transitionParams;
        this.properties = new Object();
        this.isPaused = false;
        this.timePaused = undefined;
        this.isCaller = false;
        this.updatesSkipped = 0;
        this.timesCalled = 0;
        this.skipUpdates = 0;
        this.hasStarted = false;
    }
    TweenListObj.prototype.clone = function (omitEvents) {
        var nTween = new TweenListObj(this.scope, this.timeStart, this.timeComplete, this.useFrames, this.transition, this.transitionParams);
        nTween.properties = new Array();
        for (var pName in this.properties) {
            nTween.properties[pName] = this.properties[pName].clone();
        }
        nTween.skipUpdates = this.skipUpdates;
        nTween.updatesSkipped = this.updatesSkipped;
        if (!omitEvents) {
            nTween.onStart = this.onStart;
            nTween.onUpdate = this.onUpdate;
            nTween.onComplete = this.onComplete;
            nTween.onOverwrite = this.onOverwrite;
            nTween.onError = this.onError;
            nTween.onStartParams = this.onStartParams;
            nTween.onUpdateParams = this.onUpdateParams;
            nTween.onCompleteParams = this.onCompleteParams;
            nTween.onOverwriteParams = this.onOverwriteParams;
            nTween.onStartScope = this.onStartScope;
            nTween.onUpdateScope = this.onUpdateScope;
            nTween.onCompleteScope = this.onCompleteScope;
            nTween.onOverwriteScope = this.onOverwriteScope;
            nTween.onErrorScope = this.onErrorScope;
        }
        nTween.rounded = this.rounded;
        nTween.isPaused = this.isPaused;
        nTween.timePaused = this.timePaused;
        nTween.isCaller = this.isCaller;
        nTween.count = this.count;
        nTween.timesCalled = this.timesCalled;
        nTween.waitFrames = this.waitFrames;
        nTween.hasStarted = this.hasStarted;
        return nTween;
    };
    TweenListObj.prototype.toString = function () {
        var returnStr = "\n[TweenListObj ";
        returnStr += "scope:" + this.scope;
        returnStr += ", properties:";
        var isFirst = true;
        for (var i in this.properties) {
            if (!isFirst)
                returnStr += ",";
            returnStr += "[name:" + this.properties[i].name;
            returnStr += ",valueStart:" + this.properties[i].valueStart;
            returnStr += ",valueComplete:" + this.properties[i].valueComplete;
            returnStr += "]";
            isFirst = false;
        }
        returnStr += ", timeStart:" + this.timeStart;
        returnStr += ", timeComplete:" + this.timeComplete;
        returnStr += ", useFrames:" + this.useFrames;
        returnStr += ", transition:" + this.transition;
        returnStr += ", transitionParams:" + this.transitionParams;
        if (this.skipUpdates)
            returnStr += ", skipUpdates:" + this.skipUpdates;
        if (this.updatesSkipped)
            returnStr += ", updatesSkipped:" + this.updatesSkipped;
        if (this.onStart !== null)
            returnStr += ", onStart:" + this.onStart;
        if (this.onUpdate !== null)
            returnStr += ", onUpdate:" + this.onUpdate;
        if (this.onComplete !== null)
            returnStr += ", onComplete:" + this.onComplete;
        if (this.onOverwrite !== null)
            returnStr += ", onOverwrite:" + this.onOverwrite;
        if (this.onError !== null)
            returnStr += ", onError:" + this.onError;
        if (this.onStartParams)
            returnStr += ", onStartParams:" + this.onStartParams;
        if (this.onUpdateParams)
            returnStr += ", onUpdateParams:" + this.onUpdateParams;
        if (this.onCompleteParams)
            returnStr += ", onCompleteParams:" + this.onCompleteParams;
        if (this.onOverwriteParams)
            returnStr += ", onOverwriteParams:" + this.onOverwriteParams;
        if (this.onStartScope)
            returnStr += ", onStartScope:" + this.onStartScope;
        if (this.onUpdateScope)
            returnStr += ", onUpdateScope:" + this.onUpdateScope;
        if (this.onCompleteScope)
            returnStr += ", onCompleteScope:" + this.onCompleteScope;
        if (this.onOverwriteScope)
            returnStr += ", onOverwriteScope:" + this.onOverwriteScope;
        if (this.onErrorScope)
            returnStr += ", onErrorScope:" + this.onErrorScope;
        if (this.rounded)
            returnStr += ", rounded:" + this.rounded;
        if (this.isPaused)
            returnStr += ", isPaused:" + this.isPaused;
        if (this.timePaused)
            returnStr += ", timePaused:" + this.timePaused;
        if (this.isCaller)
            returnStr += ", isCaller:" + this.isCaller;
        if (this.count)
            returnStr += ", count:" + this.count;
        if (this.timesCalled)
            returnStr += ", timesCalled:" + this.timesCalled;
        if (this.waitFrames)
            returnStr += ", waitFrames:" + this.waitFrames;
        if (this.hasStarted)
            returnStr += ", hasStarted:" + this.hasStarted;
        returnStr += "]\n";
        return returnStr;
    };
    TweenListObj.makePropertiesChain = function (p_obj) {
        var baseObject = p_obj.base;
        if (baseObject) {
            var chainedObject = {};
            var chain = void 0;
            if (baseObject instanceof Array) {
                chain = [];
                for (var k = 0; k < baseObject.length; k++)
                    chain.push(baseObject[k]);
            }
            else {
                chain = [baseObject];
            }
            chain.push(p_obj);
            var currChainObj = void 0;
            var len = chain.length;
            for (var i = 0; i < len; i++) {
                if (chain[i]["base"]) {
                    currChainObj = AuxFunctions_1.AuxFunctions.concatObjects(this.makePropertiesChain(chain[i]["base"]), chain[i]);
                }
                else {
                    currChainObj = chain[i];
                }
                chainedObject = AuxFunctions_1.AuxFunctions.concatObjects(chainedObject, currChainObj);
            }
            if (chainedObject["base"]) {
                delete chainedObject["base"];
            }
            return chainedObject;
        }
        else {
            return p_obj;
        }
    };
    return TweenListObj;
}());
exports.TweenListObj = TweenListObj;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var PropertyInfoObj = (function () {
    function PropertyInfoObj(p_valueStart, p_valueComplete, p_originalValueComplete, p_arrayIndex, p_extra, p_isSpecialProperty, p_modifierFunction, p_modifierParameters) {
        this.valueStart = p_valueStart;
        this.valueComplete = p_valueComplete;
        this.originalValueComplete = p_originalValueComplete;
        this.arrayIndex = p_arrayIndex;
        this.extra = p_extra;
        this.isSpecialProperty = p_isSpecialProperty;
        this.hasModifier = (p_modifierFunction != null);
        this.modifierFunction = p_modifierFunction;
        this.modifierParameters = p_modifierParameters;
    }
    PropertyInfoObj.prototype.clone = function () {
        var nProperty = new PropertyInfoObj(this.valueStart, this.valueComplete, this.originalValueComplete, this.arrayIndex, this.extra, this.isSpecialProperty, this.modifierFunction, this.modifierParameters);
        return nProperty;
    };
    PropertyInfoObj.prototype.toString = function () {
        var returnStr = "\n[PropertyInfoObj ";
        returnStr += "valueStart:" + this.valueStart;
        returnStr += ", ";
        returnStr += "valueComplete:" + this.valueComplete;
        returnStr += ", ";
        returnStr += "originalValueComplete:" + this.originalValueComplete;
        returnStr += ", ";
        returnStr += "arrayIndex:" + this.arrayIndex;
        returnStr += ", ";
        returnStr += "extra:" + this.extra;
        returnStr += ", ";
        returnStr += "isSpecialProperty:" + this.isSpecialProperty;
        returnStr += ", ";
        returnStr += "hasModifier:" + this.hasModifier;
        returnStr += ", ";
        returnStr += "modifierFunction:" + this.modifierFunction;
        returnStr += ", ";
        returnStr += "modifierParameters:" + this.modifierParameters;
        returnStr += "]\n";
        return returnStr;
    };
    return PropertyInfoObj;
}());
exports.PropertyInfoObj = PropertyInfoObj;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SpecialPropertySplitter = (function () {
    function SpecialPropertySplitter(p_splitFunction, p_parameters) {
        this.splitValues = p_splitFunction;
        this.parameters = p_parameters;
    }
    SpecialPropertySplitter.prototype.toString = function () {
        var value = "";
        value += "[SpecialPropertySplitter ";
        value += "splitValues:" + this.splitValues;
        value += ", ";
        value += "parameters:" + this.parameters;
        value += "]";
        return value;
    };
    return SpecialPropertySplitter;
}());
exports.SpecialPropertySplitter = SpecialPropertySplitter;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_47899__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Tweener_1 = __nested_webpack_require_47899__(1);
var Equations = (function () {
    function Equations() {
        throw new Error("Equations is a static class and should not be instantiated.");
    }
    Equations.init = function () {
        Tweener_1.Tweener.registerTransition("easenone", Equations.easeNone);
        Tweener_1.Tweener.registerTransition("linear", Equations.easeNone);
        Tweener_1.Tweener.registerTransition("easeinquad", Equations.easeInQuad);
        Tweener_1.Tweener.registerTransition("easeoutquad", Equations.easeOutQuad);
        Tweener_1.Tweener.registerTransition("easeinoutquad", Equations.easeInOutQuad);
        Tweener_1.Tweener.registerTransition("easeoutinquad", Equations.easeOutInQuad);
        Tweener_1.Tweener.registerTransition("easeincubic", Equations.easeInCubic);
        Tweener_1.Tweener.registerTransition("easeoutcubic", Equations.easeOutCubic);
        Tweener_1.Tweener.registerTransition("easeinoutcubic", Equations.easeInOutCubic);
        Tweener_1.Tweener.registerTransition("easeoutincubic", Equations.easeOutInCubic);
        Tweener_1.Tweener.registerTransition("easeinquart", Equations.easeInQuart);
        Tweener_1.Tweener.registerTransition("easeoutquart", Equations.easeOutQuart);
        Tweener_1.Tweener.registerTransition("easeinoutquart", Equations.easeInOutQuart);
        Tweener_1.Tweener.registerTransition("easeoutinquart", Equations.easeOutInQuart);
        Tweener_1.Tweener.registerTransition("easeinquint", Equations.easeInQuint);
        Tweener_1.Tweener.registerTransition("easeoutquint", Equations.easeOutQuint);
        Tweener_1.Tweener.registerTransition("easeinoutquint", Equations.easeInOutQuint);
        Tweener_1.Tweener.registerTransition("easeoutinquint", Equations.easeOutInQuint);
        Tweener_1.Tweener.registerTransition("easeinsine", Equations.easeInSine);
        Tweener_1.Tweener.registerTransition("easeoutsine", Equations.easeOutSine);
        Tweener_1.Tweener.registerTransition("easeinoutsine", Equations.easeInOutSine);
        Tweener_1.Tweener.registerTransition("easeoutinsine", Equations.easeOutInSine);
        Tweener_1.Tweener.registerTransition("easeincirc", Equations.easeInCirc);
        Tweener_1.Tweener.registerTransition("easeoutcirc", Equations.easeOutCirc);
        Tweener_1.Tweener.registerTransition("easeinoutcirc", Equations.easeInOutCirc);
        Tweener_1.Tweener.registerTransition("easeoutincirc", Equations.easeOutInCirc);
        Tweener_1.Tweener.registerTransition("easeinexpo", Equations.easeInExpo);
        Tweener_1.Tweener.registerTransition("easeoutexpo", Equations.easeOutExpo);
        Tweener_1.Tweener.registerTransition("easeinoutexpo", Equations.easeInOutExpo);
        Tweener_1.Tweener.registerTransition("easeoutinexpo", Equations.easeOutInExpo);
        Tweener_1.Tweener.registerTransition("easeinelastic", Equations.easeInElastic);
        Tweener_1.Tweener.registerTransition("easeoutelastic", Equations.easeOutElastic);
        Tweener_1.Tweener.registerTransition("easeinoutelastic", Equations.easeInOutElastic);
        Tweener_1.Tweener.registerTransition("easeoutinelastic", Equations.easeOutInElastic);
        Tweener_1.Tweener.registerTransition("easeinback", Equations.easeInBack);
        Tweener_1.Tweener.registerTransition("easeoutback", Equations.easeOutBack);
        Tweener_1.Tweener.registerTransition("easeinoutback", Equations.easeInOutBack);
        Tweener_1.Tweener.registerTransition("easeoutinback", Equations.easeOutInBack);
        Tweener_1.Tweener.registerTransition("easeinbounce", Equations.easeInBounce);
        Tweener_1.Tweener.registerTransition("easeoutbounce", Equations.easeOutBounce);
        Tweener_1.Tweener.registerTransition("easeinoutbounce", Equations.easeInOutBounce);
        Tweener_1.Tweener.registerTransition("easeoutinbounce", Equations.easeOutInBounce);
    };
    Equations.easeNone = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * t / d + b;
    };
    Equations.easeInQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t + b;
    };
    Equations.easeOutQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * (t /= d) * (t - 2) + b;
    };
    Equations.easeInOutQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t + b;
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
    };
    Equations.easeOutInQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutQuad(t * 2, b, c / 2, d, p_params);
        return Equations.easeInQuad((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t * t + b;
    };
    Equations.easeOutCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * ((t = t / d - 1) * t * t + 1) + b;
    };
    Equations.easeInOutCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t + b;
        return c / 2 * ((t -= 2) * t * t + 2) + b;
    };
    Equations.easeOutInCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutCubic(t * 2, b, c / 2, d, p_params);
        return Equations.easeInCubic((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t * t * t + b;
    };
    Equations.easeOutQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    };
    Equations.easeInOutQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t * t + b;
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    };
    Equations.easeOutInQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutQuart(t * 2, b, c / 2, d, p_params);
        return Equations.easeInQuart((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t * t * t * t + b;
    };
    Equations.easeOutQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    };
    Equations.easeInOutQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t * t * t + b;
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    };
    Equations.easeOutInQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutQuint(t * 2, b, c / 2, d, p_params);
        return Equations.easeInQuint((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    };
    Equations.easeOutSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    };
    Equations.easeInOutSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    };
    Equations.easeOutInSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutSine(t * 2, b, c / 2, d, p_params);
        return Equations.easeInSine((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
    };
    Equations.easeOutExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return (t == d) ? b + c : c * 1.001 * (-Math.pow(2, -10 * t / d) + 1) + b;
    };
    Equations.easeInOutExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if (t == d)
            return b + c;
        if ((t /= d / 2) < 1)
            return c / 2 * Math.pow(2, 10 * (t - 1)) + b - c * 0.0005;
        return c / 2 * 1.0005 * (-Math.pow(2, -10 * --t) + 2) + b;
    };
    Equations.easeOutInExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutExpo(t * 2, b, c / 2, d, p_params);
        return Equations.easeInExpo((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    };
    Equations.easeOutCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    };
    Equations.easeInOutCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    };
    Equations.easeOutInCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutCirc(t * 2, b, c / 2, d, p_params);
        return Equations.easeInCirc((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        var p = !Boolean(p_params) || isNaN(p_params.period) ? d * .3 : p_params.period;
        var s;
        var a = !Boolean(p_params) || isNaN(p_params.amplitude) ? 0 : p_params.amplitude;
        if (!Boolean(a) || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    };
    Equations.easeOutElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        var p = !Boolean(p_params) || isNaN(p_params.period) ? d * .3 : p_params.period;
        var s;
        var a = !Boolean(p_params) || isNaN(p_params.amplitude) ? 0 : p_params.amplitude;
        if (!Boolean(a) || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
    };
    Equations.easeInOutElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if ((t /= d / 2) == 2)
            return b + c;
        var p = !Boolean(p_params) || isNaN(p_params.period) ? d * (.3 * 1.5) : p_params.period;
        var s;
        var a = !Boolean(p_params) || isNaN(p_params.amplitude) ? 0 : p_params.amplitude;
        if (!Boolean(a) || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        if (t < 1)
            return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
    };
    Equations.easeOutInElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutElastic(t * 2, b, c / 2, d, p_params);
        return Equations.easeInElastic((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        var s = !Boolean(p_params) || isNaN(p_params.overshoot) ? 1.70158 : p_params.overshoot;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    };
    Equations.easeOutBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        var s = !Boolean(p_params) || isNaN(p_params.overshoot) ? 1.70158 : p_params.overshoot;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    };
    Equations.easeInOutBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        var s = !Boolean(p_params) || isNaN(p_params.overshoot) ? 1.70158 : p_params.overshoot;
        if ((t /= d / 2) < 1)
            return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    };
    Equations.easeOutInBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutBack(t * 2, b, c / 2, d, p_params);
        return Equations.easeInBack((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c - Equations.easeOutBounce(d - t, 0, c, d) + b;
    };
    Equations.easeOutBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d) < (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        }
        else if (t < (2 / 2.75)) {
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        }
        else if (t < (2.5 / 2.75)) {
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        }
        else {
            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        }
    };
    Equations.easeInOutBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeInBounce(t * 2, 0, c, d) * .5 + b;
        else
            return Equations.easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
    };
    Equations.easeOutInBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutBounce(t * 2, b, c / 2, d, p_params);
        return Equations.easeInBounce((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    return Equations;
}());
exports.Equations = Equations;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SpecialProperty = (function () {
    function SpecialProperty(p_getFunction, p_setFunction, p_parameters, p_preProcessFunction) {
        if (p_parameters === void 0) { p_parameters = null; }
        if (p_preProcessFunction === void 0) { p_preProcessFunction = null; }
        this.getValue = p_getFunction;
        this.setValue = p_setFunction;
        this.parameters = p_parameters;
        this.preProcess = p_preProcessFunction;
    }
    SpecialProperty.prototype.toString = function () {
        var value = "";
        value += "[SpecialProperty ";
        value += "getValue:" + this.getValue;
        value += ", ";
        value += "setValue:" + this.setValue;
        value += ", ";
        value += "parameters:" + this.parameters;
        value += ", ";
        value += "preProcess:" + this.preProcess;
        value += "]";
        return value;
    };
    return SpecialProperty;
}());
exports.SpecialProperty = SpecialProperty;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SpecialPropertyModifier = (function () {
    function SpecialPropertyModifier(p_modifyFunction, p_getFunction) {
        this.modifyValues = p_modifyFunction;
        this.getValue = p_getFunction;
    }
    SpecialPropertyModifier.prototype.toString = function () {
        var value = "";
        value += "[SpecialPropertyModifier ";
        value += "modifyValues:" + this.modifyValues;
        value += ", ";
        value += "getValue:" + this.getValue;
        value += "]";
        return value;
    };
    return SpecialPropertyModifier;
}());
exports.SpecialPropertyModifier = SpecialPropertyModifier;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_65650__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Tweener_1 = __nested_webpack_require_65650__(1);
exports.Tweener = Tweener_1.Tweener;
var TweenListObj_1 = __nested_webpack_require_65650__(2);
exports.TweenListObj = TweenListObj_1.TweenListObj;
var PropertyInfoObject_1 = __nested_webpack_require_65650__(3);
exports.PropertyInfoObj = PropertyInfoObject_1.PropertyInfoObj;
var AuxFunctions_1 = __nested_webpack_require_65650__(0);
exports.AuxFunctions = AuxFunctions_1.AuxFunctions;
var SpecialPropertySplitter_1 = __nested_webpack_require_65650__(4);
exports.SpecialPropertySplitter = SpecialPropertySplitter_1.SpecialPropertySplitter;
var Equations_1 = __nested_webpack_require_65650__(5);
exports.Equations = Equations_1.Equations;
var SpecialProperty_1 = __nested_webpack_require_65650__(6);
exports.SpecialProperty = SpecialProperty_1.SpecialProperty;
var SpecialPropertyModifier_1 = __nested_webpack_require_65650__(7);
exports.SpecialPropertyModifier = SpecialPropertyModifier_1.SpecialPropertyModifier;


/***/ })
/******/ ]);
});
//# sourceMappingURL=ignitionTween.js.map

/***/ }),

/***/ 4654:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  TheMiner: () => (/* binding */ TheMiner)
});

;// CONCATENATED MODULE: ./node_modules/@pixi/constants/lib/index.mjs
var ENV = /* @__PURE__ */ ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var lib_BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(lib_BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var lib_WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(lib_WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
  return COLOR_MASK_BITS2;
})(COLOR_MASK_BITS || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/adapter.mjs
const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};


//# sourceMappingURL=adapter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/settings.mjs


const settings = {
  ADAPTER: BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};


//# sourceMappingURL=settings.mjs.map

;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}
//# sourceMappingURL=isMobile.js.map
;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/utils/isMobile.mjs


const isMobileCall = isMobile["default"] ?? isMobile;
const isMobile_isMobile = isMobileCall(globalThis.navigator);


//# sourceMappingURL=isMobile.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/index.mjs





//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/settings.mjs



settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
//# sourceMappingURL=settings.mjs.map

// EXTERNAL MODULE: ./node_modules/eventemitter3/index.js
var eventemitter3 = __webpack_require__(6729);
var eventemitter3_default = /*#__PURE__*/__webpack_require__.n(eventemitter3);
// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js
var earcut = __webpack_require__(9187);
// EXTERNAL MODULE: ./node_modules/url/url.js
var url = __webpack_require__(8575);
;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/url.mjs


const url_url = {
  parse: url/* parse */.Qc,
  format: url/* format */.WU,
  resolve: url/* resolve */.DB
};


//# sourceMappingURL=url.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/path.mjs


function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol = "";
    const isFile = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile || isHttp || isWindows) {
      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
      protocol = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol;
  },
  toAbsolute(url, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url);
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i) {
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    if (protocol)
      ret.dir = protocol + ret.dir;
    return ret;
  },
  sep: "/",
  delimiter: ":"
};


//# sourceMappingURL=path.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/logging/deprecation.mjs
const warnings = {};
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}


//# sourceMappingURL=deprecation.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/hello.mjs


function skipHello() {
  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}


//# sourceMappingURL=hello.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs



let supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}


//# sourceMappingURL=isWebGLSupported.mjs.map

;// CONCATENATED MODULE: ./node_modules/colord/index.mjs
var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};

;// CONCATENATED MODULE: ./node_modules/colord/plugins/names.mjs
/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}

;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/Color.mjs



k([names]);
const _Color = class {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color) {
      this._value = this.cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {
      this.normalize(value);
      this._value = this.cloneSource(value);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v, i) => v === value2[i]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    out = out ?? [];
    out[0] = Math.round(r * 255);
    out[1] = Math.round(g * 255);
    out[2] = Math.round(b * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r, g, b] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r, g, b, a] = _Color.temp.setValue(value)._components;
    this._components[0] *= r;
    this._components[1] *= g;
    this._components[2] *= b;
    this._components[3] *= a;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r = this._int >> 16 & 255;
    let g = this._int >> 8 & 255;
    let b = this._int & 255;
    if (applyToRGB) {
      r = r * alpha + 0.5 | 0;
      g = g * alpha + 0.5 | 0;
      b = b * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r, g, b] = this._components;
    this._components[0] = Math.round(r * steps) / steps;
    this._components[1] = Math.round(g * steps) / steps;
    this._components[2] = Math.round(b * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r, g, b, a] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }
  normalize(value) {
    let r;
    let g;
    let b;
    let a;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255;
      g = (int >> 8 & 255) / 255;
      b = (int & 255) / 255;
      a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r, g, b, a = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r, g, b, a = 255] = value;
      r /= 255;
      g /= 255;
      b /= 255;
      a /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = w(value);
      if (color.isValid()) {
        ({ r, g, b, a } = color.rgba);
        r /= 255;
        g /= 255;
        b /= 255;
      }
    }
    if (r !== void 0) {
      this._components[0] = r;
      this._components[1] = g;
      this._components[2] = b;
      this._components[3] = a;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    });
    return value;
  }
};
let Color_Color = _Color;
Color_Color.shared = new _Color();
Color_Color.temp = new _Color();
Color_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;


//# sourceMappingURL=Color.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/hex.mjs



function hex2rgb(hex, out = []) {
  deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return Color_Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return Color_Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return Color_Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return Color_Color.shared.setValue(rgb).toNumber();
}


//# sourceMappingURL=hex.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/premultiply.mjs




function mapPremultipliedBlendModes() {
  const pm = [];
  const npm = [];
  for (let i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[lib_BLEND_MODES.NORMAL_NPM] = lib_BLEND_MODES.NORMAL;
  pm[lib_BLEND_MODES.ADD_NPM] = lib_BLEND_MODES.ADD;
  pm[lib_BLEND_MODES.SCREEN_NPM] = lib_BLEND_MODES.SCREEN;
  npm[lib_BLEND_MODES.NORMAL] = lib_BLEND_MODES.NORMAL_NPM;
  npm[lib_BLEND_MODES.ADD] = lib_BLEND_MODES.ADD_NPM;
  npm[lib_BLEND_MODES.SCREEN] = lib_BLEND_MODES.SCREEN_NPM;
  const array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return Color_Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return Color_Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return Color_Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}


//# sourceMappingURL=premultiply.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/const.mjs
const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;


//# sourceMappingURL=const.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs
function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}


//# sourceMappingURL=createIndicesForQuads.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/getBufferType.mjs
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}


//# sourceMappingURL=getBufferType.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs


const map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}


//# sourceMappingURL=interleaveTypedArrays.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/pow2.mjs
function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  let r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  let shift = (v > 255 ? 1 : 0) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 15 ? 1 : 0) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 3 ? 1 : 0) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}


//# sourceMappingURL=pow2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}


//# sourceMappingURL=removeItems.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/sign.mjs
function sign(n) {
  if (n === 0)
    return 0;
  return n < 0 ? -1 : 1;
}


//# sourceMappingURL=sign.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/uid.mjs
let nextUid = 0;
function uid() {
  return ++nextUid;
}


//# sourceMappingURL=uid.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/BoundingBox.mjs
const _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
let BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);


//# sourceMappingURL=BoundingBox.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/caches.mjs
const ProgramCache = {};
const TextureCache = /* @__PURE__ */ Object.create(null);
const BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}


//# sourceMappingURL=caches.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs


class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}


//# sourceMappingURL=CanvasRenderTarget.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs


function checkRow(data, width, y) {
  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x, top, bottom) {
  const stride = 4 * width;
  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas;
  const context = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new BoundingBox(left, top, right, bottom);
}


//# sourceMappingURL=getCanvasBoundingBox.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/trimCanvas.mjs


function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context = canvas.getContext("2d");
    if (context === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
}


//# sourceMappingURL=trimCanvas.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs


function decomposeDataUri(dataUri) {
  const dataUriMatch = DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}


//# sourceMappingURL=decomposeDataUri.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs


let tempAnchor;
function determineCrossOrigin(url$1, loc = globalThis.location) {
  if (url$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1;
  const parsedUrl = url_url.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}


//# sourceMappingURL=determineCrossOrigin.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs



function getResolutionOfUrl(url, defaultValue = 1) {
  const resolution = settings.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue;
}


//# sourceMappingURL=getResolutionOfUrl.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/index.mjs




























//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/extensions/lib/index.mjs
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type].push(ext);
        } else {
          handlers[type](ext);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type].forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  handleByMap(type, map) {
    return this.handle(type, (extension) => {
      map[extension.name] = extension.ref;
    }, (extension) => {
      delete map[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority));
    }, (extension) => {
      const index = list.indexOf(extension.ref);
      if (index !== -1) {
        list.splice(index, 1);
      }
    });
  }
};


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}


//# sourceMappingURL=ViewableBuffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs
const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += `if(test == ${i}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}


//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/State.mjs


const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
class State {
  constructor() {
    this.data = 0;
    this.blendMode = lib_BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== lib_BLEND_MODES.NONE;
    this._blendMode = value;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}


//# sourceMappingURL=State.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs
const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i = INSTALLED.length - 1; i >= 0; --i) {
    const ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}


//# sourceMappingURL=autoDetectResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/Runner.mjs
class Runner_Runner {
  constructor(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name, items } = this;
    this._aliasCount++;
    for (let i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner_Runner.prototype, {
  dispatch: { value: Runner_Runner.prototype.emit },
  run: { value: Runner_Runner.prototype.emit }
});


//# sourceMappingURL=Runner.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/Resource.mjs


class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner_Runner("setRealSize");
    this.onUpdate = new Runner_Runner("update");
    this.onError = new Runner_Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}


//# sourceMappingURL=Resource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs



class BufferResource extends Resource {
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}


//# sourceMappingURL=BufferResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/BaseTexture.mjs







const defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
const _BaseTexture = class extends eventemitter3 {
  constructor(resource = null, options = null) {
    super();
    options = Object.assign({}, _BaseTexture.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = uid();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    if (this._mipmap !== value) {
      this._mipmap = value;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    if (this._scaleMode !== value) {
      this._scaleMode = value;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    if (this._wrapMode !== value) {
      this._wrapMode = value;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${uid()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new BufferResource(buffer, { width, height });
    const type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
let BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: SCALE_MODES.LINEAR,
  wrapMode: lib_WRAP_MODES.CLAMP,
  alphaMode: ALPHA_MODES.UNPACK,
  target: TARGETS.TEXTURE_2D,
  format: FORMATS.RGBA,
  type: TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;


//# sourceMappingURL=BaseTexture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs


class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}


//# sourceMappingURL=BatchDrawCall.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Buffer.mjs



let UID = 0;
class Buffer_Buffer {
  constructor(data, _static = true, index = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new Runner_Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value) {
    this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer_Buffer(data);
  }
}


//# sourceMappingURL=Buffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Attribute.mjs


class Attribute {
  constructor(buffer, size = 0, normalized = false, type = TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer, size, normalized, type, stride) {
    return new Attribute(buffer, size, normalized, type, stride);
  }
}


//# sourceMappingURL=Attribute.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs


const interleaveTypedArrays_map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays_interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = getBufferType(array);
    if (!views[type]) {
      views[type] = new interleaveTypedArrays_map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}


//# sourceMappingURL=interleaveTypedArrays.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Geometry.mjs







const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
let Geometry_UID = 0;
const Geometry_map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = Geometry_UID++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner_Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer_Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer_Buffer(buffer);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer, size, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer) {
    if (!(buffer instanceof Buffer_Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer_Buffer(buffer);
    }
    buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (!this.buffers.includes(buffer)) {
      this.buffers.push(buffer);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new Buffer_Buffer();
    let i;
    for (i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays_interleaveTypedArrays(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry();
    for (let i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new Buffer_Buffer(this.buffers[i].data.slice(0));
    }
    for (const i in this.attributes) {
      const attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry();
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        sizes[j] = sizes[j] || 0;
        sizes[j] += geometry.buffers[j].data.length;
        offsets[j] = 0;
      }
    }
    for (let i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new Geometry_map[getBufferType(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new Buffer_Buffer(arrays[i]);
    }
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        arrays[j].set(geometry.buffers[j].data, offsets[j]);
        offsets[j] += geometry.buffers[j].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (const i in geometry.attributes) {
        const attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (let i = 0; i < geometries.length; i++) {
        const indexBufferData = geometries[i].indexBuffer.data;
        for (let j = 0; j < indexBufferData.length; j++) {
          geometryOut.indexBuffer.data[j + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}


//# sourceMappingURL=Geometry.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs




class BatchGeometry extends Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new Buffer_Buffer(null, _static, false);
    this._indexBuffer = new Buffer_Buffer(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}


//# sourceMappingURL=BatchGeometry.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/const.mjs
const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});


//# sourceMappingURL=const.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Point.mjs
class Point {
  constructor(x = 0, y = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  copyTo(p) {
    p.set(this.x, this.y);
    return p;
  }
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}


//# sourceMappingURL=Point.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Rectangle.mjs



const tempPoints = [new Point(), new Point(), new Point(), new Point()];
class Rectangle {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s * (lb.y - lt.y);
    const ny = s * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s * (lt.y - rt.y);
    const my = s * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}


//# sourceMappingURL=Rectangle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Circle.mjs



class Circle {
  constructor(x = 0, y = 0, radius = 0) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  getBounds() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}


//# sourceMappingURL=Circle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Ellipse.mjs



class Ellipse {
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x;
    this.y = y;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x - this.x) / this.width;
    let normy = (y - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}


//# sourceMappingURL=Ellipse.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Polygon.mjs


class Polygon {
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x, y) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2];
      const yi = this.points[i * 2 + 1];
      const xj = this.points[j * 2];
      const yj = this.points[j * 2 + 1];
      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}


//# sourceMappingURL=Polygon.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs


class RoundedRectangle {
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        let dx = x - (this.x + radius);
        let dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}


//# sourceMappingURL=RoundedRectangle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Matrix.mjs



class Matrix {
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point();
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point();
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  }
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}


//# sourceMappingURL=Matrix.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/groupD8.mjs


const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};


//# sourceMappingURL=groupD8.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/ObservablePoint.mjs
class ObservablePoint {
  constructor(cb, scope, x = 0, y = 0) {
    this._x = x;
    this._y = y;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p) {
    p.set(this._x, this._y);
    return p;
  }
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
}


//# sourceMappingURL=ObservablePoint.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Transform.mjs



const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
let Transform = _Transform;
Transform.IDENTITY = new _Transform();


//# sourceMappingURL=Transform.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/index.mjs













//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram.mjs
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";


//# sourceMappingURL=defaultProgram.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram2.mjs
var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";


//# sourceMappingURL=defaultProgram2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs
const uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];


//# sourceMappingURL=uniformParsers.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs


const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
const GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i in group.uniforms) {
    const data = uniformData[i];
    if (!data) {
      if (group.uniforms[i]?.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i];
    let parsed = false;
    for (let j = 0; j < uniformParsers.length; j++) {
      if (uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}


//# sourceMappingURL=generateUniformsSync.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs



const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = settings.ADAPTER.createCanvas();
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}


//# sourceMappingURL=getTestContext.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs



let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}


//# sourceMappingURL=getMaxFragmentPrecision.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs
const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}


//# sourceMappingURL=mapSize.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapType.mjs
let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}


//# sourceMappingURL=mapType.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs


function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}


//# sourceMappingURL=setPrecision.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/index.mjs












//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Program.mjs








let Program_UID = 0;
const nameCache = {};
const _Program = class {
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = Program_UID++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += `-${nameCache[name]}`;
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
      this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, PRECISION.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return defaultVertex;
  }
  static get defaultFragmentSrc() {
    return defaultFragment;
  }
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
    }
    return program;
  }
};
let Program = _Program;
Program.defaultVertexPrecision = PRECISION.HIGH;
Program.defaultFragmentPrecision = isMobile_isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;


//# sourceMappingURL=Program.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/UniformGroup.mjs



let UniformGroup_UID = 0;
class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UniformGroup_UID++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer_Buffer) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer_Buffer(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}


//# sourceMappingURL=UniformGroup.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Shader.mjs




class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
    this.disposeRunner = new Runner_Runner("disposeShader");
  }
  checkUniformExists(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (const i in group.uniforms) {
      const uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}


//# sourceMappingURL=Shader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs





class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += `if(vTextureId < ${i}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}


//# sourceMappingURL=BatchShaderGenerator.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs
class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  }
}


//# sourceMappingURL=BatchTextureArray.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs


function canUploadSameBuffer() {
  return !isMobile_isMobile.apple.device;
}


//# sourceMappingURL=canUploadSameBuffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs


function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator = settings.ADAPTER.getNavigator();
  if (isMobile_isMobile.tablet || isMobile_isMobile.phone) {
    if (isMobile_isMobile.apple.device) {
      const match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile_isMobile.android.device) {
      const match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}


//# sourceMappingURL=maxRecommendedTextures.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs
class ObjectRenderer {
  constructor(renderer) {
    this.renderer = renderer;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}


//# sourceMappingURL=ObjectRenderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture.mjs
var texture_defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";


//# sourceMappingURL=texture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture2.mjs
var texture2_defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";


//# sourceMappingURL=texture2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs



















const _BatchRenderer = class extends ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.setShaderGenerator();
    this.geometryClass = BatchGeometry;
    this.vertexSize = 6;
    this.state = State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  get MAX_TEXTURES() {
    deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return texture2_defaultVertex;
  }
  static get defaultFragmentTemplate() {
    return texture_defaultFragment;
  }
  setShaderGenerator({
    vertex = _BatchRenderer.defaultVertexSrc,
    fragment = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (let i = 0; i < this.maxTextures; i++) {
      this._tempBoundTextures[i] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i = 0; i < this._bufferSize; ++i) {
      const tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i = start; i < finish; ++i) {
      const sprite = elements[i];
      const tex = sprite._texture.baseTexture;
      const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j = 0; j < texArray.count; j++) {
      textureSystem.bind(texArray.elements[j], texArray.ids[j]);
      texArray.elements[j] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i = 0; i < dcCount; i++) {
      const { texArray, type, size, start, blend } = drawCalls[i];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size) {
    const roundedP2 = nextPow2(Math.ceil(size / 8));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  }
  getIndexBuffer(size) {
    const roundedP2 = nextPow2(Math.ceil(size / 12));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = Color_Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  }
};
let BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
extensions.add(BatchRenderer);


//# sourceMappingURL=BatchRenderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter.mjs
var defaultFilter_defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";


//# sourceMappingURL=defaultFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter2.mjs
var defaultFilter2_defaultVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";


//# sourceMappingURL=defaultFilter2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/Filter.mjs







const _Filter = class extends Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new State();
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  static get defaultVertexSrc() {
    return defaultFilter2_defaultVertex;
  }
  static get defaultFragmentSrc() {
    return defaultFilter_defaultFragment;
  }
};
let Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = MSAA_QUALITY.NONE;


//# sourceMappingURL=Filter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs



class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new Color_Color(0);
    this.alpha = 1;
  }
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options;
    const color = background ?? backgroundColor;
    if (color !== void 0) {
      this.color = color;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions.add(BackgroundSystem);


//# sourceMappingURL=BackgroundSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchSystem.mjs



class BatchSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j = 0;
    for (let i = 0; i < count; i++) {
      const tex = elements[i];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j < maxTextures) {
        const bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j;
        tex._batchLocation = j;
        boundTextures[j] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "batch"
};
extensions.add(BatchSystem);


//# sourceMappingURL=BatchSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/context/ContextSystem.mjs




let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.useContextAlpha = options.useContextAlpha;
      this.powerPreference = options.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== void 0) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  createContext(canvas, options) {
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== void 0) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "context"
};
extensions.add(ContextSystem);


//# sourceMappingURL=ContextSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/DepthResource.mjs



class DepthResource extends BufferResource {
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}


//# sourceMappingURL=DepthResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs





class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner_Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index = 0, texture) {
    this.colorTextures[index] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i = 0; i < this.colorTextures.length; i++) {
      const texture = this.colorTextures[i];
      const resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}


//# sourceMappingURL=Framebuffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs





class BaseRenderTexture extends BaseTexture {
  constructor(options = {}) {
    if (typeof options === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample ?? (options.multisample = MSAA_QUALITY.NONE);
    super(null, options);
    this.mipmap = MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new Color_Color([0, 0, 0, 0]);
    this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}


//# sourceMappingURL=BaseRenderTexture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs




class BaseImageResource extends Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer, baseTexture, glTexture, source) {
    const gl = renderer.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}


//# sourceMappingURL=BaseImageResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs




class ImageResource extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (typeof source === "string") {
      const imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve(this.process());
        } else {
          resolve(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r) => r.blob()).then((blob) => createImageBitmap(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}


//# sourceMappingURL=ImageResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureUvs.mjs


class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate);
      this.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate);
      this.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate);
      this.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate);
      this.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}


//# sourceMappingURL=TextureUvs.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/Texture.mjs







const DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
class Texture extends eventemitter3 {
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate || 0);
    if (rotate === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if (resource?.url && TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix}-${uid()}`;
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${uid()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture(new BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture(source);
      Texture.addToCache(texture, cacheId);
    }
    return texture;
  }
  static fromURL(url, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);
    const texture = Texture.from(url, Object.assign({ resourceOptions }, options), false);
    const resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(() => Promise.resolve(texture));
  }
  static fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
  }
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.defaultOptions.scaleMode,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    const { resource } = baseTexture;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    const texture = new Texture(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise((resolve) => {
      texture.baseTexture.once("loaded", () => resolve(texture));
    });
  }
  static addToCache(texture, id) {
    if (id) {
      if (!texture.textureCacheIds.includes(id)) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id] && TextureCache[id] !== texture) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      TextureCache[id] = texture;
    }
  }
  static removeFromCache(texture) {
    if (typeof texture === "string") {
      const textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i = 0; i < texture.textureCacheIds.length; ++i) {
        if (TextureCache[texture.textureCacheIds[i]] === texture) {
          delete TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x, y, width, height } = frame;
    const xNotFit = x + width > this.baseTexture.width;
    const yNotFit = y + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new BaseTexture());
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.ADAPTER.createCanvas(16, 16);
      const context = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context.fillStyle = "white";
      context.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}


//# sourceMappingURL=Texture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs



class RenderTexture extends Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options) {
    return new RenderTexture(new BaseRenderTexture(options));
  }
}


//# sourceMappingURL=RenderTexture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs





class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i in this.texturePool) {
        const textures = this.texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (const i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      const textures = this.texturePool[i];
      if (textures) {
        for (let j = 0; j < textures.length; j++) {
          textures[j].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;


//# sourceMappingURL=RenderTexturePool.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/Quad.mjs


class Quad extends Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}


//# sourceMappingURL=Quad.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/QuadUv.mjs



class QuadUv extends Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new Buffer_Buffer(this.vertices);
    this.uvBuffer = new Buffer_Buffer(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x = 0;
    let y = 0;
    this.uvs[0] = x;
    this.uvs[1] = y;
    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;
    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    x = destinationFrame.x;
    y = destinationFrame.y;
    this.vertices[0] = x;
    this.vertices[1] = y;
    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;
    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;
    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}


//# sourceMappingURL=QuadUv.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterState.mjs



class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}


//# sourceMappingURL=FilterState.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterSystem.mjs









const FilterSystem_tempPoints = [new Point(), new Point(), new Point(), new Point()];
const tempMatrix = new Matrix();
class FilterSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters) {
    const renderer = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new FilterState();
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters[0].resolution;
    let multisample = filters[0].multisample;
    let padding = filters[0].padding;
    let autoFit = filters[0].autoFit;
    let legacy = filters[0].legacy ?? true;
    for (let i = 1; i < filters.length; i++) {
      const filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || (filter.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer.projection.transform) {
      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        const t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(DRAW_MODES.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = FilterSystem_tempPoints[0];
    const lb = FilterSystem_tempPoints[1];
    const rt = FilterSystem_tempPoints[2];
    const rb = FilterSystem_tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a, b, c, d } = transform;
      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "filter"
};
extensions.add(FilterSystem);


//# sourceMappingURL=FilterSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs


class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}


//# sourceMappingURL=GLFramebuffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs







const tempRectangle = new Rectangle();
class FramebufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i = 0; i < framebuffer.colorTextures.length; i++) {
        const tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x, y, width, height) {
    const v = this.viewport;
    x = Math.round(x);
    y = Math.round(y);
    width = Math.round(width);
    height = Math.round(height);
    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
      v.x = x;
      v.y = y;
      v.width = width;
      v.height = height;
      this.gl.viewport(x, y, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r, g, b, a, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r, g, b, a);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w = framebuffer.width;
    const h = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions.add(FramebufferSystem);


//# sourceMappingURL=FramebufferSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs




const GeometrySystem_byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);
        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);
        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j in buffers) {
      tempStride[j] = 0;
      tempStart[j] = 0;
    }
    for (const j in attributes) {
      if (!attributes[j].size && program.attributeData[j]) {
        attributes[j].size = program.attributeData[j].size;
      } else if (!attributes[j].size) {
        console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j].buffer] += attributes[j].size * GeometrySystem_byteSizeMap[attributes[j].type];
    }
    for (const j in attributes) {
      const attribute = attributes[j];
      const attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * GeometrySystem_byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * GeometrySystem_byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = this.renderer?.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i = 0; i < buffers.length; i++) {
        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i = 0; i < all.length; i++) {
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j];
      const buffer = buffers[attribute.buffer];
      const glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = program.attributeData[j].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "geometry"
};
extensions.add(GeometrySystem);


//# sourceMappingURL=GeometrySystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs


const tempMat = new Matrix();
class TextureMatrix {
  constructor(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i];
      const y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}


//# sourceMappingURL=TextureMatrix.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.mjs
var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";


//# sourceMappingURL=spriteMaskFilter2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.mjs
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";


//# sourceMappingURL=spriteMaskFilter3.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs






class SpriteMaskFilter extends Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    super(vertexSrc || vertex, fragmentSrc || fragment, uniforms);
    this.maskSprite = sprite;
    this.maskMatrix = new Matrix();
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}


//# sourceMappingURL=SpriteMaskFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskData.mjs



class MaskData {
  constructor(maskObject = null) {
    this.type = MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    if (value) {
      if (this._filters) {
        this._filters[0] = value;
      } else {
        this._filters = [value];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}


//# sourceMappingURL=MaskData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskSystem.mjs





class MaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d = this.maskDataPool.pop() || new MaskData();
      d.pooled = true;
      d.maskObject = maskDataOrTarget;
      maskData = d;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    }
    if (maskData.type === MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
        default:
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES.SCISSOR;
    } else {
      maskData.type = MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    const renderer = this.renderer;
    const renderTextureSystem = renderer.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = maskData.multisample ?? renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "mask"
};
extensions.add(MaskSystem);


//# sourceMappingURL=MaskSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs
class AbstractMaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}


//# sourceMappingURL=AbstractMaskSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs





const ScissorSystem_tempMatrix = new Matrix();
const rectPool = [];
const _ScissorSystem = class extends AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer } = this;
    const renderTextureSystem = renderer.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a, b, c, d } = matrix;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? ScissorSystem_tempMatrix.copyFrom(transform) : ScissorSystem_tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y;
    if (this.renderer.renderTexture.current) {
      y = rect.y;
    } else {
      y = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  }
};
let ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "scissor"
};
extensions.add(ScissorSystem);


//# sourceMappingURL=ScissorSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/StencilSystem.mjs




class StencilSystem extends AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "stencil"
};
extensions.add(StencilSystem);


//# sourceMappingURL=StencilSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs



class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o in staticMap) {
      this.plugins[o] = new staticMap[o](this.renderer);
    }
  }
  destroy() {
    for (const o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
  }
}
PluginSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions.add(PluginSystem);


//# sourceMappingURL=PluginSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs



class ProjectionSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix;
    const sign = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "projection"
};
extensions.add(ProjectionSystem);


//# sourceMappingURL=ProjectionSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs




const tempTransform = new Transform();
class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._tempMatrix = new Matrix();
  }
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions.add(GenerateTextureSystem);


//# sourceMappingURL=GenerateTextureSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs




const tempRect = new Rectangle();
const tempRect2 = new Rectangle();
class RenderTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer._view.screen.width;
        tempRect.height = renderer._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color = Color_Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color.premultiply(color.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x, y, width, height } = this.viewportFrame;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions.add(RenderTextureSystem);


//# sourceMappingURL=RenderTextureSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/GLProgram.mjs
class IGLUniformData {
}
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}


//# sourceMappingURL=GLProgram.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}


//# sourceMappingURL=compileShader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs
function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}


//# sourceMappingURL=defaultValue.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs



function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}


//# sourceMappingURL=getAttributeData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs



function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}


//# sourceMappingURL=getUniformData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}


//# sourceMappingURL=logProgramError.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs







function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program.uniformData) {
    const data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}


//# sourceMappingURL=generateProgram.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs




function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
const GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort((a, b) => a.index - b.index);
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const uniform = group.uniforms[uboElement.data.name];
    const name = uboElement.data.name;
    let parsed = false;
    for (let j = 0; j < uniformParsers.length; j++) {
      const uniformParser = uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size2 = mapSize(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size2 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}


//# sourceMappingURL=generateUniformBufferSync.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs
let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}


//# sourceMappingURL=unsafeEvalSupported.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs







let ShaderSystem_UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  constructor(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = ShaderSystem_UID++;
  }
  systemCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "shader"
};
extensions.add(ShaderSystem);


//# sourceMappingURL=ShaderSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/startup/StartupSystem.mjs


class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options);
    if (options.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer.rendererLogId} - https://pixijs.com`);
    }
    renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions.add(StartupSystem);


//# sourceMappingURL=StartupSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs


function mapWebGLBlendModesToPixi(gl, array = []) {
  array[lib_BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[lib_BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.NONE] = [0, 0];
  array[lib_BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[lib_BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[lib_BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[lib_BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[lib_BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[lib_BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[lib_BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[lib_BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}


//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/StateSystem.mjs





const StateSystem_BLEND = 0;
const StateSystem_OFFSET = 1;
const StateSystem_CULLING = 2;
const StateSystem_DEPTH_TEST = 3;
const StateSystem_WINDING = 4;
const StateSystem_DEPTH_MASK = 5;
const _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = lib_BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[StateSystem_BLEND] = this.setBlend;
    this.map[StateSystem_OFFSET] = this.setOffset;
    this.map[StateSystem_CULLING] = this.setCullFace;
    this.map[StateSystem_DEPTH_TEST] = this.setDepthTest;
    this.map[StateSystem_WINDING] = this.setFrontFace;
    this.map[StateSystem_DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this.updateCheck(_StateSystem.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  setBlendMode(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModes[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
let StateSystem = _StateSystem;
StateSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "state"
};
extensions.add(StateSystem);


//# sourceMappingURL=StateSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/system/SystemManager.mjs



class SystemManager extends eventemitter3 {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key) => config.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key) => !priority.includes(key))
    ];
    for (const i of orderByPriority) {
      this.addSystem(config.systems[i], i);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new Runner_Runner(runnerId);
    });
  }
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = {};
  }
}


//# sourceMappingURL=SystemManager.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs



const _TextureGCSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i = 0; i < managedTextures.length; i++) {
      const texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j = 0;
      for (let i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j++] = managedTextures[i];
        }
      }
      managedTextures.length = j;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (let i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
let TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "textureGC"
};
extensions.add(TextureGCSystem);


//# sourceMappingURL=TextureGCSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/GLTexture.mjs


class GLTexture {
  constructor(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES.UNSIGNED_BYTE;
    this.internalFormat = FORMATS.RGBA;
    this.samplerType = 0;
  }
}


//# sourceMappingURL=GLTexture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs


function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8,
        [FORMATS.RGB]: gl.RGB8,
        [FORMATS.RG]: gl.RG8,
        [FORMATS.RED]: gl.R8,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [FORMATS.RG_INTEGER]: gl.RG8UI,
        [FORMATS.RED_INTEGER]: gl.R8UI,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8_SNORM,
        [FORMATS.RGB]: gl.RGB8_SNORM,
        [FORMATS.RG]: gl.RG8_SNORM,
        [FORMATS.RED]: gl.R8_SNORM,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [FORMATS.RGB_INTEGER]: gl.RGB8I,
        [FORMATS.RG_INTEGER]: gl.RG8I,
        [FORMATS.RED_INTEGER]: gl.R8I
      },
      [TYPES.UNSIGNED_SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [FORMATS.RG_INTEGER]: gl.RG16UI,
        [FORMATS.RED_INTEGER]: gl.R16UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [TYPES.SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [FORMATS.RGB_INTEGER]: gl.RGB16I,
        [FORMATS.RG_INTEGER]: gl.RG16I,
        [FORMATS.RED_INTEGER]: gl.R16I
      },
      [TYPES.UNSIGNED_INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [FORMATS.RG_INTEGER]: gl.RG32UI,
        [FORMATS.RED_INTEGER]: gl.R32UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [TYPES.INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [FORMATS.RGB_INTEGER]: gl.RGB32I,
        [FORMATS.RG_INTEGER]: gl.RG32I,
        [FORMATS.RED_INTEGER]: gl.R32I
      },
      [TYPES.FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA32F,
        [FORMATS.RGB]: gl.RGB32F,
        [FORMATS.RG]: gl.RG32F,
        [FORMATS.RED]: gl.R32F,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [TYPES.HALF_FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA16F,
        [FORMATS.RGB]: gl.RGB16F,
        [FORMATS.RG]: gl.RG16F,
        [FORMATS.RED]: gl.R16F
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB565
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA4
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGB5_A1
      },
      [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [FORMATS.RGBA]: gl.RGB10_A2,
        [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [FORMATS.RGB]: gl.RGB9_E5
      },
      [TYPES.UNSIGNED_INT_24_8]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA,
        [FORMATS.RGB]: gl.RGB,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
}


//# sourceMappingURL=mapTypeAndFormatToInternalFormat.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureSystem.mjs







class TextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  }
  bind(texture, location = 0) {
    const { gl } = this;
    texture = texture?.castToBaseTexture();
    if (texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  }
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (let i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i = maxTextures - 1; i >= 0; --i) {
      const tex = boundTextures[i];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture) {
    const glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  }
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource?.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture.realWidth;
      const height = texture.realHeight;
      const gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  }
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          removeItems(this.managedTextures, i, 1);
        }
      }
    }
  }
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = lib_WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource?.style(this.renderer, texture, glTexture)) {
    } else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  }
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "texture"
};
extensions.add(TextureSystem);


//# sourceMappingURL=TextureSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs


class TransformFeedbackSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    if (shader) {
      renderer.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i = 0; i < tf.buffers.length; i++) {
      const buffer = tf.buffers[i];
      if (!buffer)
        continue;
      renderer.buffer.update(buffer);
      buffer._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions.add(TransformFeedbackSystem);


//# sourceMappingURL=TransformFeedbackSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/view/ViewSystem.mjs




class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  init(options) {
    this.screen = new Rectangle(0, 0, options.width, options.height);
    this.element = options.view || settings.ADAPTER.createCanvas();
    this.resolution = options.resolution || settings.RESOLUTION;
    this.autoDensity = !!options.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    if (removeView) {
      this.element.parentNode?.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions.add(ViewSystem);


//# sourceMappingURL=ViewSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/systems.mjs





















//# sourceMappingURL=systems.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/settings.mjs














settings.PREFER_ENV = ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
settings.RENDER_OPTIONS = {
  ...ContextSystem.defaultOptions,
  ...BackgroundSystem.defaultOptions,
  ...ViewSystem.defaultOptions,
  ...StartupSystem.defaultOptions
};
Object.defineProperties(settings, {
  WRAP_MODE: {
    get() {
      return BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  SCALE_MODE: {
    get() {
      return BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      BaseTexture.defaultOptions.mipmap = value;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return Filter.defaultResolution;
    },
    set(value) {
      Filter.defaultResolution = value;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return Filter.defaultMultisample;
    },
    set(value) {
      Filter.defaultMultisample = value;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      BatchRenderer.defaultMaxTextures = value;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.defaultBatchSize;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      BatchRenderer.defaultBatchSize = value;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      BatchRenderer.canUploadSameBuffer = value;
    }
  },
  GC_MODE: {
    get() {
      return TextureGCSystem.defaultMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      TextureGCSystem.defaultMode = value;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      TextureGCSystem.defaultMaxIdle = value;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return Program.defaultVertexPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      Program.defaultVertexPrecision = value;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return Program.defaultFragmentPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      Program.defaultFragmentPrecision = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/const.mjs
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});


//# sourceMappingURL=const.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerListener.mjs
class TickerListener {
  constructor(fn, context = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context;
    this.priority = priority;
    this.once = once;
  }
  match(fn, context = null) {
    return this.fn === fn && this.context === context;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}


//# sourceMappingURL=TickerListener.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/Ticker.mjs



const _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context, priority));
  }
  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
let Ticker = _Ticker;
Ticker.targetFPMS = 0.06;


//# sourceMappingURL=Ticker.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/settings.mjs





Object.defineProperties(settings, {
  TARGET_FPMS: {
    get() {
      return Ticker.targetFPMS;
    },
    set(value) {
      deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      Ticker.targetFPMS = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerPlugin.mjs




class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = ExtensionType.Application;
extensions.add(TickerPlugin);


//# sourceMappingURL=TickerPlugin.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/index.mjs




//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/autoDetectRenderer.mjs


const renderers = [];
extensions.handleByList(ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers) {
    if (RendererType.test(options)) {
      return new RendererType(options);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
}


//# sourceMappingURL=autoDetectRenderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/default.mjs
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";


//# sourceMappingURL=default.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/defaultFilter.mjs
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";


//# sourceMappingURL=defaultFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/index.mjs



const fragments_defaultVertex = $defaultVertex;
const defaultFilterVertex = $defaultFilterVertex;


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs



class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY.HIGH) {
      this.multisample = MSAA_QUALITY.HIGH;
    } else if (samples >= MSAA_QUALITY.MEDIUM) {
      this.multisample = MSAA_QUALITY.MEDIUM;
    } else if (samples >= MSAA_QUALITY.LOW) {
      this.multisample = MSAA_QUALITY.LOW;
    } else {
      this.multisample = MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions.add(MultisampleSystem);


//# sourceMappingURL=MultisampleSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs
class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}


//# sourceMappingURL=GLBuffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs



class BufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer, index) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer, index, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  }
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i = 0; i < all.length; i++) {
      this.dispose(this.managedBuffers[all[i]], contextLost);
    }
  }
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl } = this;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "buffer"
};
extensions.add(BufferSystem);


//# sourceMappingURL=BufferSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs


class ObjectRendererSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture;
    let clear;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer.runners.prerender.emit();
    renderer.emit("prerender");
    renderer.projection.transform = transform;
    if (renderer.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer.renderTexture.bind(renderTexture);
    renderer.batch.currentRenderer.start();
    if (clear ?? renderer.background.clearBeforeRender) {
      renderer.renderTexture.clear();
    }
    displayObject.render(renderer);
    renderer.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options.blit) {
        renderer.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer.runners.postrender.emit();
    renderer.projection.transform = null;
    renderer.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions.add(ObjectRendererSystem);


//# sourceMappingURL=ObjectRendererSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/Renderer.mjs








const _Renderer = class extends SystemManager {
  constructor(options) {
    super();
    this.type = RENDERER_TYPE.WEBGL;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options) {
      deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options;
    this.startup.run(this.options);
  }
  static test(options) {
    if (options?.forceCanvas) {
      return false;
    }
    return isWebGLSupported();
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value) {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value;
  }
  get backgroundAlpha() {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value) {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value;
  }
  get powerPreference() {
    deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
let Renderer = _Renderer;
Renderer.extension = {
  type: ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
extensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
extensions.add(Renderer);


//# sourceMappingURL=Renderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs




class AbstractMultiResource extends Resource {
  constructor(length, options) {
    const { width, height } = options || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i = 0; i < length; i++) {
      const partTexture = new BaseTexture();
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options) {
    for (let i = 0; i < this.length; i++) {
      if (!resources[i]) {
        continue;
      }
      if (resources[i].castToBaseTexture) {
        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
      } else if (resources[i] instanceof Resource) {
        this.addResourceAt(resources[i], i);
      } else {
        this.addResourceAt(autoDetectResource(resources[i], options), i);
      }
    }
  }
  dispose() {
    for (let i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index) {
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}


//# sourceMappingURL=AbstractMultiResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs



class ArrayResource extends AbstractMultiResource {
  constructor(source, options) {
    const { width, height } = options || {};
    let urls;
    let length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    super(length, { width, height });
    if (urls) {
      this.initFromArray(urls, options);
    }
  }
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer, texture, glTexture) {
    const { length, itemDirtyIds, items } = this;
    const { gl } = renderer;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (let i = 0; i < length; i++) {
      const item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}


//# sourceMappingURL=ArrayResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs


class CanvasResource extends BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas } = globalThis;
    if (OffscreenCanvas && source instanceof OffscreenCanvas) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}


//# sourceMappingURL=CanvasResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs



const _CubeResource = class extends AbstractMultiResource {
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  }
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      const side = this.items[i];
      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
let CubeResource = _CubeResource;
CubeResource.SIDES = 6;


//# sourceMappingURL=CubeResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs




class ImageBitmapResource extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    let baseSource;
    let url;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url = source;
    } else {
      baseSource = source;
      url = null;
    }
    super(baseSource);
    this.url = url;
    this.crossOrigin = options.crossOrigin ?? true;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve, reject) => {
      if (this.url === null) {
        resolve(this);
        return;
      }
      try {
        const response = await settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve(this);
      } catch (e) {
        if (this.destroyed)
          return;
        reject(e);
        this.onError.emit(e);
      }
    });
    return this._load;
  }
  upload(renderer, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}


//# sourceMappingURL=ImageBitmapResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs




const _SVGResource = class extends BaseImageResource {
  constructor(sourceBase64, options) {
    options = options || {};
    super(settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options.scale || 1;
    this._overrideWidth = options.width;
    this._overrideHeight = options.height;
    this._resolve = null;
    this._crossorigin = options.crossorigin;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${uid()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
let SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;


//# sourceMappingURL=SVGResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs



const _VideoResource = class extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i = 0; i < source.length; ++i) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i];
        src = src || source[i];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve) => {
      if (this.valid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
let VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};


//# sourceMappingURL=VideoResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/index.mjs






















INSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs


class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {};
    this.buffers = [];
    this.disposeRunner = new Runner("disposeTransformFeedback");
  }
  bindBuffer(index, buffer) {
    this.buffers[index] = buffer;
  }
  destroy() {
    this.disposeRunner.emit(this, false);
  }
}


//# sourceMappingURL=TransformFeedback.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/index.mjs





























































































const VERSION = "7.2.4";


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Bounds.mjs


class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a, b, c, d, tx, ty } = matrix;
    const x = a * point.x + c * point.y + tx;
    const y = b * point.x + d * point.y + ty;
    this.minX = Math.min(this.minX, x);
    this.maxX = Math.max(this.maxX, x);
    this.minY = Math.min(this.minY, y);
    this.maxY = Math.max(this.maxY, y);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = vertices[0];
    let y = vertices[1];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[2];
    y = vertices[3];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[4];
    y = vertices[5];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[6];
    y = vertices[7];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = a * x0 + c * y0 + tx;
    let y = b * x0 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const x = vertexData[i];
      const y = vertexData[i + 1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const rawX = vertices[i];
      const rawY = vertices[i + 1];
      const x = a * rawX + c * rawY + tx;
      const y = d * rawY + b * rawX + ty;
      minX = Math.min(minX, x - padX);
      maxX = Math.max(maxX, x + padX);
      minY = Math.min(minY, y - padY);
      maxY = Math.max(maxY, y + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area) {
    const _minX = bounds.minX > area.x ? bounds.minX : area.x;
    const _minY = bounds.minY > area.y ? bounds.minY : area.y;
    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}


//# sourceMappingURL=Bounds.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/DisplayObject.mjs



class DisplayObject extends eventemitter3 {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new Transform();
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new Bounds();
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds();
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x;
    this.position.y = y;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject();
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  get angle() {
    return this.transform.rotation * RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;


//# sourceMappingURL=DisplayObject.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Container.mjs



const Container_tempMatrix = new Matrix();
function sortChildren(a, b) {
  if (a.zIndex === b.zIndex) {
    return a._lastSortedIndex - b._lastSortedIndex;
  }
  return a.zIndex - b.zIndex;
}
const _Container = class extends DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index) {
    if (index < 0 || index > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index, 0, child);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("added", this);
    this.emit("childAdded", child, this, index);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index;
  }
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1);
    this.children.splice(index, 0, child);
    this.onChildrenChange(index);
  }
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    } else {
      const child = children[0];
      const index = this.children.indexOf(child);
      if (index === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
    }
    return children[0];
  }
  removeChildAt(index) {
    const child = this.getChildAt(index);
    child.parent = null;
    child.transform._parentID = -1;
    removeItems(this.children, index, 1);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].parent = null;
        if (removed[i].transform) {
          removed[i].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].emit("removed", this);
        this.emit("childRemoved", removed[i], this, i);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      child._lastSortedIndex = i;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = Container_tempMatrix.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer);
    } else if (this.cullArea) {
      return;
    }
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer);
      child.cullable = childCullable;
    }
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters?.length) {
      this.renderAdvanced(renderer);
    } else if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
  }
  renderAdvanced(renderer) {
    const filters = this.filters;
    const mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i = 0; i < filters.length; i++) {
        if (filters[i].enabled) {
          this._enabledFilters.push(filters[i]);
        }
      }
    }
    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value;
  }
};
let Container_Container = _Container;
Container_Container.defaultSortableChildren = false;
Container_Container.prototype.containerUpdateTransform = Container_Container.prototype.updateTransform;


//# sourceMappingURL=Container.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/settings.mjs




Object.defineProperties(settings, {
  SORTABLE_CHILDREN: {
    get() {
      return Container_Container.defaultSortableChildren;
    },
    set(value) {
      deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      Container_Container.defaultSortableChildren = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/index.mjs




//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/Sprite.mjs



const tempPoint = new Point();
const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends Container_Container {
  constructor(texture) {
    super();
    this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new Color_Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = lib_BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture || Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim = texture.trim;
    const orig = texture.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
  }
  _render(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options) {
    const texture = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite(texture);
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s = sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s = sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value || Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value) {
      if (value.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value.once("update", this._onTextureUpdate, this);
      }
    }
  }
}


//# sourceMappingURL=Sprite.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs




const _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      let data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  const cachedRenderTexture = renderer.renderTexture.current;
  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer.projection.transform;
  const renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  });
  const textureCacheId = `cacheAsBitmap_${uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext;
  const cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(settings.RESOLUTION);
  const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m = _tempMatrix;
  this.transform.localTransform.copyTo(m);
  m.invert();
  m.tx -= bounds.x;
  m.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.canvasContext.activeContext = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs


DisplayObject.prototype.name = null;
Container_Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (let i = 0, j = this.children.length; i < j; i++) {
    if (this.children[i].name === name) {
      return this.children[i];
    }
  }
  if (deep) {
    for (let i = 0, j = this.children.length; i < j; i++) {
      const child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-global-position/lib/index.mjs



DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point(), skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/alpha.mjs
var alpha_fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";


//# sourceMappingURL=alpha.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs



class AlphaFilter extends Filter {
  constructor(alpha = 1) {
    super(fragments_defaultVertex, alpha_fragment, { uAlpha: 1 });
    this.alpha = alpha;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}


//# sourceMappingURL=AlphaFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs
const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const generateBlurFragSource_fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = generateBlurFragSource_fragTemplate;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}


//# sourceMappingURL=generateBlurFragSource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs
const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}


//# sourceMappingURL=generateBlurVertSource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs




class BlurFilterPass extends Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource(kernelSize, horizontal);
    const fragSrc = generateBlurFragSource(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
      for (let i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
}


//# sourceMappingURL=BlurFilterPass.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs



class BlurFilter extends Filter {
  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}


//# sourceMappingURL=BlurFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.mjs
var colorMatrix_fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";


//# sourceMappingURL=colorMatrix.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs



class ColorMatrixFilter extends Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(defaultFilterVertex, colorMatrix_fragment, uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a, b) {
    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;
    return m;
  }
  brightness(b, multiply) {
    const matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  tint(color, multiply) {
    const [r, g, b] = Color_Color.shared.setValue(color).toArray();
    const matrix = [
      r,
      0,
      0,
      0,
      0,
      0,
      g,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w = 1 / 3;
    const sqrW = sqrt(w);
    const a00 = cosR + (1 - cosR) * w;
    const a01 = w * (1 - cosR) - sqrW * sinR;
    const a02 = w * (1 - cosR) + sqrW * sinR;
    const a10 = w * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w * (1 - cosR);
    const a12 = w * (1 - cosR) - sqrW * sinR;
    const a20 = w * (1 - cosR) - sqrW * sinR;
    const a21 = w * (1 - cosR) + sqrW * sinR;
    const a22 = cosR + w * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  contrast(amount, multiply) {
    const v = (amount || 0) + 1;
    const o = -0.5 * (v - 1);
    const matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  saturate(amount = 0, multiply) {
    const x = amount * 2 / 3 + 1;
    const y = (x - 1) * -0.5;
    const matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = Color_Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  predator(amount, multiply) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;


//# sourceMappingURL=ColorMatrixFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement.mjs
var displacement_fragment = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";


//# sourceMappingURL=displacement.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement2.mjs
var displacement2_vertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";


//# sourceMappingURL=displacement2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs




class DisplacementFilter extends Filter {
  constructor(sprite, scale) {
    const maskMatrix = new Matrix();
    sprite.renderable = false;
    super(displacement2_vertex, displacement_fragment, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    this.scale = new Point(scale, scale);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}


//# sourceMappingURL=DisplacementFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa.mjs
var fxaa_fragment = "varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n";


//# sourceMappingURL=fxaa.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa2.mjs
var fxaa2_vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";


//# sourceMappingURL=fxaa2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs




class FXAAFilter extends Filter {
  constructor() {
    super(fxaa2_vertex, fxaa_fragment);
  }
}


//# sourceMappingURL=FXAAFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/noise.mjs
var noise_fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";


//# sourceMappingURL=noise.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs



class NoiseFilter extends Filter {
  constructor(noise = 0.5, seed = Math.random()) {
    super(defaultFilterVertex, noise_fragment, {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise;
    this.seed = seed;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}


//# sourceMappingURL=NoiseFilter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters.mjs








const filters = {
  AlphaFilter: AlphaFilter,
  BlurFilter: BlurFilter,
  BlurFilterPass: BlurFilterPass,
  ColorMatrixFilter: ColorMatrixFilter,
  DisplacementFilter: DisplacementFilter,
  FXAAFilter: FXAAFilter,
  NoiseFilter: NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});


//# sourceMappingURL=filters.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventTicker.mjs


class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
const EventsTicker = new EventsTickerClass();


//# sourceMappingURL=EventTicker.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEvent.mjs


class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point();
    this.page = new Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}


//# sourceMappingURL=FederatedEvent.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs



class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new Point();
    this.movement = new Point();
    this.offset = new Point();
    this.global = new Point();
    this.screen = new Point();
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}


//# sourceMappingURL=FederatedMouseEvent.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs


class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}


//# sourceMappingURL=FederatedPointerEvent.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs


class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;


//# sourceMappingURL=FederatedWheelEvent.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventBoundary.mjs






const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new Point();
const tempLocalMapping = new Point();
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new eventemitter3();
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e.type];
    if (mappers) {
      for (let i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
  }
  hitTest(x, y) {
    EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e, type) {
    if (!e.target) {
      return;
    }
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    for (let i = composedPath.length - 2; i >= 0; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
  }
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--) {
      events.forEach((event) => {
        e.currentTarget = targets[i];
        this.notifyTarget(e, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location)) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location);
    }
    return false;
  }
  notifyTarget(e, type) {
    type = type ?? e.type;
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this.notifyListeners(e, type);
    }
  }
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerdown");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchstart");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e = this.createPointerEvent(from);
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover");
    if (isMouse)
      this.dispatchEvent(e, "mouseover");
    if (e.pointerType === "mouse")
      this.cursor = e.target?.cursor;
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerup");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchend");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e.composedPath().includes(currentTarget)) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length; i++) {
      if (propagationPath[i].parent === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  copyMouseData(from, to) {
    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (!listeners)
      return;
    if (!e.currentTarget.isInteractive())
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e.currentTarget.removeListener(type, listeners.fn, void 0, true);
      listeners.fn.call(listeners.context, e);
    } else {
      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once)
          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
        listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
}


//# sourceMappingURL=EventBoundary.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventSystem.mjs






const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class {
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "auto";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x, y) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
let EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
extensions.add(EventSystem);


//# sourceMappingURL=EventSystem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEventTarget.mjs





function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);
  },
  set interactive(value) {
    deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value;
    this.eventMode = value ? "static" : "auto";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context);
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context);
  },
  dispatchEvent(e) {
    if (!(e instanceof FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = false;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }
};
DisplayObject.mixin(FederatedDisplayObject);


//# sourceMappingURL=FederatedEventTarget.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/index.mjs








//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs
const accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};


//# sourceMappingURL=accessibleTarget.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs





DisplayObject.mixin(accessibleTarget);
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  constructor(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (isMobile_isMobile.tablet || isMobile_isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    this.renderer.view.parentNode?.appendChild(this.div);
  }
  deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    this.div.parentNode?.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this.updateAccessibleObjects(children[i]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (isMobile_isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x, y, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x}px`;
    div.style.top = `${y}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        removeItems(this.children, i, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e, type) {
    const { displayObject: target } = e.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  _onFocus(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e, ["mouseover"]);
  }
  _onFocusOut(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e, ["mouseout"]);
  }
  _onKeyDown(e) {
    if (e.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    ExtensionType.RendererPlugin,
    ExtensionType.CanvasRendererPlugin
  ]
};
extensions.add(AccessibilityManager);


//# sourceMappingURL=AccessibilityManager.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/Application.mjs



const _Application = class {
  constructor(options) {
    this.stage = new Container_Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
let Application = _Application;
Application._plugins = [];
extensions.handleByList(ExtensionType.Application, Application._plugins);


//# sourceMappingURL=Application.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/ResizePlugin.mjs


class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = ExtensionType.Application;
extensions.add(ResizePlugin);


//# sourceMappingURL=ResizePlugin.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/AssetExtension.mjs


const assetKeyMap = {
  loader: ExtensionType.LoadParser,
  resolver: ExtensionType.ResolveParser,
  cache: ExtensionType.CacheParser,
  detection: ExtensionType.DetectionParser
};
extensions.handle(ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
});
//# sourceMappingURL=AssetExtension.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/BackgroundLoader.mjs
class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
}


//# sourceMappingURL=BackgroundLoader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkExtension.mjs


function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}


//# sourceMappingURL=checkExtension.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/index.mjs






//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/convertToList.mjs
const convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};


//# sourceMappingURL=convertToList.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/Cache.mjs




class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys = convertToList(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys.forEach((key2) => {
        cacheableAssets[key2] = value;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value instanceof Texture) {
      const texture = value;
      keys.forEach((key2) => {
        if (texture.baseTexture !== Texture.EMPTY.baseTexture) {
          BaseTexture.addToCache(texture.baseTexture, key2);
        }
        Texture.addToCache(texture, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();


//# sourceMappingURL=Cache.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs
const isSingleItem = (item) => !Array.isArray(item);


//# sourceMappingURL=isSingleItem.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/Loader.mjs





class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
        delete this.promiseCache[url];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}


//# sourceMappingURL=Loader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});


//# sourceMappingURL=LoaderParser.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}


//# sourceMappingURL=checkDataUrl.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs





const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url) {
    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
  },
  async load(url) {
    const response = await settings.ADAPTER.fetch(url);
    const json = await response.json();
    return json;
  }
};
extensions.add(loadJson);


//# sourceMappingURL=loadJson.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs





const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  test(url) {
    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
  },
  async load(url) {
    const response = await settings.ADAPTER.fetch(url);
    const txt = await response.text();
    return txt;
  }
};
extensions.add(loadTxt);


//# sourceMappingURL=loadTxt.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs





const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = path.extname(url);
  const name = path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const loadWebFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url) {
    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
  },
  async load(url, options) {
    const fonts = settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = options.data?.family ?? getFontFamilyName(url);
      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
      const data = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        const weight = weights[i];
        const font = new FontFace(name, `url(${encodeURI(url)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));
  }
};
extensions.add(loadWebFont);


//# sourceMappingURL=loadWebFont.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs
let UUID = 0;
let MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
const checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
const workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== void 0) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this.queue.push({ id, arguments: args, resolve, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();


//# sourceMappingURL=WorkerManager.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs


function createTexture(base, loader, url) {
  const texture = new Texture(base);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url];
  });
  return texture;
}


//# sourceMappingURL=createTexture.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs







const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url) {
  const response = await settings.ADAPTER.fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url) {
    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.loadImageBitmap(url);
      } else {
        src = await loadImageBitmap(url);
      }
    } else {
      src = await new Promise((resolve) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
        }
      });
    }
    const base = new BaseTexture(src, {
      resolution: getResolutionOfUrl(url),
      ...asset.data
    });
    base.resource.src = url;
    return createTexture(base, loader, url);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
extensions.add(loadTextures);


//# sourceMappingURL=loadTextures.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs







const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSVG = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url) {
    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
  },
  async testParse(data) {
    return SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new BaseTexture(src, {
      resolution: getResolutionOfUrl(asset),
      ...data?.data
    });
    base.resource.src = asset;
    const texture = createTexture(base, loader, asset);
    return texture;
  },
  async load(url, _options) {
    const response = await settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload: loadTextures.unload
};
extensions.add(loadSVG);


//# sourceMappingURL=loadSVG.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs



//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/index.mjs





//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}


//# sourceMappingURL=createStringVariations.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/Resolver.mjs





class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys = convertToList(keysIn);
    keys.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = createStringVariations(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i = 0; i < this._parsers.length; i++) {
          const parser = this._parsers[i];
          if (parser.test(asset)) {
            formattedAsset = parser.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i in result) {
        out[i] = result[i].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
}


//# sourceMappingURL=Resolver.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/Assets.mjs










class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats = [];
    if (options.texturePreference?.format) {
      const formatPref = options.texturePreference?.format;
      formats = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats = await detection.remove(formats);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats = await detection.add(formats);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url) => {
      if (typeof url !== "string") {
        this.resolver.add(url.src, url);
        return url.src;
      }
      if (!this.resolver.hasKey(url)) {
        this.resolver.add(url, url);
      }
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.get(keys);
    }
    const assets = {};
    for (let i = 0; i < keys.length; i++) {
      assets[i] = Cache.get(keys[i]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out[resolveKeys[i]] = asset;
      Cache.set(keys, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);


//# sourceMappingURL=Assets.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs


const cacheTextureArray = {
  extension: ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    keys.forEach((key) => {
      asset.forEach((item, i) => {
        out[key + (i === 0 ? "" : i + 1)] = item;
      });
    });
    return out;
  }
};
extensions.add(cacheTextureArray);


//# sourceMappingURL=cacheTextureArray.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/index.mjs



//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs


const detectAvif = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f) => f !== "avif")
};
extensions.add(detectAvif);


//# sourceMappingURL=detectAvif.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs


const detectWebp = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f) => f !== "webp")
};
extensions.add(detectWebp);


//# sourceMappingURL=detectWebp.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs


const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
};
extensions.add(detectDefaults);


//# sourceMappingURL=detectDefaults.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/index.mjs



//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs




const resolveTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: value.split(".").pop(),
    src: value
  })
};
extensions.add(resolveTextureUrl);


//# sourceMappingURL=resolveTextureUrl.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs
const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};


//# sourceMappingURL=copySearchParams.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/index.mjs


























//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/const.mjs
var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,
  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,
  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,
  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,
  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,
  [37488 /* COMPRESSED_R11_EAC */]: 0.5,
  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,
  [37490 /* COMPRESSED_RG11_EAC */]: 1,
  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,
  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,
  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,
  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,
  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,
  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: 0.5,
  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: 0.5,
  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: 0.25,
  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: 0.25,
  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGB_ATC_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */]: 1,
  [34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */]: 1,
  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1
};


//# sourceMappingURL=const.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs

//# sourceMappingURL=compressedTextureExtensions.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs


let storedGl;
let detectCompressedTextures_extensions;
function getCompressedTextureExtensions() {
  detectCompressedTextures_extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats) => {
    if (!detectCompressedTextures_extensions)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in detectCompressedTextures_extensions) {
      const extension = detectCompressedTextures_extensions[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats];
  },
  remove: async (formats) => {
    if (!detectCompressedTextures_extensions)
      getCompressedTextureExtensions();
    return formats.filter((f) => !(f in detectCompressedTextures_extensions));
  }
};
extensions.add(detectCompressedTextures);


//# sourceMappingURL=detectCompressedTextures.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs


class BlobResource extends BufferResource {
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    super(data, options);
    this.origin = origin;
    this.buffer = data ? new ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}


//# sourceMappingURL=BlobResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs



class CompressedTextureResource extends BlobResource {
  constructor(source, options) {
    super(source, options);
    this.format = options.format;
    this.levels = options.levels || 1;
    this._width = options.width;
    this._height = options.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options.levelBuffers || this.buffer) {
      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer, _texture, _glTexture) {
    const gl = renderer.gl;
    const extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i = 0, j = this.levels; i < j; i++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format) {
    if (format >= 33776 && format <= 33779) {
      return "s3tc";
    } else if (format >= 37488 && format <= 37497) {
      return "etc";
    } else if (format >= 35840 && format <= 35843) {
      return "pvrtc";
    } else if (format >= 36196) {
      return "etc1";
    } else if (format >= 35986 && format <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    for (let i = 0; i < levels; i++) {
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    }
    return buffers;
  }
}


//# sourceMappingURL=CompressedTextureResource.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs




const DDS_MAGIC_SIZE = 4;
const DDS_HEADER_SIZE = 124;
const DDS_HEADER_PF_SIZE = 32;
const DDS_HEADER_DX10_SIZE = 20;
const DDS_MAGIC = 542327876;
const DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
const DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
  return DXGI_FORMAT2;
})(DXGI_FORMAT || {});
var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
  return D3D10_RESOURCE_DIMENSION2;
})(D3D10_RESOURCE_DIMENSION || {});
const PF_FLAGS = 1;
const DDPF_ALPHA = 2;
const DDPF_FOURCC = 4;
const DDPF_RGB = 64;
const DDPF_YUV = 512;
const DDPF_LUMINANCE = 131072;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT5 = 894720068;
const FOURCC_DX10 = 808540228;
const DDS_RESOURCE_MISC_TEXTURECUBE = 4;
const FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
const DXGI_TO_FORMAT = {
  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [71 /* DXGI_FORMAT_BC1_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [74 /* DXGI_FORMAT_BC2_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [77 /* DXGI_FORMAT_BC3_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6 /* DDS_DIMENSION_TEXTURE3D */) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array();
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i = 0; i < mipmapCount; i++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i = 0; i < arraySize; i++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}


//# sourceMappingURL=parseDDS.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs





const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const ENDIANNESS = 67305985;
const KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [TYPES.UNSIGNED_BYTE]: 1,
  [TYPES.UNSIGNED_SHORT]: 2,
  [TYPES.INT]: 4,
  [TYPES.UNSIGNED_INT]: 4,
  [TYPES.FLOAT]: 4,
  [TYPES.HALF_FLOAT]: 8
};
const FORMATS_TO_COMPONENTS = {
  [FORMATS.RGBA]: 4,
  [FORMATS.RGB]: 3,
  [FORMATS.RG]: 2,
  [FORMATS.RED]: 1,
  [FORMATS.LUMINANCE]: 1,
  [FORMATS.LUMINANCE_ALPHA]: 2,
  [FORMATS.ALPHA]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!parseKTX_validate(url, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function parseKTX_validate(url, dataView) {
  for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
      console.error(`${url} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format) {
  switch (format) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}


//# sourceMappingURL=parseKTX.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs





const loadDDS = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url) {
    return checkExtension(url, ".dds");
  },
  async load(url, asset, loader) {
    const response = await settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const resources = parseDDS(arrayBuffer);
    const textures = resources.map((resource) => {
      const base = new BaseTexture(resource, {
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: getResolutionOfUrl(url),
        ...asset.data
      });
      return createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
extensions.add(loadDDS);


//# sourceMappingURL=loadDDS.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs





const loadKTX = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url) {
    return checkExtension(url, ".ktx");
  },
  async load(url, asset, loader) {
    const response = await settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = parseKTX(url, arrayBuffer);
    const resources = compressed ?? uncompressed;
    const options = {
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: getResolutionOfUrl(url),
      ...asset.data
    };
    const textures = resources.map((resource) => {
      if (resources === uncompressed) {
        Object.assign(options, {
          type: resource.type,
          format: resource.format
        });
      }
      const base = new BaseTexture(resource, options);
      base.ktxKeyValueData = kvData;
      return createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
extensions.add(loadKTX);


//# sourceMappingURL=loadKTX.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs


const resolveCompressedTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext) => value.endsWith(ext))) {
        return {
          resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: extensions2.find((ext) => value.endsWith(ext)),
          src: value
        };
      }
    }
    return {
      resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
extensions.add(resolveCompressedTextureUrl);


//# sourceMappingURL=resolveCompressedTextureUrl.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs





//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/index.mjs












//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/Extract.mjs


const TEMP_RECT = new Rectangle();
const BYTES_PER_PIXEL = 4;
const _Extract = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  async image(target, format, quality) {
    const image = new Image();
    image.src = await this.base64(target, format, quality);
    return image;
  }
  async base64(target, format, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format, quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target, {
          resolution: renderer.resolution,
          multisample: renderer.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width / resolution;
        frame.height = renderer.height / resolution;
      }
      flipY = true;
      renderer.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture?.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w = width << 2;
    const h = height >> 1;
    const temp = new Uint8Array(w);
    for (let y = 0; y < h; y++) {
      const t = y * w;
      const b = (height - y - 1) * w;
      temp.set(pixels.subarray(t, t + w));
      pixels.copyWithin(t, b, b + w);
      pixels.set(temp, b);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n = pixels.length;
    for (let i = 0; i < n; i += 4) {
      const alpha = pixels[i + 3];
      if (alpha !== 0) {
        const a = 255.001 / alpha;
        pixels[i] = pixels[i] * a + 0.5;
        pixels[i + 1] = pixels[i + 1] * a + 0.5;
        pixels[i + 2] = pixels[i + 2] * a + 0.5;
      }
    }
  }
};
let Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: ExtensionType.RendererSystem
};
extensions.add(Extract);


//# sourceMappingURL=Extract.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs


const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x;
    let y;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x = ellipse.x;
      y = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m;
    if (m === 0) {
      return;
    }
    if (n === 0) {
      points.length = 8;
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return;
    }
    let j1 = 0;
    let j2 = n * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        const y2 = y - y0;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n);
      const x0 = dx + Math.cos(a) * rx;
      const y0 = dy + Math.sin(a) * ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      points[j3++] = x2;
      points[j3++] = y2;
      points[--j4] = y2;
      points[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x2;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x;
    let y;
    if (graphicsData.type !== SHAPES.RREC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2;
      y = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
    vertPos++;
    verts.push(points[0], points[1]);
    for (let i = 2; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices.push(vertPos++, center, vertPos);
    }
    indices.push(center + 1, center, vertPos);
  }
};


//# sourceMappingURL=buildCircle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs


function fixOrientation(points, hole = false) {
  const m = points.length;
  if (m < 6) {
    return;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n = m / 2;
    for (let i = n + n % 2; i < m; i += 2) {
      const i1 = m - i - 2;
      const i2 = m - i - 1;
      const i3 = i;
      const i4 = i + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i2], points[i4]] = [points[i4], points[i2]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      const triangles = earcut(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i = 0; i < triangles.length; i += 3) {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i + 1] + vertPos);
        indices.push(triangles[i + 2] + vertPos);
      }
      for (let i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};


//# sourceMappingURL=buildPoly.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs
const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};


//# sourceMappingURL=buildRectangle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs


const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};


//# sourceMappingURL=buildRoundedRectangle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/const.mjs
var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length, defaultSegments = 20) {
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    let result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
const GRAPHICS_CURVES = (/* unused pure expression or super */ null && (curves));


//# sourceMappingURL=const.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs



class ArcUtils {
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle;
    const n = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    const theta = sweep / (n * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i = 0; i <= segMinus; ++i) {
      const real = i + remainder * i;
      const angle = theta + startAngle + theta2 * real;
      const c = Math.cos(angle);
      const s = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
    }
  }
}


//# sourceMappingURL=ArcUtils.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs


class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n = 10;
    let result = 0;
    let t = 0;
    let t2 = 0;
    let t3 = 0;
    let nt = 0;
    let nt2 = 0;
    let nt3 = 0;
    let x = 0;
    let y = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i = 1; i <= n; ++i) {
      t = i / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x;
      dy = prevY - y;
      prevX = x;
      prevY = y;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    points.length -= 2;
    const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t2 = 0;
    let t3 = 0;
    points.push(fromX, fromY);
    for (let i = 1, j = 0; i <= n; ++i) {
      j = i / n;
      dt = 1 - j;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j * j;
      t3 = t2 * j;
      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  }
}


//# sourceMappingURL=BezierUtils.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildLine.mjs



function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join = LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join) {
        case LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join) {
        case LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices = graphicsGeometry.indices;
  const eps2 = curves.epsilon * curves.epsilon;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices = graphicsGeometry.indices;
  const length = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}


//# sourceMappingURL=buildLine.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs


class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a = 4 * (ax * ax + ay * ay);
    const b = 4 * (ax * bx + ay * by);
    const c = bx * bx + by * by;
    const s = 2 * Math.sqrt(a + b + c);
    const a2 = Math.sqrt(a);
    const a32 = 2 * a * a2;
    const c2 = 2 * Math.sqrt(c);
    const ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const n = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i = 1; i <= n; ++i) {
      const j = i / n;
      xa = fromX + (cpX - fromX) * j;
      ya = fromY + (cpY - fromY) * j;
      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
  }
}


//# sourceMappingURL=QuadraticUtils.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/index.mjs















const FILL_COMMANDS = {
  [SHAPES.POLY]: buildPoly,
  [SHAPES.CIRC]: buildCircle,
  [SHAPES.ELIP]: buildCircle,
  [SHAPES.RECT]: buildRectangle,
  [SHAPES.RREC]: buildRoundedRectangle
};
const BATCH_POOL = [];
const DRAW_CALL_POOL = [];


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsData.mjs
class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}


//# sourceMappingURL=GraphicsData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs
class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}


//# sourceMappingURL=BatchPart.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs








const tmpPoint = new Point();
const _GraphicsGeometry = class extends BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 1e-4;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new Bounds();
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (let i = 0; i < this.batches.length; i++) {
      const batchPart = this.batches[i];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i = 0; i < graphicsData.length; ++i) {
      const data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i2 = 0; i2 < data.holes.length; i2++) {
              const hole = data.holes[i2];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      const data = graphicsData[i];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j = 0; j < 2; j++) {
        const style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index2 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = lib_WRAP_MODES.REPEAT;
        if (j === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size = this.points.length / 2 - attribIndex;
        if (size === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index2, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index2, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    const index = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i = 0, l = this.graphicsData.length; i < l; i++) {
      const data = this.graphicsData[i];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i = 0, l = batches.length; i < l; i++) {
      const batch = batches[i];
      for (let j = 0; j < batch.size; j++) {
        const index = batch.start + j;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++BaseTexture._globalBatch;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = DRAW_MODES.TRIANGLES;
    let index = 0;
    this.drawCalls.push(currentGroup);
    for (let i = 0; i < this.batches.length; i++) {
      const data = this.batches[i];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = lib_WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p = 0;
    for (let i = 0; i < verts.length / 2; i++) {
      f32[p++] = verts[i * 2];
      f32[p++] = verts[i * 2 + 1];
      f32[p++] = uvs[i * 2];
      f32[p++] = uvs[i * 2 + 1];
      u32[p++] = colors[i];
      f32[p++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      buildPoly.triangulate(data, this);
    } else {
      const command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    buildLine(data, this);
    for (let i = 0; i < data.holes.length; i++) {
      buildLine(data.holes[i], this);
    }
  }
  processHoles(holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      const command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points, matrix) {
    for (let i = 0; i < points.length / 2; i++) {
      const x = points[i * 2];
      const y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  }
  addColors(colors, color, alpha, size, offset = 0) {
    const bgr = Color_Color.shared.setValue(color).toLittleEndianNumber();
    const result = Color_Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (let i = 0; i < size; i++) {
      colors[offset + i] = result;
    }
  }
  addTextureIds(textureIds, id, size, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (let i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  }
  addUvs(verts, uvs, texture, start, size, matrix = null) {
    let index = 0;
    const uvsStart = uvs.length;
    const frame = texture.frame;
    while (index < size) {
      let x = verts[(start + index) * 2];
      let y = verts[(start + index) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty;
        x = nx;
      }
      index++;
      uvs.push(x / frame.width, y / frame.height);
    }
    const baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  }
  adjustUvs(uvs, texture, start, size) {
    const baseTexture = texture.baseTexture;
    const eps = 1e-6;
    const finish = start + size * 2;
    const frame = texture.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  }
};
let GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;


//# sourceMappingURL=GraphicsGeometry.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs


class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}


//# sourceMappingURL=FillStyle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs



class LineStyle extends FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = LINE_CAP.BUTT;
    this.join = LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}


//# sourceMappingURL=LineStyle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/Graphics.mjs











const DEFAULT_SHADERS = {};
const _Graphics = class extends Container_Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new FillStyle();
    this._lineStyle = new LineStyle();
    this._matrix = null;
    this._holeMode = false;
    this.state = State.for2d();
    this._geometry = geometry || new GraphicsGeometry();
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new Color_Color(16777215);
    this.blendMode = lib_BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  }
  lineTo(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  _initCurve(x = 0, y = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps) {
      } else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  }
  normalizeColor(options) {
    const temp = Color_Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    const defaultOptions = {
      texture: Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x, y, width, height) {
    return this.drawShape(new Rectangle(x, y, width, height));
  }
  drawRoundedRect(x, y, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
  }
  drawCircle(x, y, radius) {
    return this.drawShape(new Circle(x, y, radius));
  }
  drawEllipse(x, y, width, height) {
    return this.drawShape(new Ellipse(x, y, width, height));
  }
  drawPolygon(...path) {
    let points;
    let closeStroke = true;
    const poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    const shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i = 0; i < len; i++) {
      const gI = geometry.batches[i];
      const color = gI.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      const batch = {
        vertexData,
        blendMode,
        indices,
        uvs,
        _batchRGB: Color_Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i = 0, l = this.batches.length; i < l; i++) {
      const batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    Color_Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (let i = 0, l = drawCalls.length; i < l; i++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
    }
  }
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type, size, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j = 0; j < groupTextureCount; j++) {
      renderer.texture.bind(texArray.elements[j], j);
    }
    renderer.geometry.draw(type, size, start);
  }
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i = 0; i < this.batches.length; i++) {
        const batch = this.batches[i];
        batch._tintRGB = Color_Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i = 0; i < data.length; i += 2) {
      const x = data[i];
      const y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
let Graphics_Graphics = _Graphics;
Graphics_Graphics.curves = curves;
Graphics_Graphics._TEMP_POINT = new Point();


//# sourceMappingURL=Graphics.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/index.mjs

















const graphicsUtils = {
  buildPoly: buildPoly,
  buildCircle: buildCircle,
  buildRectangle: buildRectangle,
  buildRoundedRectangle: buildRoundedRectangle,
  buildLine: buildLine,
  ArcUtils: ArcUtils,
  BezierUtils: BezierUtils,
  QuadraticUtils: QuadraticUtils,
  BatchPart: BatchPart,
  FILL_COMMANDS: FILL_COMMANDS,
  BATCH_POOL: BATCH_POOL,
  DRAW_CALL_POOL: DRAW_CALL_POOL
};


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs
class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}


//# sourceMappingURL=MeshBatchUvs.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/Mesh.mjs




const Mesh_tempPoint = new Point();
const tempPolygon = new Polygon();
const _Mesh = class extends Container_Container {
  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (this._geometry === value) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  }
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2];
      const y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx;
      vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, Mesh_tempPoint);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points = tempPolygon.points;
    const indices = this.geometry.getIndex().data;
    const len = indices.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i = 0; i + 2 < len; i += step) {
      const ind0 = indices[i] * 2;
      const ind1 = indices[i + 1] * 2;
      const ind2 = indices[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(Mesh_tempPoint.x, Mesh_tempPoint.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
let Mesh_Mesh = _Mesh;
Mesh_Mesh.BATCHABLE_SIZE = 100;


//# sourceMappingURL=Mesh.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshGeometry.mjs


class MeshGeometry_MeshGeometry extends Geometry {
  constructor(vertices, uvs, index) {
    super();
    const verticesBuffer = new Buffer_Buffer(vertices);
    const uvsBuffer = new Buffer_Buffer(uvs, true);
    const indexBuffer = new Buffer_Buffer(index, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}


//# sourceMappingURL=MeshGeometry.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh.mjs
var mesh_fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";


//# sourceMappingURL=mesh.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh2.mjs
var mesh2_vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";


//# sourceMappingURL=mesh2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshMaterial.mjs




class MeshMaterial_MeshMaterial extends Shader {
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    super(options.program || Program.from(mesh2_vertex, mesh_fragment), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new TextureMatrix(uSampler);
    this.batchable = options.program === void 0;
    this.pluginName = options.pluginName;
    this._tintColor = new Color_Color(options.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    if (this.uniforms.uSampler !== value) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value;
      this.uvMatrix.texture = value;
    }
  }
  set alpha(value) {
    if (value === this._alpha)
      return;
    this._alpha = value;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value) {
    if (value === this.tint)
      return;
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      Color_Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}


//# sourceMappingURL=MeshMaterial.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/index.mjs




//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs


class PlaneGeometry extends MeshGeometry_MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i = 0; i < total; i++) {
      const x = i % this.segWidth;
      const y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / segmentsX, y / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % segmentsX;
      const ypos = i / segmentsX | 0;
      const value = ypos * this.segWidth + xpos;
      const value2 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}


//# sourceMappingURL=PlaneGeometry.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs


class RopeGeometry_RopeGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x;
        const dy = prev.y - points[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i];
      const index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      if (ratio > 1) {
        ratio = 1;
      }
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}


//# sourceMappingURL=RopeGeometry.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs




class SimplePlane extends Mesh_Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new MeshMaterial_MeshMaterial(Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value) {
    if (this.shader.texture === value) {
      return;
    }
    this.shader.texture = value;
    this._textureID = -1;
    if (value.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}


//# sourceMappingURL=SimplePlane.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs



const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    super(Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w ? 1 : this._width / w;
    const h = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h ? 1 : this._height / h;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}


//# sourceMappingURL=NineSlicePlane.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs



class SimpleMesh extends Mesh_Mesh {
  constructor(texture = Texture.EMPTY, vertices, uvs, indices, drawMode) {
    const geometry = new MeshGeometry_MeshGeometry(vertices, uvs, indices);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new MeshMaterial_MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}


//# sourceMappingURL=SimpleMesh.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs




class SimpleRope extends (/* unused pure expression or super */ null && (Mesh)) {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer);
  }
}


//# sourceMappingURL=SimpleRope.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/index.mjs






//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs



class ParticleContainer extends (/* unused pure expression or super */ null && (Container)) {
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
    super();
    const maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    this._properties = [false, true, false, false, false];
    this._maxSize = maxSize;
    this._batchSize = batchSize;
    this._buffers = null;
    this._bufferUpdateIDs = [];
    this._updateID = 0;
    this.interactiveChildren = false;
    this.blendMode = BLEND_MODES.NORMAL;
    this.autoResize = autoResize;
    this.roundPixels = true;
    this.baseTexture = null;
    this.setProperties(properties);
    this._tintColor = new Color(0);
    this.tintRgb = new Float32Array(3);
    this.tint = 16777215;
  }
  setProperties(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintColor.toRgbArray(this.tintRgb);
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", () => this.onChildrenChange(0));
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  }
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  }
  destroy(options) {
    super.destroy(options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  }
}


//# sourceMappingURL=ParticleContainer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs


class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i = 0; i < properties.length; ++i) {
      let property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new Buffer_Buffer(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer_Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer_Buffer(this.staticData, true, false);
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i = 0; i < this.dynamicProperties.length; i++) {
      const property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i = 0; i < this.staticProperties.length; i++) {
      const property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}


//# sourceMappingURL=ParticleBuffer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles.mjs
var particles_fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";


//# sourceMappingURL=particles.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles2.mjs
var particles2_vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";


//# sourceMappingURL=particles2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs





class ParticleRenderer extends ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new Matrix();
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = Shader.from(particles2_vertex, particles_fragment, {});
    this.state = State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
    renderer.state.set(this.state);
    const gl = renderer.gl;
    const m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m.toArray(true);
    this.shader.uniforms.uColor = Color_Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      let amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer = buffers[j];
      buffer.uploadDynamic(children, i, amount);
      const bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i = 0; i < size; i += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const texture = sprite._texture;
      const sx = sprite.scale.x;
      const sy = sprite.scale.y;
      const trim = texture.trim;
      const orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const result = Color_Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array[offset] = result;
      array[offset + stride] = result;
      array[offset + stride * 2] = result;
      array[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: ExtensionType.RendererPlugin
};
extensions.add(ParticleRenderer);


//# sourceMappingURL=ParticleRenderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/const.mjs
var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});


//# sourceMappingURL=const.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextMetrics.mjs


const contextSettings = {
  willReadFrequently: true
};
const _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context = canvas.getContext("2d", contextSettings);
    context.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context.letterSpacing = `${letterSpacing}px`;
        context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context.letterSpacing = "0px";
        context.textLetterSpacing = "0px";
      }
    }
    let width = context.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j = 0; j < characters.length; j++) {
            let char = characters[j];
            let lastChar = char;
            let k = 1;
            while (characters[j + k]) {
              const nextChar = characters[j + k];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k++;
            }
            j += k - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache, context) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i = text.length - 1; i >= 0; i--) {
      const char = text[i];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const nextChar = text[i + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context = _TextMetrics._context;
    context.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context.measureText(metricsString).width);
    let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    const imagedata = context.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i = 0;
    let idx = 0;
    let stop = false;
    for (i = 0; i < baseline; ++i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c = new OffscreenCanvas(0, 0);
        const context = c.getContext("2d", contextSettings);
        if (context?.measureText) {
          _TextMetrics.__canvas = c;
          return c;
        }
        canvas = settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
let TextMetrics_TextMetrics = _TextMetrics;
TextMetrics_TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics_TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics_TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics_TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics_TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter === "function") {
    const segmenter = new Intl.Segmenter();
    return (s) => [...segmenter.segment(s)].map((x) => x.segment);
  }
  return (s) => [...s];
})();
TextMetrics_TextMetrics.experimentalLetterSpacing = false;
TextMetrics_TextMetrics._fonts = {};
TextMetrics_TextMetrics._newlines = [
  10,
  13
];
TextMetrics_TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];


//# sourceMappingURL=TextMetrics.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextStyle.mjs



const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
const _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    if (this._trim !== trim) {
      this._trim = trim;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i = fontFamilies.length - 1; i >= 0; i--) {
      let fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
let TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
function getColor(color) {
  const temp = Color_Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c) => temp.setValue(c).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}


//# sourceMappingURL=TextStyle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/Text.mjs






const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
const _Text = class extends Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture = Texture.from(canvas);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    super(texture);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return TextMetrics_TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    TextMetrics_TextMetrics.experimentalLetterSpacing = value;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context = this.context;
    const measured = TextMetrics_TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context.scale(this._resolution, this._resolution);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context.font = this._font;
    context.lineWidth = style.strokeThickness;
    context.textBaseline = style.textBaseline;
    context.lineJoin = style.lineJoin;
    context.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i = 0; i < passesCount; ++i) {
      const isShadowPass = style.dropShadow && i === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context.fillStyle = "black";
        context.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context.shadowColor = Color_Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context.shadowBlur = dropShadowBlur;
        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context.fillStyle = this._generateFillStyle(style, lines, measured);
        context.strokeStyle = style.stroke;
        context.shadowColor = "black";
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i2];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x, y, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics_TextMetrics.experimentalLetterSpacingSupported) {
      if (TextMetrics_TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x, y);
      } else {
        this.context.fillText(text, x, y);
      }
      return;
    }
    let currentPosition = x;
    const stringArray = TextMetrics_TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i = 0; i < stringArray.length; ++i) {
      const currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y);
      } else {
        this.context.fillText(currentChar, currentPosition, y);
      }
      let textStr = "";
      for (let j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i = 0; i < lines.length; i++) {
        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i;
        let thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    super.destroy(options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s = sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s = sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
};
let Text = _Text;
Text.defaultAutoResolution = true;


//# sourceMappingURL=Text.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/index.mjs




//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/CountLimiter.mjs
class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}


//# sourceMappingURL=CountLimiter.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/BasePrepare.mjs





function findMultipleBaseTextures(item, queue) {
  let result = false;
  if (item?._textures?.length) {
    for (let i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof Texture) {
        const baseTexture = item._textures[i].baseTexture;
        if (!queue.includes(baseTexture)) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    const texture = item.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    const font = item.toFontString();
    TextMetrics_TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    if (!queue.includes(item.style)) {
      queue.push(item.style);
    }
    if (!queue.includes(item)) {
      queue.push(item);
    }
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof TextStyle) {
    if (!queue.includes(item)) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
const _BasePrepare = class {
  constructor(renderer) {
    this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve);
        if (!this.ticking) {
          this.ticking = true;
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i = 0, len = completes.length; i < len; i++) {
        completes[i]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i = 0, len = this.addHooks.length; i < len; i++) {
      if (this.addHooks[i](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container_Container) {
      for (let i = item.children.length - 1; i >= 0; i--) {
        this.add(item.children[i]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
let BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;


//# sourceMappingURL=BasePrepare.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/settings.mjs




Object.defineProperties(settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.uploadsPerFrame;
    },
    set(value) {
      deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      BasePrepare.uploadsPerFrame = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/Prepare.mjs




function uploadBaseTextures(renderer, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof Graphics_Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i = 0; i < batches.length; i++) {
    const { texture } = batches[i].style;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof Graphics_Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
class Prepare extends BasePrepare {
  constructor(renderer) {
    super(renderer);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: ExtensionType.RendererSystem
};
extensions.add(Prepare);


//# sourceMappingURL=Prepare.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/index.mjs





//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs



class AnimatedSprite extends Sprite {
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign;
        this._currentTime += sign;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  }
  updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  destroy(options) {
    this.stop();
    super.destroy(options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  static fromFrames(frames) {
    const textures = [];
    for (let i = 0; i < frames.length; ++i) {
      textures.push(Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  }
  static fromImages(images) {
    const textures = [];
    for (let i = 0; i < images.length; ++i) {
      textures.push(Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  }
  get totalFrames() {
    return this._textures.length;
  }
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i = 0; i < value.length; i++) {
        this._textures.push(value[i].texture);
        this._durations.push(value[i].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this.updateTexture();
  }
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  }
  get playing() {
    return this._playing;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}


//# sourceMappingURL=AnimatedSprite.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/index.mjs

//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs



const TilingSprite_tempPoint = new Point();
class TilingSprite extends Sprite {
  constructor(texture, width = 100, height = 100) {
    super(texture);
    this.tileTransform = new Transform();
    this._width = width;
    this._height = height;
    this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);
    this.pluginName = "tilingSprite";
    this.uvRespectAnchor = false;
  }
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value) {
    this.uvMatrix.clampMargin = value;
    this.uvMatrix.update(true);
  }
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value) {
    this.tileTransform.scale.copyFrom(value);
  }
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value) {
    this.tileTransform.position.copyFrom(value);
  }
  _onTextureUpdate() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  }
  _render(renderer) {
    const texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const minX = this._width * -this._anchor._x;
    const minY = this._height * -this._anchor._y;
    const maxX = this._width * (1 - this._anchor._x);
    const maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, TilingSprite_tempPoint);
    const width = this._width;
    const height = this._height;
    const x1 = -width * this.anchor._x;
    if (TilingSprite_tempPoint.x >= x1 && TilingSprite_tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (TilingSprite_tempPoint.y >= y1 && TilingSprite_tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this.tileTransform = null;
    this.uvMatrix = null;
  }
  static from(source, options) {
    const texture = source instanceof Texture ? source : Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
}


//# sourceMappingURL=TilingSprite.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";


//# sourceMappingURL=sprite-tiling.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";


//# sourceMappingURL=sprite-tiling2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";


//# sourceMappingURL=sprite-tiling-fallback.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";


//# sourceMappingURL=sprite-tiling-fallback2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";


//# sourceMappingURL=sprite-tiling-simple.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs







const TilingSpriteRenderer_tempMat = new Matrix();
class TilingSpriteRenderer extends ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    renderer.runners.contextChange.add(this);
    this.quad = new QuadUv();
    this.state = State.for2d();
  }
  contextChange() {
    const renderer = this.renderer;
    const uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  }
  render(ts) {
    const renderer = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === lib_WRAP_MODES.CLAMP) {
          baseTex.wrapMode = lib_WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== lib_WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple ? this.simpleShader : this.shader;
    const w = tex.width;
    const h = tex.height;
    const W = ts._width;
    const H = ts._height;
    TilingSpriteRenderer_tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
    TilingSpriteRenderer_tempMat.invert();
    if (isSimple) {
      TilingSpriteRenderer_tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = TilingSpriteRenderer_tempMat.toArray(true);
    shader.uniforms.uColor = Color_Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: ExtensionType.RendererPlugin
};
extensions.add(TilingSpriteRenderer);


//# sourceMappingURL=TilingSpriteRenderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs


const _Spritesheet = class {
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture instanceof Texture ? texture : null;
    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i = this._frameKeys[frameIndex];
      const data = this._frames[i];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
        Texture.addToCache(this.textures[i], i);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    for (const i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
let Spritesheet = _Spritesheet;
Spritesheet.BATCH_SIZE = 1e3;


//# sourceMappingURL=Spritesheet.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs




const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  resolver: {
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      let basePath = path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = copySearchParams(imagePath, options.src);
      const assets = await loader.load([imagePath]);
      const texture = assets[imagePath];
      const spritesheet = new Spritesheet(texture.baseTexture, asset, options.src);
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = copySearchParams(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
extensions.add(spritesheetAsset);


//# sourceMappingURL=spritesheetAsset.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs
class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}


//# sourceMappingURL=BitmapFontData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs


class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i in items) {
      const name = items[i].match(/^[a-z]+/gm)[0];
      const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i2 in attributeList) {
        const split = attributeList[i2].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = new BitmapFontData();
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}


//# sourceMappingURL=TextFormat.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs


class XMLFormat {
  static test(data) {
    const xml = data;
    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new BitmapFontData();
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (let i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (let i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (let i = 0; i < char.length; i++) {
      const letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    for (let i = 0; i < distanceField.length; i++) {
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}


//# sourceMappingURL=XMLFormat.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs



class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return XMLFormat.test(settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
  }
}


//# sourceMappingURL=XMLStringFormat.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/index.mjs







const formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs


function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i = 0; i < lines.length; i++) {
      const thisLineTop = metrics.lineHeight * i;
      for (let j = 0; j < fill.length; j++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i = 0; i < fill.length; i++) {
      let stop;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}


//# sourceMappingURL=generateFillStyle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs



function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context.translate(x, y);
  context.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context.font = style.toFontString();
  context.lineWidth = style.strokeThickness;
  context.textBaseline = style.textBaseline;
  context.lineJoin = style.lineJoin;
  context.miterLimit = style.miterLimit;
  context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);
  context.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context.shadowColor = Color_Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context.shadowBlur = dropShadowBlur;
    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context.shadowColor = "black";
    context.shadowBlur = 0;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "rgba(0, 0, 0, 0)";
}


//# sourceMappingURL=drawGlyph.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/index.mjs





//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}


//# sourceMappingURL=splitTextToCharacters.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs


function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}


//# sourceMappingURL=resolveCharacters.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}


//# sourceMappingURL=extractCharCode.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs









const _BitmapFont = class {
  constructor(data, textures, ownsTextures) {
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i = 0; i < data.page.length; i++) {
      const { id, file } = data.page[i];
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
      if (distanceField?.fieldType && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
      }
    }
    for (let i = 0; i < data.char.length; i++) {
      const { id, page: page2 } = data.char[i];
      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
      x /= res;
      y /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i = 0; i < data.kerning.length; i++) {
      let { first, second, amount } = data.kerning[i];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField?.distanceRange;
    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      const format = autoDetectFormat(data);
      if (!format) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    const font = new _BitmapFont(fontData, textures, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name) {
    const font = _BitmapFont.available[name];
    if (!font) {
      throw new Error(`No font found named '${name}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name];
  }
  static from(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options);
    const charsList = resolveCharacters(chars);
    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context;
    let baseTexture;
    let maxCharHeight = 0;
    const baseTextures = [];
    const textures = [];
    for (let i = 0; i < charsList.length; i++) {
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context = canvas.getContext("2d");
        baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });
        baseTextures.push(baseTexture);
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      const character = charsList[i];
      const metrics = TextMetrics_TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        canvas = null;
        context = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i = 0, len = charsList.length; i < len; i++) {
      const first = charsList[i];
      for (let j = 0; j < len; j++) {
        const second = charsList[j];
        const c1 = context.measureText(first).width;
        const c2 = context.measureText(second).width;
        const total = context.measureText(first + second).width;
        const amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode(first),
            second: extractCharCode(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures, true);
    if (_BitmapFont.available[name] !== void 0) {
      _BitmapFont.uninstall(name);
    }
    _BitmapFont.available[name] = font;
    return font;
  }
};
let BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};


//# sourceMappingURL=BitmapFont.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";


//# sourceMappingURL=msdf.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";


//# sourceMappingURL=msdf2.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs










const pageMeshDataDefaultPageMeshData = [];
const pageMeshDataMSDFPageMeshData = [];
const charRenderDataPool = [];
const _BitmapText = class extends Container_Container {
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new Color_Color(tint);
    this._font = void 0;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    const data = BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale = fontSize / data.size;
    const pos = new Point();
    const chars = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = splitTextToCharacters(text);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i = 0; i < charsInput.length; i++) {
      const char = charsInput[i];
      const charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i = 0; i <= line; i++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i = 0; i < lenChars; i++) {
      const texture = chars[i].texture;
      const baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new MeshGeometry_MeshGeometry();
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial_MeshMaterial(Texture.EMPTY);
            meshBlendMode = lib_BLEND_MODES.NORMAL;
          } else {
            material = new MeshMaterial_MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = lib_BLEND_MODES.NORMAL_NPM;
          }
          const mesh = new Mesh_Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i = 0; i < activePagesMeshData.length; i++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i])) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (let i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      const total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh_Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
          vertices[i2] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i = 0; i < lenChars; i++) {
      const char = chars[i];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale;
      const yPos = char.position.y * scale;
      const texture = char.texture;
      const pageMesh = pagesMeshData[texture.baseTexture.uid];
      const textureFrame = texture.frame;
      const textureUvs = texture._uvs;
      const index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i2 = 0; i2 < pageMeshData.total; i2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a, b, c, d } = this.worldTransform;
      const dx = Math.sqrt(a * a + b * b);
      const dy = Math.sqrt(c * c + d * d);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size;
      const resolution = renderer._view.resolution;
      for (const mesh of this._activePagesMeshData) {
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint === value)
      return;
    this._tintColor.setValue(value);
    for (let i = 0; i < this._activePagesMeshData.length; i++) {
      this._activePagesMeshData[i].mesh.tint = value;
    }
  }
  get align() {
    return this._align;
  }
  set align(value) {
    if (this._align !== value) {
      this._align = value;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.available[value]) {
      throw new Error(`Missing BitmapFont "${value}"`);
    }
    if (this._fontName !== value) {
      this._fontName = value;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    if (this._fontSize !== value) {
      this._fontSize = value;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    if (typeof value === "number") {
      this._anchor.set(value);
    } else {
      this._anchor.copyFrom(value);
    }
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    if (this._maxWidth === value) {
      return;
    }
    this._maxWidth = value;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    if (this._letterSpacing !== value) {
      this._letterSpacing = value;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    if (value !== this._roundPixels) {
      this._roundPixels = value;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  destroy(options) {
    const { _textureCache } = this;
    const data = BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options);
  }
};
let BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};


//# sourceMappingURL=BitmapText.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs







const validExtensions = [".xml", ".fnt"];
const loadBitmapFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url) {
    return validExtensions.includes(path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.test(data) || XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i = 0; i < pages.length; ++i) {
      const pageFile = pages[i].file;
      let imagePath = path.join(path.dirname(src), pageFile);
      imagePath = copySearchParams(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url) => loadedTextures[url]);
    return BitmapFont.install(fontData, textures, true);
  },
  async load(url, _options) {
    const response = await settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
extensions.add(loadBitmapFont);


//# sourceMappingURL=loadBitmapFont.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/index.mjs









//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs



const _HTMLTextStyle = class extends TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url, options = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url]) {
      const font = availableFonts[url];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return settings.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader();
      reader.onload = () => resolve([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: path.basename(url, path.extname(url)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url,
        fontFace: null
      }, options);
      availableFonts[url] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value) {
    const toAdd = value.filter((v) => !this._overrides.includes(v));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value) {
    const toRemove = value.filter((v) => this._overrides.includes(v));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v) => !toRemove.includes(v));
      this.styleID++;
    }
  }
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    if (this._stylesheet !== value) {
      this._stylesheet = value;
      this.styleID++;
    }
  }
  normalizeColor(color) {
    if (Array.isArray(color)) {
      color = rgb2hex(color);
    }
    if (typeof color === "number") {
      return hex2string(color);
    }
    return color;
  }
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha;
    const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color.startsWith("#") && alpha < 1) {
      color += (alpha * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x}px ${y}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve) => setTimeout(resolve, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
let HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};


//# sourceMappingURL=HTMLTextStyle.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLText.mjs





const _HTMLText = class extends Sprite {
  constructor(text = "", style = {}) {
    super(Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image();
    const texture = Texture.from(image, {
      scaleMode: settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image();
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? settings.RESOLUTION;
    this.text = text;
    this.style = style;
  }
  measureText(overrides) {
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });
      this._styleElement.textContent = this._style?.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution;
    texture.trim.height = texture._frame.height = image.height / resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  _renderCanvas(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);
    super.destroy(options);
    const forceClear = null;
    if (this.ownsStyle) {
      this._style?.cleanFonts();
    }
    this._style = forceClear;
    this._svgRoot?.remove();
    this._svgRoot = forceClear;
    this._domElement?.remove();
    this._domElement = forceClear;
    this._foreignObject?.remove();
    this._foreignObject = forceClear;
    this._styleElement?.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s = sign(this.scale.x) || 1;
    this.scale.x = s * value / this._image.width / this.resolution;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s = sign(this.scale.y) || 1;
    this.scale.y = s * value / this._image.height / this.resolution;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text);
    text = this.sanitiseText(text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
let HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;


//# sourceMappingURL=HTMLText.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs






























//# sourceMappingURL=index.mjs.map

// EXTERNAL MODULE: ./node_modules/reflect-metadata/Reflect.js
var reflect_metadata_Reflect = __webpack_require__(8660);
;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/types/lifecycle.js
var Lifecycle;
(function (Lifecycle) {
    Lifecycle[Lifecycle["Transient"] = 0] = "Transient";
    Lifecycle[Lifecycle["Singleton"] = 1] = "Singleton";
    Lifecycle[Lifecycle["ResolutionScoped"] = 2] = "ResolutionScoped";
    Lifecycle[Lifecycle["ContainerScoped"] = 3] = "ContainerScoped";
})(Lifecycle || (Lifecycle = {}));
/* harmony default export */ const lifecycle = (Lifecycle);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/types/index.js


;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function tslib_es6_extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function tslib_es6_rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function tslib_es6_spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/class-provider.js
function isClassProvider(provider) {
    return !!provider.useClass;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/factory-provider.js
function isFactoryProvider(provider) {
    return !!provider.useFactory;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/lazy-helpers.js

var DelayedConstructor = (function () {
    function DelayedConstructor(wrap) {
        this.wrap = wrap;
        this.reflectMethods = [
            "get",
            "getPrototypeOf",
            "setPrototypeOf",
            "getOwnPropertyDescriptor",
            "defineProperty",
            "has",
            "set",
            "deleteProperty",
            "apply",
            "construct",
            "ownKeys"
        ];
    }
    DelayedConstructor.prototype.createProxy = function (createObject) {
        var _this = this;
        var target = {};
        var init = false;
        var value;
        var delayedObject = function () {
            if (!init) {
                value = createObject(_this.wrap());
                init = true;
            }
            return value;
        };
        return new Proxy(target, this.createHandler(delayedObject));
    };
    DelayedConstructor.prototype.createHandler = function (delayedObject) {
        var handler = {};
        var install = function (name) {
            handler[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                args[0] = delayedObject();
                var method = Reflect[name];
                return method.apply(void 0, tslib_es6_spread(args));
            };
        };
        this.reflectMethods.forEach(install);
        return handler;
    };
    return DelayedConstructor;
}());

function delay(wrappedConstructor) {
    if (typeof wrappedConstructor === "undefined") {
        throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");
    }
    return new DelayedConstructor(wrappedConstructor);
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/injection-token.js

function isNormalToken(token) {
    return typeof token === "string" || typeof token === "symbol";
}
function injection_token_isTokenDescriptor(descriptor) {
    return (typeof descriptor === "object" &&
        "token" in descriptor &&
        "multiple" in descriptor);
}
function injection_token_isTransformDescriptor(descriptor) {
    return (typeof descriptor === "object" &&
        "token" in descriptor &&
        "transform" in descriptor);
}
function isConstructorToken(token) {
    return typeof token === "function" || token instanceof DelayedConstructor;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/token-provider.js
function isTokenProvider(provider) {
    return !!provider.useToken;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/value-provider.js
function isValueProvider(provider) {
    return provider.useValue != undefined;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/index.js






;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/provider.js




function isProvider(provider) {
    return (isClassProvider(provider) ||
        isValueProvider(provider) ||
        isTokenProvider(provider) ||
        isFactoryProvider(provider));
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/registry-base.js
var RegistryBase = (function () {
    function RegistryBase() {
        this._registryMap = new Map();
    }
    RegistryBase.prototype.entries = function () {
        return this._registryMap.entries();
    };
    RegistryBase.prototype.getAll = function (key) {
        this.ensure(key);
        return this._registryMap.get(key);
    };
    RegistryBase.prototype.get = function (key) {
        this.ensure(key);
        var value = this._registryMap.get(key);
        return value[value.length - 1] || null;
    };
    RegistryBase.prototype.set = function (key, value) {
        this.ensure(key);
        this._registryMap.get(key).push(value);
    };
    RegistryBase.prototype.setAll = function (key, value) {
        this._registryMap.set(key, value);
    };
    RegistryBase.prototype.has = function (key) {
        this.ensure(key);
        return this._registryMap.get(key).length > 0;
    };
    RegistryBase.prototype.clear = function () {
        this._registryMap.clear();
    };
    RegistryBase.prototype.ensure = function (key) {
        if (!this._registryMap.has(key)) {
            this._registryMap.set(key, []);
        }
    };
    return RegistryBase;
}());
/* harmony default export */ const registry_base = (RegistryBase);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/registry.js


var Registry = (function (_super) {
    tslib_es6_extends(Registry, _super);
    function Registry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Registry;
}(registry_base));
/* harmony default export */ const registry = (Registry);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/resolution-context.js
var ResolutionContext = (function () {
    function ResolutionContext() {
        this.scopedResolutions = new Map();
    }
    return ResolutionContext;
}());
/* harmony default export */ const resolution_context = (ResolutionContext);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/error-helpers.js

function formatDependency(params, idx) {
    if (params === null) {
        return "at position #" + idx;
    }
    var argName = params.split(",")[idx].trim();
    return "\"" + argName + "\" at position #" + idx;
}
function composeErrorMessage(msg, e, indent) {
    if (indent === void 0) { indent = "    "; }
    return tslib_es6_spread([msg], e.message.split("\n").map(function (l) { return indent + l; })).join("\n");
}
function error_helpers_formatErrorCtor(ctor, paramIdx, error) {
    var _a = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a[1], params = _b === void 0 ? null : _b;
    var dep = formatDependency(params, paramIdx);
    return composeErrorMessage("Cannot inject the dependency " + dep + " of \"" + ctor.name + "\" constructor. Reason:", error);
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/types/disposable.js
function isDisposable(value) {
    if (typeof value.dispose !== "function")
        return false;
    var disposeFun = value.dispose;
    if (disposeFun.length > 0) {
        return false;
    }
    return true;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/interceptors.js


var PreResolutionInterceptors = (function (_super) {
    tslib_es6_extends(PreResolutionInterceptors, _super);
    function PreResolutionInterceptors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PreResolutionInterceptors;
}(registry_base));

var PostResolutionInterceptors = (function (_super) {
    tslib_es6_extends(PostResolutionInterceptors, _super);
    function PostResolutionInterceptors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PostResolutionInterceptors;
}(registry_base));

var Interceptors = (function () {
    function Interceptors() {
        this.preResolution = new PreResolutionInterceptors();
        this.postResolution = new PostResolutionInterceptors();
    }
    return Interceptors;
}());
/* harmony default export */ const interceptors = (Interceptors);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/dependency-container.js











var typeInfo = new Map();
var InternalDependencyContainer = (function () {
    function InternalDependencyContainer(parent) {
        this.parent = parent;
        this._registry = new registry();
        this.interceptors = new interceptors();
        this.disposed = false;
        this.disposables = new Set();
    }
    InternalDependencyContainer.prototype.register = function (token, providerOrConstructor, options) {
        if (options === void 0) { options = { lifecycle: lifecycle.Transient }; }
        this.ensureNotDisposed();
        var provider;
        if (!isProvider(providerOrConstructor)) {
            provider = { useClass: providerOrConstructor };
        }
        else {
            provider = providerOrConstructor;
        }
        if (isTokenProvider(provider)) {
            var path = [token];
            var tokenProvider = provider;
            while (tokenProvider != null) {
                var currentToken = tokenProvider.useToken;
                if (path.includes(currentToken)) {
                    throw new Error("Token registration cycle detected! " + tslib_es6_spread(path, [currentToken]).join(" -> "));
                }
                path.push(currentToken);
                var registration = this._registry.get(currentToken);
                if (registration && isTokenProvider(registration.provider)) {
                    tokenProvider = registration.provider;
                }
                else {
                    tokenProvider = null;
                }
            }
        }
        if (options.lifecycle === lifecycle.Singleton ||
            options.lifecycle == lifecycle.ContainerScoped ||
            options.lifecycle == lifecycle.ResolutionScoped) {
            if (isValueProvider(provider) || isFactoryProvider(provider)) {
                throw new Error("Cannot use lifecycle \"" + lifecycle[options.lifecycle] + "\" with ValueProviders or FactoryProviders");
            }
        }
        this._registry.set(token, { provider: provider, options: options });
        return this;
    };
    InternalDependencyContainer.prototype.registerType = function (from, to) {
        this.ensureNotDisposed();
        if (isNormalToken(to)) {
            return this.register(from, {
                useToken: to
            });
        }
        return this.register(from, {
            useClass: to
        });
    };
    InternalDependencyContainer.prototype.registerInstance = function (token, instance) {
        this.ensureNotDisposed();
        return this.register(token, {
            useValue: instance
        });
    };
    InternalDependencyContainer.prototype.registerSingleton = function (from, to) {
        this.ensureNotDisposed();
        if (isNormalToken(from)) {
            if (isNormalToken(to)) {
                return this.register(from, {
                    useToken: to
                }, { lifecycle: lifecycle.Singleton });
            }
            else if (to) {
                return this.register(from, {
                    useClass: to
                }, { lifecycle: lifecycle.Singleton });
            }
            throw new Error('Cannot register a type name as a singleton without a "to" token');
        }
        var useClass = from;
        if (to && !isNormalToken(to)) {
            useClass = to;
        }
        return this.register(from, {
            useClass: useClass
        }, { lifecycle: lifecycle.Singleton });
    };
    InternalDependencyContainer.prototype.resolve = function (token, context) {
        if (context === void 0) { context = new resolution_context(); }
        this.ensureNotDisposed();
        var registration = this.getRegistration(token);
        if (!registration && isNormalToken(token)) {
            throw new Error("Attempted to resolve unregistered dependency token: \"" + token.toString() + "\"");
        }
        this.executePreResolutionInterceptor(token, "Single");
        if (registration) {
            var result = this.resolveRegistration(registration, context);
            this.executePostResolutionInterceptor(token, result, "Single");
            return result;
        }
        if (isConstructorToken(token)) {
            var result = this.construct(token, context);
            this.executePostResolutionInterceptor(token, result, "Single");
            return result;
        }
        throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
    };
    InternalDependencyContainer.prototype.executePreResolutionInterceptor = function (token, resolutionType) {
        var e_1, _a;
        if (this.interceptors.preResolution.has(token)) {
            var remainingInterceptors = [];
            try {
                for (var _b = __values(this.interceptors.preResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var interceptor = _c.value;
                    if (interceptor.options.frequency != "Once") {
                        remainingInterceptors.push(interceptor);
                    }
                    interceptor.callback(token, resolutionType);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.interceptors.preResolution.setAll(token, remainingInterceptors);
        }
    };
    InternalDependencyContainer.prototype.executePostResolutionInterceptor = function (token, result, resolutionType) {
        var e_2, _a;
        if (this.interceptors.postResolution.has(token)) {
            var remainingInterceptors = [];
            try {
                for (var _b = __values(this.interceptors.postResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var interceptor = _c.value;
                    if (interceptor.options.frequency != "Once") {
                        remainingInterceptors.push(interceptor);
                    }
                    interceptor.callback(token, result, resolutionType);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.interceptors.postResolution.setAll(token, remainingInterceptors);
        }
    };
    InternalDependencyContainer.prototype.resolveRegistration = function (registration, context) {
        this.ensureNotDisposed();
        if (registration.options.lifecycle === lifecycle.ResolutionScoped &&
            context.scopedResolutions.has(registration)) {
            return context.scopedResolutions.get(registration);
        }
        var isSingleton = registration.options.lifecycle === lifecycle.Singleton;
        var isContainerScoped = registration.options.lifecycle === lifecycle.ContainerScoped;
        var returnInstance = isSingleton || isContainerScoped;
        var resolved;
        if (isValueProvider(registration.provider)) {
            resolved = registration.provider.useValue;
        }
        else if (isTokenProvider(registration.provider)) {
            resolved = returnInstance
                ? registration.instance ||
                    (registration.instance = this.resolve(registration.provider.useToken, context))
                : this.resolve(registration.provider.useToken, context);
        }
        else if (isClassProvider(registration.provider)) {
            resolved = returnInstance
                ? registration.instance ||
                    (registration.instance = this.construct(registration.provider.useClass, context))
                : this.construct(registration.provider.useClass, context);
        }
        else if (isFactoryProvider(registration.provider)) {
            resolved = registration.provider.useFactory(this);
        }
        else {
            resolved = this.construct(registration.provider, context);
        }
        if (registration.options.lifecycle === lifecycle.ResolutionScoped) {
            context.scopedResolutions.set(registration, resolved);
        }
        return resolved;
    };
    InternalDependencyContainer.prototype.resolveAll = function (token, context) {
        var _this = this;
        if (context === void 0) { context = new resolution_context(); }
        this.ensureNotDisposed();
        var registrations = this.getAllRegistrations(token);
        if (!registrations && isNormalToken(token)) {
            throw new Error("Attempted to resolve unregistered dependency token: \"" + token.toString() + "\"");
        }
        this.executePreResolutionInterceptor(token, "All");
        if (registrations) {
            var result_1 = registrations.map(function (item) {
                return _this.resolveRegistration(item, context);
            });
            this.executePostResolutionInterceptor(token, result_1, "All");
            return result_1;
        }
        var result = [this.construct(token, context)];
        this.executePostResolutionInterceptor(token, result, "All");
        return result;
    };
    InternalDependencyContainer.prototype.isRegistered = function (token, recursive) {
        if (recursive === void 0) { recursive = false; }
        this.ensureNotDisposed();
        return (this._registry.has(token) ||
            (recursive &&
                (this.parent || false) &&
                this.parent.isRegistered(token, true)));
    };
    InternalDependencyContainer.prototype.reset = function () {
        this.ensureNotDisposed();
        this._registry.clear();
        this.interceptors.preResolution.clear();
        this.interceptors.postResolution.clear();
    };
    InternalDependencyContainer.prototype.clearInstances = function () {
        var e_3, _a;
        this.ensureNotDisposed();
        try {
            for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
                this._registry.setAll(token, registrations
                    .filter(function (registration) { return !isValueProvider(registration.provider); })
                    .map(function (registration) {
                    registration.instance = undefined;
                    return registration;
                }));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    InternalDependencyContainer.prototype.createChildContainer = function () {
        var e_4, _a;
        this.ensureNotDisposed();
        var childContainer = new InternalDependencyContainer(this);
        try {
            for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
                if (registrations.some(function (_a) {
                    var options = _a.options;
                    return options.lifecycle === lifecycle.ContainerScoped;
                })) {
                    childContainer._registry.setAll(token, registrations.map(function (registration) {
                        if (registration.options.lifecycle === lifecycle.ContainerScoped) {
                            return {
                                provider: registration.provider,
                                options: registration.options
                            };
                        }
                        return registration;
                    }));
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return childContainer;
    };
    InternalDependencyContainer.prototype.beforeResolution = function (token, callback, options) {
        if (options === void 0) { options = { frequency: "Always" }; }
        this.interceptors.preResolution.set(token, {
            callback: callback,
            options: options
        });
    };
    InternalDependencyContainer.prototype.afterResolution = function (token, callback, options) {
        if (options === void 0) { options = { frequency: "Always" }; }
        this.interceptors.postResolution.set(token, {
            callback: callback,
            options: options
        });
    };
    InternalDependencyContainer.prototype.dispose = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.disposed = true;
                        promises = [];
                        this.disposables.forEach(function (disposable) {
                            var maybePromise = disposable.dispose();
                            if (maybePromise) {
                                promises.push(maybePromise);
                            }
                        });
                        return [4, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    InternalDependencyContainer.prototype.getRegistration = function (token) {
        if (this.isRegistered(token)) {
            return this._registry.get(token);
        }
        if (this.parent) {
            return this.parent.getRegistration(token);
        }
        return null;
    };
    InternalDependencyContainer.prototype.getAllRegistrations = function (token) {
        if (this.isRegistered(token)) {
            return this._registry.getAll(token);
        }
        if (this.parent) {
            return this.parent.getAllRegistrations(token);
        }
        return null;
    };
    InternalDependencyContainer.prototype.construct = function (ctor, context) {
        var _this = this;
        if (ctor instanceof DelayedConstructor) {
            return ctor.createProxy(function (target) {
                return _this.resolve(target, context);
            });
        }
        var instance = (function () {
            var paramInfo = typeInfo.get(ctor);
            if (!paramInfo || paramInfo.length === 0) {
                if (ctor.length === 0) {
                    return new ctor();
                }
                else {
                    throw new Error("TypeInfo not known for \"" + ctor.name + "\"");
                }
            }
            var params = paramInfo.map(_this.resolveParams(context, ctor));
            return new (ctor.bind.apply(ctor, tslib_es6_spread([void 0], params)))();
        })();
        if (isDisposable(instance)) {
            this.disposables.add(instance);
        }
        return instance;
    };
    InternalDependencyContainer.prototype.resolveParams = function (context, ctor) {
        var _this = this;
        return function (param, idx) {
            var _a, _b, _c;
            try {
                if (injection_token_isTokenDescriptor(param)) {
                    if (injection_token_isTransformDescriptor(param)) {
                        return param.multiple
                            ? (_a = _this.resolve(param.transform)).transform.apply(_a, tslib_es6_spread([_this.resolveAll(param.token)], param.transformArgs)) : (_b = _this.resolve(param.transform)).transform.apply(_b, tslib_es6_spread([_this.resolve(param.token, context)], param.transformArgs));
                    }
                    else {
                        return param.multiple
                            ? _this.resolveAll(param.token)
                            : _this.resolve(param.token, context);
                    }
                }
                else if (injection_token_isTransformDescriptor(param)) {
                    return (_c = _this.resolve(param.transform, context)).transform.apply(_c, tslib_es6_spread([_this.resolve(param.token, context)], param.transformArgs));
                }
                return _this.resolve(param, context);
            }
            catch (e) {
                throw new Error(error_helpers_formatErrorCtor(ctor, idx, e));
            }
        };
    };
    InternalDependencyContainer.prototype.ensureNotDisposed = function () {
        if (this.disposed) {
            throw new Error("This container has been disposed, you cannot interact with a disposed container");
        }
    };
    return InternalDependencyContainer;
}());
var dependency_container_instance = new InternalDependencyContainer();
/* harmony default export */ const dependency_container = ((/* unused pure expression or super */ null && (dependency_container_instance)));

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js





function autoInjectable() {
    return function (target) {
        var paramInfo = getParamInfo(target);
        return (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, __spread(args.concat(paramInfo.slice(args.length).map(function (type, index) {
                    var _a, _b, _c;
                    try {
                        if (isTokenDescriptor(type)) {
                            if (isTransformDescriptor(type)) {
                                return type.multiple
                                    ? (_a = globalContainer
                                        .resolve(type.transform)).transform.apply(_a, __spread([globalContainer.resolveAll(type.token)], type.transformArgs)) : (_b = globalContainer
                                    .resolve(type.transform)).transform.apply(_b, __spread([globalContainer.resolve(type.token)], type.transformArgs));
                            }
                            else {
                                return type.multiple
                                    ? globalContainer.resolveAll(type.token)
                                    : globalContainer.resolve(type.token);
                            }
                        }
                        else if (isTransformDescriptor(type)) {
                            return (_c = globalContainer
                                .resolve(type.transform)).transform.apply(_c, __spread([globalContainer.resolve(type.token)], type.transformArgs));
                        }
                        return globalContainer.resolve(type);
                    }
                    catch (e) {
                        var argIndex = index + args.length;
                        throw new Error(formatErrorCtor(target, argIndex, e));
                    }
                })))) || this;
            }
            return class_1;
        }(target));
    };
}
/* harmony default export */ const auto_injectable = ((/* unused pure expression or super */ null && (autoInjectable)));

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/reflection-helpers.js
var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
function reflection_helpers_getParamInfo(target) {
    var params = Reflect.getMetadata("design:paramtypes", target) || [];
    var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    Object.keys(injectionTokens).forEach(function (key) {
        params[+key] = injectionTokens[key];
    });
    return params;
}
function defineInjectionTokenMetadata(data, transform) {
    return function (target, _propertyKey, parameterIndex) {
        var descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
        descriptors[parameterIndex] = transform
            ? {
                token: data,
                transform: transform.transformToken,
                transformArgs: transform.args || []
            }
            : data;
        Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/inject.js

function inject(token) {
    return defineInjectionTokenMetadata(token);
}
/* harmony default export */ const decorators_inject = (inject);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/injectable.js


function injectable_injectable() {
    return function (target) {
        typeInfo.set(target, reflection_helpers_getParamInfo(target));
    };
}
/* harmony default export */ const decorators_injectable = (injectable_injectable);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/registry.js


function registry_registry(registrations) {
    if (registrations === void 0) { registrations = []; }
    return function (target) {
        registrations.forEach(function (_a) {
            var token = _a.token, options = _a.options, provider = __rest(_a, ["token", "options"]);
            return globalContainer.register(token, provider, options);
        });
        return target;
    };
}
/* harmony default export */ const decorators_registry = ((/* unused pure expression or super */ null && (registry_registry)));

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/singleton.js


function singleton() {
    return function (target) {
        decorators_injectable()(target);
        dependency_container_instance.registerSingleton(target);
    };
}
/* harmony default export */ const decorators_singleton = (singleton);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/scoped.js


function scoped(lifecycle, token) {
    return function (target) {
        injectable()(target);
        globalContainer.register(token || target, target, {
            lifecycle: lifecycle
        });
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/index.js










;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/index.js
if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
    throw new Error("tsyringe requires a reflect polyfill. Please add 'import \"reflect-metadata\"' to the top of your entry point.");
}







;// CONCATENATED MODULE: ./src/ignition-interactive/core/control/command/ControlCommand.ts
class ControlCommand {
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/event/UIStateEvent.ts
var UIStateEvent;
(function (UIStateEvent) {
    UIStateEvent["SETTINGS_OPEN_CHANGED"] = "uiSettingsOpenChanged";
    UIStateEvent["ACTIVE_PANEL_CHANGED"] = "uiPanelChanged";
    UIStateEvent["ACTIVE_POPUP_CHANGED"] = "uiPopupChanged";
    UIStateEvent["INTERACTIVE_PANEL_TRUE"] = "uiPanelInteractivityChangedTrue";
    UIStateEvent["INTERACTIVE_PANEL_FALSE"] = "uiPanelInteractivityChangedFalse";
})(UIStateEvent || (UIStateEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/UIState.ts


var UIPanelType;
(function (UIPanelType) {
    UIPanelType["RULES"] = "rules";
    UIPanelType["HISTORY"] = "history";
    UIPanelType["AUTOSPIN_SETTINGS"] = "autospinSettings";
    UIPanelType["BET_SETTINGS"] = "betSettings";
    UIPanelType["PAYTABLE"] = "paytable";
    UIPanelType["MENU_SETTINGS"] = "SystemSettingsPanel";
})(UIPanelType || (UIPanelType = {}));
class UIState extends (eventemitter3_default()) {
    constructor() {
        super(...arguments);
        this._settingsOpen = false;
        this._activePanel = null;
    }
    get settingsOpen() {
        return this._settingsOpen;
    }
    set settingsOpen(value) {
        if (this._settingsOpen == value) {
            return;
        }
        this._settingsOpen = value;
        this.emit(UIStateEvent.SETTINGS_OPEN_CHANGED, value);
    }
    get activePanel() {
        return this._activePanel;
    }
    set activePanel(type) {
        if (this._activePanel == type) {
            return;
        }
        this._activePanel = type;
        this.emit(UIStateEvent.ACTIVE_PANEL_CHANGED, type);
    }
    set interactivity(value) {
        if (this._interactivity == value)
            return;
        this._interactivity = value;
        switch (this._interactivity) {
            case true:
                this.emit(UIStateEvent.INTERACTIVE_PANEL_TRUE);
                break;
            case false:
                this.emit(UIStateEvent.INTERACTIVE_PANEL_FALSE);
                break;
        }
    }
    get interactivity() {
        return this._interactivity;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/event/UIPanelEvent.ts
var UIPanelEvent;
(function (UIPanelEvent) {
    UIPanelEvent["OPEN_SETTINGS"] = "uiSettingsOpen";
    UIPanelEvent["CLOSE_SETTINGS"] = "uiSettingsClose";
    UIPanelEvent["OPEN_PANEL"] = "uiPanelOpen";
    UIPanelEvent["CLOSE_PANEL"] = "uiPanelClose";
    UIPanelEvent["SHOW_POPUP"] = "uiPopupShow";
    UIPanelEvent["HIDE_POPUP"] = "uiPopupHide";
    UIPanelEvent["SET_INTERACTIVITY_TRUE"] = "uiSetInteractivityTrue";
    UIPanelEvent["SET_INTERACTIVITY_FALSE"] = "uiSetInteractivityFalse";
})(UIPanelEvent || (UIPanelEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/ChangeUISettingsStateCommand.ts




class ChangeUISettingsStateCommand extends ControlCommand {
    execute(event) {
        const uiState = dependency_container_instance.resolve(UIState);
        uiState.settingsOpen = event.type == UIPanelEvent.OPEN_SETTINGS;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/ClosePanelCommand.ts



class ClosePanelCommand extends ControlCommand {
    execute(event) {
        const uiState = dependency_container_instance.resolve(UIState);
        uiState.activePanel = null;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/PopupState.ts


var PopupType;
(function (PopupType) {
    PopupType["NOT_ENOUGH_BALANCE"] = "notEnoughBalance";
    PopupType["CONNECTION_LOST"] = "connectionLost";
    PopupType["FREESPIN_BUY"] = "freespinBuy";
    PopupType["HOLD_AND_SPINNER_BUY"] = "holdAndSpinnerBuy";
    PopupType["TURBO_ACTIVATE"] = "turboActivate";
})(PopupType || (PopupType = {}));
class PopupData {
    constructor() {
        this.hideOnClick = false;
        this.duration = -1;
        this.callbacks = null;
    }
}
class PopupState extends (eventemitter3_default()) {
    constructor() {
        super(...arguments);
        this._activePopup = null;
    }
    get activePopup() {
        return this._activePopup;
    }
    set activePopup(popup) {
        this._activePopup = popup;
        this.emit(UIStateEvent.ACTIVE_POPUP_CHANGED, popup);
    }
    get activeType() {
        return this._activePopup.type;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/HidePopupCommand.ts



class HidePopupCommand extends ControlCommand {
    execute(event) {
        const popupState = dependency_container_instance.resolve(PopupState);
        popupState.activePopup = null;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/OpenPanelCommand.ts



class OpenPanelCommand extends ControlCommand {
    execute(event) {
        const uiState = dependency_container_instance.resolve(UIState);
        const panelData = event.data;
        uiState.activePanel = panelData;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/ShowPopupCommand.ts



class ShowPopupCommand extends ControlCommand {
    execute(event) {
        const popupState = dependency_container_instance.resolve(PopupState);
        popupState.activePopup = event.data;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/tsyringe/tokens/CommonTokenConstants.ts
var CommonTokenConstants;
(function (CommonTokenConstants) {
    CommonTokenConstants["MOBILE_BORDER_PADDING"] = "mobileBorderPadding";
    CommonTokenConstants["AUTOSPIN_PANEL_BUTTON_SPACING"] = "autospinPanelButtonSpacing";
    CommonTokenConstants["AUTOSPIN_PANEL_CHECKBOX_SPACING"] = "autospinPanelCheckbox";
    CommonTokenConstants["AUTOSPIN_PANEL_MOBILE_MAX_BUTTONS_IN_ROW"] = "autospinPanelMobileMaxButtonsInRow";
    CommonTokenConstants["AUTOSPIN_PANEL_NUMBER_OF_SPINS"] = "autospinPanelNumberOfSpins";
    CommonTokenConstants["AUTOSPIN_PANEL_MOBILE_CONTAINER_WIDTH"] = "autospinPanelMobileContainerWidth";
    CommonTokenConstants["CASCADE_HISTORY_CELL_MAX_FONT_SIZE"] = "cascadeHistoryCellMaxFontSize";
    CommonTokenConstants["CASCADE_HISTORY_VIEW_FALLING_TIME"] = "cascadeHistoryViewFallingTime";
    CommonTokenConstants["CASCADE_HISTORY_VIEW_MAX_ELEMENTS"] = "cascadeHistoryViewMaxElements";
    CommonTokenConstants["CASCADE_HISTORY_VIEW_CELL_OFFSET"] = "cascadeHistoryViewCellOffset";
    CommonTokenConstants["CHECKBOX_OPTION_ALLOWED_CHARS"] = "checkboxOptionAllowedChars";
    CommonTokenConstants["CHECKBOX_OPTION_FONT"] = "checkboxOptionFont";
    CommonTokenConstants["CHECKBOX_OPTION_TEXT_COLOR"] = "checkboxOptionTextColor";
    CommonTokenConstants["CHECKBOX_OPTION_FONT_SIZE"] = "checkboxOptionFontSize";
    CommonTokenConstants["DOUBLE_CHANCE_BUTTON_COST_RATE"] = "doubleChanceButtonCostRate";
    CommonTokenConstants["PAYTABEL_PANEL_SYMBOL_CELL_SPACING"] = "paytablePanelSymbolCellSpacing";
    CommonTokenConstants["PAYTBALE_PANEL_MOBILE_TEXTFIELD_VERTICAL_SPACING"] = "paytablePanelMobileTextfieldVerticalSpacing";
    CommonTokenConstants["HISTORY_PANEL_DESKTOP_BORDER_PADDING"] = "historyPanelDesktopBorderPadding";
    CommonTokenConstants["HISTORY_PANEL_DESKTOP_BACKGROUND_WIDTH"] = "historyPanelDesktopBackgroundWidth";
    CommonTokenConstants["HISTORY_PANEL_DESKTOP_CELL_WIDTH"] = "historyPanelDesktopCellWidth";
    CommonTokenConstants["HOLD_AND_SPINNER_MULTI_STYLED_TEXT"] = "holdAndSpinnerMultiStyledText";
    CommonTokenConstants["FREESPIN_MULTI_STYLED_TEXT"] = "freespinMultiStyledText";
    CommonTokenConstants["PAYTABLE_PANEL_SYMBOL_DESCRIPTION_SPACING"] = "paytablePanelSymbolDescriptionSpacing";
    CommonTokenConstants["WILD_MULTIPLIER_STYLE"] = "wildMultiplierStyle";
    CommonTokenConstants["MULTIPLIER_STYLE"] = "multiplierStyle";
})(CommonTokenConstants || (CommonTokenConstants = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/tsyringe/tokens/defaults.ts


dependency_container_instance.register(CommonTokenConstants.MOBILE_BORDER_PADDING, { useValue: 100 });
dependency_container_instance.register(CommonTokenConstants.HISTORY_PANEL_DESKTOP_CELL_WIDTH, { useValue: 1204 });
dependency_container_instance.register(CommonTokenConstants.AUTOSPIN_PANEL_BUTTON_SPACING, { useValue: { x: 20, y: 25 } });
dependency_container_instance.register(CommonTokenConstants.AUTOSPIN_PANEL_CHECKBOX_SPACING, {
    useValue: {
        mobile: { x: 0, y: 40 },
        desktop: { x: 50, y: 10 }
    }
});
dependency_container_instance.register(CommonTokenConstants.AUTOSPIN_PANEL_MOBILE_MAX_BUTTONS_IN_ROW, { useValue: 4 });
dependency_container_instance.register(CommonTokenConstants.AUTOSPIN_PANEL_NUMBER_OF_SPINS, { useValue: [10, 30, 50, 80, 1000] });
dependency_container_instance.register(CommonTokenConstants.AUTOSPIN_PANEL_MOBILE_CONTAINER_WIDTH, { useValue: 1000 });
dependency_container_instance.register(CommonTokenConstants.CASCADE_HISTORY_CELL_MAX_FONT_SIZE, { useValue: 20 });
dependency_container_instance.register(CommonTokenConstants.CASCADE_HISTORY_VIEW_FALLING_TIME, { useValue: 0.3 });
dependency_container_instance.register(CommonTokenConstants.CASCADE_HISTORY_VIEW_MAX_ELEMENTS, { useValue: 4 });
dependency_container_instance.register(CommonTokenConstants.CASCADE_HISTORY_VIEW_CELL_OFFSET, { useValue: 2 });
dependency_container_instance.register(CommonTokenConstants.CHECKBOX_OPTION_ALLOWED_CHARS, { useValue: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.'] });
dependency_container_instance.register(CommonTokenConstants.CHECKBOX_OPTION_FONT, { useValue: 'Alexandria' });
dependency_container_instance.register(CommonTokenConstants.CHECKBOX_OPTION_TEXT_COLOR, { useValue: '0xffffff' });
dependency_container_instance.register(CommonTokenConstants.CHECKBOX_OPTION_FONT_SIZE, { useValue: { mobile: 36, desktop: 15 } });
dependency_container_instance.register(CommonTokenConstants.DOUBLE_CHANCE_BUTTON_COST_RATE, { useValue: 1.25 });
dependency_container_instance.register(CommonTokenConstants.PAYTABEL_PANEL_SYMBOL_CELL_SPACING, {
    useValue: {
        desktop: { x: 60, y: 200 },
        mobile: { x: 60, y: 70 }
    }
});
dependency_container_instance.register(CommonTokenConstants.PAYTABLE_PANEL_SYMBOL_DESCRIPTION_SPACING, {
    useValue: {
        desktop: 220,
        mobile: 90
    }
});
dependency_container_instance.register(CommonTokenConstants.PAYTBALE_PANEL_MOBILE_TEXTFIELD_VERTICAL_SPACING, { useValue: 50 });
dependency_container_instance.register(CommonTokenConstants.HISTORY_PANEL_DESKTOP_BORDER_PADDING, { useValue: 40 });
dependency_container_instance.register(CommonTokenConstants.HISTORY_PANEL_DESKTOP_BACKGROUND_WIDTH, { useValue: 1260 });

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/event/IntroScreenEvent.ts
var IntroScreenEvent;
(function (IntroScreenEvent) {
    IntroScreenEvent["ON_GET_STARTED_CLICKED"] = "onGetStartedClicked";
})(IntroScreenEvent || (IntroScreenEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/ScreenOrientation.ts
/**
 * Orientation of the screen
 * @readonly
 * @enum {string}
 */
var ScreenOrientation;
(function (ScreenOrientation) {
    /**
     * Horizontal orientation where screen width is bigger than screen height
     */
    ScreenOrientation["HORIZONTAL"] = "horizontal";
    /**
     * Vertical orientation where screen height is bigger than screen width
     */
    ScreenOrientation["VERTICAL"] = "vertical";
})(ScreenOrientation || (ScreenOrientation = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/AdjustableLayoutContainer.ts


/**
 * Helper class to simplify adding internal orientation layout and children layout management
 *
 * If an item wants to support automated orientation layouts, it needs to declare it in tweenData:
 * {
 *   "layouts":[
 *     "horizontal",
 *     "vertical"
 *   ]
 * }
  */
class AdjustableLayoutContainer extends Container_Container {
    constructor(layout) {
        super();
        this.layout = layout;
    }
    updateLayout(desc) {
        var _a;
        if (((_a = this.layout) === null || _a === void 0 ? void 0 : _a.layouts.size) && this.currentOrientation != desc.orientation) {
            if (!this.currentOrientation) {
                this.currentOrientation = desc.orientation == ScreenOrientation.HORIZONTAL ? ScreenOrientation.VERTICAL : ScreenOrientation.HORIZONTAL;
            }
            const oldLayout = this.layout.layouts.get(this.currentOrientation);
            const newLayout = this.layout.layouts.get(desc.orientation);
            oldLayout.children.forEach((le, leName) => {
                if (!newLayout.children.has(leName)) {
                    if (this[leName]) {
                        const child = this[leName];
                        this.removeChild(child);
                    }
                }
            });
            newLayout.children.forEach((le, leName) => {
                if (this[leName]) {
                    const child = this[leName];
                    child.position.set(le.x, le.y);
                    child.scale.set(le.scaleX, le.scaleY);
                    child.pivot.set(le.pivotX, le.pivotY);
                    // console.warn(leName, le.x, le.y);
                    child.visible = true;
                    this.addChild(child);
                }
            });
            this.currentOrientation = desc.orientation;
        }
        this.children.forEach((child) => {
            if (child['updateLayout']) {
                child['updateLayout'](desc);
            }
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/assets/AssetsManager.ts
class AssetsManager {
    static getAnimationTextures(texturePrefix) {
        const animationTextures = [];
        const keys = [];
        AssetsManager.textures.forEach((texture, key) => {
            if (key.indexOf(texturePrefix) === 0) {
                keys.push(key);
            }
        });
        keys.sort();
        for (const key of keys) {
            if (AssetsManager.textures.has(key)) {
                const animationFrameTexture = AssetsManager.textures.get(key);
                animationTextures.push(animationFrameTexture);
            }
        }
        if (animationTextures.length) {
            return animationTextures;
        }
        else {
            return null;
        }
    }
}
AssetsManager.layouts = new Map();
AssetsManager.textures = new Map();
AssetsManager.spine = new Map();
AssetsManager.videos = new Map();
AssetsManager.sounds = new Map();
AssetsManager.xmls = new Map();
AssetsManager.webFonts = new Map();
AssetsManager.bitmapFonts = new Map();
/* harmony default export */ const assets_AssetsManager = (AssetsManager);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/LoadingProgressBar.ts


class LoadingProgressBar extends Container_Container {
    constructor(layoutElement) {
        super();
        this.currentProgress = 0;
        this.targetProgress = 0;
        this.animationSpeed = 0.02;
        this.animationAfterLoad = 20;
        this.createProgressBar();
        this.setupAnimation();
    }
    createProgressBar() {
        // Layer 1: Base Frame (GoldenStrokeMain.webp)
        const baseTexture = assets_AssetsManager.textures.get('GoldenStrokeMain');
        if (baseTexture) {
            this.baseFrame = new Sprite(baseTexture);
            this.baseFrame.anchor.set(0.5, 0.5);
            this.baseFrame.scale.set(2.3);
            this.addChild(this.baseFrame);
        }
        // Layer 2: Progress Track Background (BaseStrokepanel.webp)
        const trackTexture = assets_AssetsManager.textures.get('BaseStrokepanel');
        if (trackTexture) {
            this.trackBackground = new Sprite(trackTexture);
            this.trackBackground.anchor.set(0.5, 0.5);
            this.addChild(this.trackBackground);
        }
        // Layer 3: Progress Fill (BaseColored.webp) - this will be masked
        const fillTexture = assets_AssetsManager.textures.get('BaseColored');
        let fillSprite;
        if (fillTexture) {
            fillSprite = new Sprite(fillTexture);
            fillSprite.anchor.set(0.5, 0.5);
            this.addChild(fillSprite);
        }
        // Layer 4: Progress Fill Mask (will be clipped)
        this.fillMask = new Graphics_Graphics();
        this.fillMask.beginFill(0x000000);
        this.fillMask.drawRoundedRect(0, -fillTexture.height / 2, fillTexture.width, fillTexture.height, 12); // Initial size, will be updated
        this.fillMask.endFill();
        this.fillMask.x = -this.fillMask.width * 3 / 2;
        this.addChild(this.fillMask);
        // Apply mask to fill sprite
        if (fillSprite) {
            fillSprite.mask = this.fillMask;
        }
        // Layer 5: Animated Stripes Overlay (Stripe.webp) - slightly taller than BaseColored
        const stripeTexture = assets_AssetsManager.textures.get('Stripe');
        if (stripeTexture && fillTexture) {
            this.stripeOverlay = new TilingSprite(stripeTexture, fillTexture.width * 0.97, fillTexture.height * 0.8);
            this.stripeOverlay.anchor.set(0.5, 0.5);
            this.stripeOverlay.mask = this.fillMask;
            this.addChild(this.stripeOverlay);
        }
        // Layer 6: Highlights (on top of stripes, aligned with BaseColored and masked with progress)
        const highlightTopTexture = assets_AssetsManager.textures.get('highlightTop');
        if (highlightTopTexture && fillTexture) {
            this.highlightTop = new Sprite(highlightTopTexture);
            this.highlightTop.anchor.set(0.5, 1); // Bottom anchor for top highlight
            this.highlightTop.y = -fillTexture.height / 10; // Move very close to BaseColored center
            this.highlightTop.mask = this.fillMask; // Apply same mask as progress
            this.addChild(this.highlightTop);
        }
        const highlightBottomTexture = assets_AssetsManager.textures.get('highlightBottom');
        if (highlightBottomTexture && fillTexture) {
            this.highlightBottom = new Sprite(highlightBottomTexture);
            this.highlightBottom.anchor.set(0.5, 0); // Top anchor for bottom highlight
            this.highlightBottom.y = fillTexture.height / 10; // Move very close to BaseColored center
            this.highlightBottom.mask = this.fillMask; // Apply same mask as progress
            this.addChild(this.highlightBottom);
        }
        // Set initial progress
        this.updateProgressMask();
    }
    setupAnimation() {
        // Animate the stripe overlay continuously
        const animate = () => {
            if (this.stripeOverlay && this.stripeOverlay.parent) {
                // Move the tiling position continuously for seamless looping
                this.stripeOverlay.tilePosition.x -= 2; // Move stripes left continuously
            }
            // Smoothly animate progress
            if (this.currentProgress < this.targetProgress) {
                this.currentProgress = Math.min(this.currentProgress + this.animationSpeed, this.targetProgress);
                this.updateProgressMask();
            }
            else if (this.currentProgress > this.targetProgress) {
                this.currentProgress = Math.max(this.currentProgress - this.animationSpeed, this.targetProgress);
                this.updateProgressMask();
            }
            if (this.currentProgress < 1) {
                requestAnimationFrame(animate);
            }
            else if (this.animationAfterLoad > 0) {
                this.animationAfterLoad--;
                requestAnimationFrame(animate);
            }
        };
        requestAnimationFrame(animate);
    }
    updateProgressMask() {
        if (this.fillMask && this.baseFrame) {
            const progressWidth = this.fillMask.width * this.currentProgress;
            this.fillMask.x = -this.fillMask.width * 3 / 2 + progressWidth;
        }
    }
    // PUBLIC API
    setProgress(progress) {
        this.targetProgress = Math.max(0, Math.min(1, progress));
    }
    getProgress() {
        return this.currentProgress;
    }
    setAnimationSpeed(speed) {
        this.animationSpeed = speed;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/sound/Sound.ts
class Sound {
    constructor(howl) {
        this._volume = 1;
        this.instanceId = null;
        this.howl = howl;
    }
    play() {
        if (this.instanceId !== null) {
            this.instanceId = this.howl.play(this.instanceId);
        }
        else {
            this.instanceId = this.howl.play();
        }
    }
    stop() {
        this.howl.stop(this.instanceId);
    }
    pause() {
        this.howl.pause(this.instanceId);
    }
    seek(value) {
        this.howl.seek(value, this.instanceId);
    }
    get volume() {
        return this._volume;
    }
    set volume(value) {
        this._volume = value;
        this.howl.volume(this._volume * this.howl.volume(), this.instanceId);
    }
    set mute(value) {
        this.howl.mute(value, this.instanceId);
    }
    get duration() {
        return this.howl.duration(this.instanceId);
    }
    set loop(value) {
        this.howl.loop(value, this.instanceId);
    }
    on(event, callback) {
        this.howl.on(event, callback, this.instanceId);
    }
    off(event, callback) {
        this.howl.off(event, callback, this.instanceId);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/sound/SoundChannelEvent.ts
var SoundChannelEvent;
(function (SoundChannelEvent) {
    SoundChannelEvent["MUTE"] = "mute";
    SoundChannelEvent["UNMUTE"] = "unmute";
})(SoundChannelEvent || (SoundChannelEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/sound/SoundChannel.ts



class SoundChannel extends (eventemitter3_default()) {
    constructor(name) {
        super();
        this._volume = 1;
        this._mute = false;
        this.sounds = new Map();
        this._name = name;
    }
    addSound(soundId, howl) {
        this.sounds.set(soundId, howl);
    }
    getSound(soundId) {
        return this.sounds.get(soundId);
    }
    get name() {
        return this._name;
    }
    get volume() {
        return this._volume;
    }
    set volume(value) {
        this.sounds.forEach((h, key) => {
            h.volume(value);
        });
        this._volume = value;
    }
    get mute() {
        return this._mute;
    }
    set mute(value) {
        this._mute = value;
        this.sounds.forEach((h, key) => {
            h.mute(value);
        });
        if (this._mute) {
            this.emit(SoundChannelEvent.MUTE);
        }
        else {
            this.emit(SoundChannelEvent.UNMUTE);
        }
    }
    play(soundData) {
        var _a;
        const h = this.sounds.get(soundData.id);
        if (!this.sounds.get(soundData.id)) {
            throw new Error(`No sound with id: ${soundData.id} found on channel: ${this._name}`);
        }
        const s = new Sound(h);
        s.play();
        s.volume = (_a = soundData.volume) !== null && _a !== void 0 ? _a : 1;
        s.mute = this.mute;
        return s;
    }
    loop(soundData) {
        const s = this.play(soundData);
        s.loop = true;
        return s;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/utils/Logger.ts
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["ALL"] = 4] = "ALL";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
    static debug(...messages) {
        if (Logger.logLevel >= LogLevel.ALL) {
            console.log('[DEBUG] ' + Logger.buildMessage(messages));
        }
    }
    static info(...messages) {
        if (Logger.logLevel >= LogLevel.INFO) {
            console.log('%c[INFO] ' + Logger.buildMessage(messages), 'color: #0000FF');
        }
    }
    static warning(...messages) {
        if (Logger.logLevel >= LogLevel.WARNING) {
            console.log('%c[WARNING] ' + Logger.buildMessage(messages), 'color: #FFCC00');
        }
    }
    static error(...messages) {
        if (Logger.logLevel >= LogLevel.ERROR) {
            console.log('%c[ERROR] ' + Logger.buildMessage(messages), 'color: #FF0000');
        }
    }
    static buildMessage(messages) {
        let message = '';
        for (const m of messages) {
            message += m + ' ';
        }
        return message.substring(0, message.length - 1);
    }
}
Logger.logLevel = LogLevel.ALL;
/* harmony default export */ const utils_Logger = (Logger);

// EXTERNAL MODULE: ./node_modules/howler/dist/howler.js
var howler = __webpack_require__(1766);
;// CONCATENATED MODULE: ./src/ignition-interactive/core/sound/SoundManager.ts



class SoundManager {
    static getChannel(channelName) {
        if (!SoundManager.channels.get(channelName)) {
            SoundManager.channels.set(channelName, new SoundChannel(channelName));
        }
        return SoundManager.channels.get(channelName);
    }
    static addSoundToChannel(soundId, sound, channelName = 'default') {
        const sc = SoundManager.getChannel(channelName);
        sc.addSound(soundId, sound);
    }
    static play(sound) {
        var _a;
        let soundData;
        if (typeof sound == 'string') {
            soundData = {
                id: sound
            };
        }
        else {
            soundData = sound;
        }
        utils_Logger.debug('Play sound: ' + soundData.id);
        const sc = SoundManager.getChannel((_a = soundData.channel) !== null && _a !== void 0 ? _a : 'default');
        return sc.play(soundData);
    }
    static playQueue(soundsIds, volume = 1, gap = 0, channelName = 'default') {
        const s = SoundManager.play({
            id: soundsIds.shift(),
            volume: volume,
            channel: channelName
        });
        const onEnd = function () {
            if (gap > 0) {
                setTimeout(() => {
                    SoundManager.playQueue(soundsIds, volume, gap, channelName);
                }, gap);
            }
            else {
                SoundManager.playQueue(soundsIds, volume, gap, channelName);
            }
            s.off('end', onEnd);
        };
        if (soundsIds.length) {
            s.on('end', onEnd);
        }
    }
    static loop(sound) {
        var _a;
        let soundData;
        if (typeof sound == 'string') {
            soundData = {
                id: sound
            };
        }
        else {
            soundData = sound;
        }
        utils_Logger.debug('Loop sound: ' + soundData.id);
        const sc = SoundManager.getChannel((_a = soundData.channel) !== null && _a !== void 0 ? _a : 'default');
        return sc.loop(soundData);
    }
    static get mute() {
        return this._mute;
    }
    static set mute(value) {
        this._mute = value;
        utils_Logger.debug(`Soun mute > ${this._mute}`);
        howler.Howler.mute(value);
    }
}
SoundManager.channels = new Map();
SoundManager._mute = false;
/* harmony default export */ const sound_SoundManager = (SoundManager);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/sound/SoundList.ts
class SoundList {
}
SoundList.GENERIC_WIN = 'generic_win';
SoundList.GOOD_WIN = 'big_win';
SoundList.HUGE_WIN = 'super_win';
SoundList.GREAT_WIN = 'mega_win';
SoundList.INSANE_WIN = 'ultra_win';
SoundList.UI_BUTTON_CLICK = 'button_click';
SoundList.UI_BUTTON_SPIN_START = 'button_spin_start';
SoundList.UI_BUTTON_SPIN_STOP = 'button_spin_stop';
SoundList.UI_REEL_SPIN = 'reel_spin';
SoundList.UI_REEL_STOP = 'reel_stop';
SoundList.UI_POPUP_COMMON_WINDOW = 'common_popup_window';
SoundList.UI_POPUP_HIDE = 'popup_hide';
SoundList.UI_POPUP_SHOW = 'show_popup';
SoundList.TRANSITION = 'transition';
SoundList.FREESPIN_AWARD = 'freespin_award';
SoundList.FREESPIN_WIN = 'freespin_win';
SoundList.UI_ERROR_APPEARANCE = 'error_appearance';
SoundList.COUNTER_LOOP = 'counter_loop';
SoundList.COUNTER_END = 'counter_end';
SoundList.TOTAL_WIN_APPEARANCE = 'total_win_appearance';
/* harmony default export */ const sound_SoundList = (SoundList);

// EXTERNAL MODULE: ./src/ignition-interactive/core/tweener/ignitionTween.js
var ignitionTween = __webpack_require__(5671);
;// CONCATENATED MODULE: ./src/ignition-interactive/core/translations/Translation.ts
// TODO: create a proper translation system based on one of the existing libraries instead of this stopgap solution

class Translation {
    static addLanguageData(languageId, data) {
        if (Translation.languagesData.has(languageId)) {
            utils_Logger.warning(`Language with id '${languageId}' already exists`);
            return;
        }
        const map = new Map();
        Translation.processBundle(map, data);
        Translation.languagesData.set(languageId, map);
    }
    static processBundle(map, data, prefix = '') {
        for (const key in data) {
            const entry = data[key];
            if (typeof entry === 'string') {
                // console.log(`${prefix}${key}`, entry);
                map.set(`${prefix}${key}`, entry);
            }
            else {
                Translation.processBundle(map, entry, `${prefix}${key}.`);
            }
        }
    }
    static setCurrentLanguage(languageId) {
        Translation.currentLanguage = languageId;
    }
    static t(key) {
        var _a;
        if (!Translation.languagesData.has(Translation.currentLanguage)) {
            utils_Logger.warning(`No language data for current language '${Translation.currentLanguage}' defined`);
        }
        const data = Translation.languagesData.get(Translation.currentLanguage);
        // return original key string if the translation is not found
        return (_a = data.get(key)) !== null && _a !== void 0 ? _a : key;
    }
}
Translation.languagesData = new Map();
Translation.currentLanguage = 'en';
/* harmony default export */ const translations_Translation = (Translation);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/LoadingScreen.ts








class LoadingScreen extends AdjustableLayoutContainer {
    constructor(onCompleteCallback) {
        super(null);
        this.isClickable = false;
        this.background = new Sprite(assets_AssetsManager.textures.get('loading-screen'));
        this.background.anchor.set(0.5, 0.5);
        this.addChild(this.background);
        this.character = new Sprite(assets_AssetsManager.textures.get('character'));
        this.character.anchor.set(0.5, 0.5);
        this.character.pivot.y = 189.25;
        this.addChild(this.character);
        this.characterLogo = new Sprite(assets_AssetsManager.textures.get('Logo'));
        this.characterLogo.anchor.set(0.5, 0.5);
        this.characterLogo.position.y = -330;
        this.progressBar = new LoadingProgressBar();
        this.addChild(this.progressBar);
        this.createGradientBottom();
        this.footerText = new Sprite(assets_AssetsManager.textures.get('footerText'));
        this.footerText.anchor.set(0.5, 0.5);
        this.addChild(this.footerText);
        this.startButton = new Sprite(assets_AssetsManager.textures.get('startbutton'));
        this.startButton.anchor.set(0.5, 0.5);
        this.startButton.scale.set(0);
        this.startButton.position.y = -203;
        const bitmapText = new BitmapText(translations_Translation.t('tfstart'), {
            fontName: 'Alexandria-Bold',
            fontSize: 70,
            align: 'center',
            tint: 0x00022B
        });
        bitmapText.y = 10;
        bitmapText.anchor.set(0.5, 0.5);
        this.startButton.addChild(bitmapText);
        this.footerText.addChild(this.characterLogo, this.startButton);
        this.callback = onCompleteCallback;
        this.once('added', () => {
            this.handleWindowResize();
            this.interactive = true;
            this.once('pointerup', this.onPopupClick, this);
        });
    }
    onPopupClick() {
        if (!this.isClickable) {
            Howler.ctx.resume();
            this.isClickable = true;
        }
        if (LoadingScreen.finished) {
            this.interactive = false;
            setTimeout(() => {
                sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
                if (this.callback) {
                    this.callback();
                    this.callback = null;
                }
                this.isClickable = false;
            }, 100);
            this.removeAllListeners();
        }
    }
    updateLayout(desc) {
        this.handleWindowResize();
    }
    createGradientBottom() {
        // Create a gradient texture in memory
        const gradientCanvas = document.createElement('canvas');
        gradientCanvas.width = 1;
        gradientCanvas.height = 400; // Base height for the gradient
        const ctx = gradientCanvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)'); // top transparent
        gradient.addColorStop(1, "#00022B"); // bottom blue
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 2, 400);
        const gradientTexture = Texture.from(gradientCanvas);
        // Create sprite with gradient texture (will be sized in updateLayout)
        this.gradientBottom = new Sprite(gradientTexture);
        this.gradientBottom.tint = 0x002479;
        this.gradientBottom.anchor.set(0, 1); // Anchor at bottom-left for easy positioning
        this.addChild(this.gradientBottom);
    }
    stop() {
        if (!LoadingScreen.finished) {
            LoadingScreen.finished = true;
            if (this.isClickable) {
                if (this.callback) {
                    this.callback();
                    this.callback = null;
                    this.interactive = false;
                }
            }
            else {
                ignitionTween.Tweener.addTween(this.progressBar, {
                    alpha: 0,
                    time: 0.1,
                    transition: 'linear',
                    onComplete: () => {
                        // Style the button
                        ignitionTween.Tweener.addTween(this.startButton.scale, {
                            x: 1,
                            y: 1,
                            time: 0.6,
                            transition: 'easeOutBounce'
                        });
                        const targetY = this.characterLogo.position.y - 100;
                        ignitionTween.Tweener.addTween(this.characterLogo.position, {
                            y: targetY,
                            time: 0.6,
                            transition: 'easeOutBounce',
                        });
                    }
                });
            }
        }
    }
    handleWindowResize() {
        if (!this.parent) {
            return;
        }
        const parentScale = this.parent ? this.parent.scale.x : 1;
        const parentOffset = this.parent ? this.parent.position : { x: 0, y: 0 };
        const inverseParentScale = 1 / parentScale;
        this.scale.set(inverseParentScale);
        this.position.set(-parentOffset.x * inverseParentScale, -parentOffset.y * inverseParentScale);
        const baseWidth = 1920; // Base game width
        const baseHeight = 1080; // Base game height
        const width = window.innerWidth;
        const height = window.innerHeight;
        const yScale = height / baseHeight;
        const xScale = width / baseWidth;
        const scale = Math.min(xScale * 2, yScale);
        // Background: Scale on Y-axis to be full screen
        if (width > height * (baseWidth / baseHeight)) {
            this.background.scale.set(xScale);
        }
        else {
            this.background.scale.set(yScale);
        }
        this.background.x = width / 2;
        this.background.y = height / 2;
        // Character: Always keep centered
        this.character.x = width / 2;
        this.character.y = height / 2;
        this.character.scale.set(scale);
        // Gradient bottom: Always at bottom of screen, full width
        this.gradientBottom.width = width;
        this.gradientBottom.height = 400 * yScale; // Scale gradient height
        this.gradientBottom.x = 0;
        this.gradientBottom.y = height; // Bottom of screen since anchor is (0,1)
        // Footer text: Center horizontally at bottom, positioned within gradient area
        this.footerText.x = width / 2;
        this.footerText.y = height - (this.gradientBottom.height * 0.3); // Position in lower part of gradient
        this.footerText.scale.set(scale);
        // Progress bar: Center horizontally and position at bottom
        if (this.progressBar) {
            this.progressBar.x = width / 2;
            this.progressBar.y = height - (this.gradientBottom.height * 0.3) - 100 * scale; // Position above footer text
            this.progressBar.scale.set(scale);
        }
    }
    setProgress(progress) {
        if (this.progressBar) {
            this.progressBar.setProgress(progress);
        }
    }
    simulateLoading() {
        // Removed simulated loading - now using real asset loading progress
        // Progress is updated via setProgress() calls from SugarDaddy.ts
    }
    destroy() {
        this.background.destroy();
        this.character.destroy();
        this.characterLogo.destroy();
        this.footerText.destroy();
        this.gradientBottom.destroy();
        this.progressBar.destroy();
        super.destroy();
    }
}
LoadingScreen.finished = false;
var LoadingState;
(function (LoadingState) {
    LoadingState["START"] = "start";
    LoadingState["PROGRESS"] = "progress";
    LoadingState["END"] = "end";
})(LoadingState || (LoadingState = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/control/event/ApplicationEvent.ts
var ApplicationEvent;
(function (ApplicationEvent) {
    ApplicationEvent["INIT"] = "onApplicationInit";
    ApplicationEvent["LOADING_COMPLETE"] = "onApplicationLoadingComplete";
})(ApplicationEvent || (ApplicationEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/events/Event.ts
class Event_Event {
    constructor(type, data) {
        this.target = null;
        this.type = type;
        this.data = data;
    }
    clone() {
        const e = new Event_Event(this.type, this.data);
        e.target = this.target;
        return e;
    }
}
Event_Event.COMPLETE = 'onComplete';
Event_Event.PROGRESS = 'onProgress';
/* harmony default export */ const events_Event = (Event_Event);

;// CONCATENATED MODULE: ./src/ignition-interactive/core/events/EventDispatcher.ts
class EventDispatcher {
    constructor() {
        this.listeners = new Map();
    }
    /*
    PUBLIC API
     */
    addEventListener(type, listener, context = null) {
        if (!this.listeners.has(type)) {
            this.listeners.set(type, new Array());
        }
        const typeListeners = this.listeners.get(type);
        const fc = new FunctionContext(listener, context);
        if (this.arrayIndexOf(typeListeners, fc) == -1) {
            typeListeners.push(fc);
        }
    }
    removeEventListener(type, listener, context = null) {
        if (this.listeners.has(type)) {
            const typeListeners = this.listeners.get(type);
            const fc = new FunctionContext(listener, context);
            if (this.arrayIndexOf(typeListeners, fc) != -1) {
                typeListeners.splice(this.arrayIndexOf(typeListeners, fc), 1);
            }
            if (!typeListeners.length) {
                this.listeners.delete(type);
            }
        }
    }
    hasEventListener(type) {
        return this.listeners.has(type);
    }
    dispatchEvent(event) {
        if (this.listeners.has(event.type)) {
            const eventListeners = this.listeners.get(event.type);
            for (const fc of eventListeners) {
                fc.f.apply(fc.c, [event]);
            }
        }
    }
    arrayIndexOf(arr, fc) {
        for (let i = 0; i < arr.length; i++) {
            const el = arr[i];
            if (el.c == fc.c && el.f == fc.f) {
                return i;
            }
        }
        return -1;
    }
}
class FunctionContext {
    constructor(f, c) {
        this.f = f;
        this.c = c;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/control/event/ControlEventDispatcher.ts

class ControlEventDispatcher extends EventDispatcher {
    constructor() {
        super();
        if (ControlEventDispatcher.instance) {
            throw new Error('You cannot instatiate ControlEventDispatcher directly!');
        }
    }
    /*
     * PUBLIC API
     */
    static getInstance() {
        if (!ControlEventDispatcher.instance) {
            ControlEventDispatcher.instance = new ControlEventDispatcher();
        }
        return ControlEventDispatcher.instance;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/control/event/ControlEvent.ts


class ControlEvent extends events_Event {
    constructor(type, data) {
        super(type, data);
        this.controlEventDispatcher = ControlEventDispatcher.getInstance();
    }
    dispatch() {
        this.controlEventDispatcher.dispatchEvent(this);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/IgnitionCore.ts
const IgnitionCore_VERSION = '1.11.0';

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutElement.ts
class LayoutElement {
    constructor(name) {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.scaleX = 0;
        this.scaleY = 0;
        this.pivotX = 0;
        this.pivotY = 0;
        this.rotation = 0;
        this.hitArea = null;
        this.alpha = 1;
        this.children = new Map();
        this.customClass = '';
        this.mask = null;
        this.render = true;
        this.effects = [];
        this.layouts = new Map();
        this.color = 0xFFFFFF;
        this.name = name;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutElementImage.ts

class LayoutElementImage extends LayoutElement {
    constructor(name, texture) {
        super(name);
        this.scale9Grid = null;
        this.tileGrid = null;
        this.texture = texture;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutElementTextField.ts

class LayoutElementTextField extends LayoutElement {
    constructor(name, text, textFormat) {
        super(name);
        this.text = text;
        if (textFormat) {
            this.textFormat = textFormat;
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutElementQuad.ts

class LayoutElementQuad extends LayoutElement {
    constructor(name, color) {
        super(name);
        this.color = color;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutElementAnimation.ts

class LayoutElementAnimation extends LayoutElement {
    constructor(name, texturePrefix, fps, loop) {
        super(name);
        this.texturePrefix = texturePrefix;
        this.fps = fps;
        this.loop = loop;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/utils/Utils.ts
const degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};
const radToDeg = function radToDeg(radians) {
    return radians * 180 / Math.PI;
};
const getConfigValue = function (configObject, parameterName, defaultValue = undefined) {
    if (parameterName.indexOf('.') != -1) {
        const firstItem = parameterName.substring(0, parameterName.indexOf('.'));
        const restItem = parameterName.substring(parameterName.indexOf('.') + 1);
        const firstObj = this.getConfigValue(configObject, firstItem);
        if (firstObj) {
            return this.getConfigValue(firstObj, restItem, defaultValue);
        }
    }
    else if (configObject.hasOwnProperty(parameterName) && configObject[parameterName] != '') {
        return configObject[parameterName];
    }
    return defaultValue;
};
const removeArrayElement = function (array, element) {
    if (array.indexOf(element) != -1) {
        array.splice(array.indexOf(element), 1);
    }
    return array;
};
const arrayFill = function (array, value) {
    const O = array;
    const len = O.length;
    const start = arguments[1];
    const relativeStart = parseInt(start, 10) || 0;
    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    const end = arguments[2];
    const relativeEnd = end === undefined ? len : (parseInt(end) || 0);
    const final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
    for (; k < final; k++) {
        O[k] = value;
    }
    return O;
};
const arrayUnique = function (array) {
    return array.filter((value, index, array) => {
        return array.indexOf(value) === index;
    });
};
const randomRange = function (min, max) {
    return Math.random() * (max - min) + min;
};
/**
 * Returns random integer within range <min, max>, both values inclusive
 * @param min
 * @param max
 */
const randomInt = function (min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
const randomArrayElement = function (arr) {
    if (arr && arr.length) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    return null;
};
const arrayShuffle = function (array) {
    const inputArray = array;
    for (let i = inputArray.length - 1; i >= 0; i--) {
        const randomIndex = Math.floor(Math.random() * (i + 1));
        const itemAtIndex = inputArray[randomIndex];
        inputArray[randomIndex] = inputArray[i];
        inputArray[i] = itemAtIndex;
    }
    return inputArray;
};

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/effect/DropShadowEffect.ts


/**
 * Example:
 * {
 *      "effects":[
 *          {
 *              "type":"dropShadow"
 *              "options":{
 *                  "alpha":1,
 *                  "angle":0,
 *                  "blur":6,
 *                  "color":"0x42B0FF",
 *                  distance":0
 *              },
 *          }
 *      ]
 * }
 */
class DropShadowEffect {
    constructor(options) {
        this.options = {
            color: options.color,
            alpha: options.alpha,
            angle: options.angle ? degToRad(options.angle) : 0,
            blur: options.blur | 0,
            distance: options.distance | 0
        };
    }
    apply(displayObject) {
        if (displayObject instanceof Text) {
            const tf = displayObject;
            const ts = tf.style;
            ts.dropShadow = true;
            ts.dropShadowAlpha = this.options.alpha;
            ts.dropShadowAngle = this.options.angle;
            ts.dropShadowBlur = this.options.blur;
            ts.dropShadowColor = this.options.color;
            ts.dropShadowDistance = this.options.distance;
            ts.padding = Math.max(ts.padding, this.options.distance + this.options.blur);
            tf.style = ts;
        }
        else {
            throw new Error('Unsupported DisplayObject for effect DropShadowEffect');
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/effect/StrokeEffect.ts


/**
 * Example:
 * {
 *      "effects":[
 *          {
 *              "type":"stroke"
 *              "options":{
 *                  "color":"0xFFFFFF",
 *                  "lineJoin":"round",
 *                  "thickness":1
 *              },
 *          }
 *      ]
 * }
 */
class StrokeEffect {
    constructor(options) {
        this.options = {
            color: options.color,
            thickness: options.thickness,
            lineJoin: options.lineJoin || 'round'
        };
    }
    apply(displayObject) {
        if (displayObject instanceof Text) {
            const tf = displayObject;
            const ts = tf.style;
            ts.stroke = this.options.color;
            ts.strokeThickness = this.options.thickness;
            ts.padding = Math.max(ts.padding, this.options.thickness);
            ts.lineJoin = this.options.lineJoin;
            tf.style = ts;
        }
        else {
            utils_Logger.error('Unsupported DisplayObject for effect StrokeEffect');
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/effect/GradientEffect.ts


/**
 * Example:
 * {
 *      "effects":[
 *          {
 *              "type":"gradient"
 *              "options":{
 *                  "fill": [
 *                      "0xFFFFFF",
 *                      "0x010101",
 *                  ],
 *                  "stopPoints": [
 *                      0,
 *                      100
 *                  ],
 *                  "orientation": "X"
 *              },
 *          }
 *      ]
 * }
 */
class GradientEffect {
    constructor(options) {
        this.options = options;
    }
    apply(displayObject) {
        if (displayObject instanceof Text) {
            const tf = displayObject;
            const ts = tf.style;
            ts.fill = this.options.fill;
            switch (this.options.orientation) {
                case 'X':
                    ts.fillGradientType = TEXT_GRADIENT.LINEAR_HORIZONTAL;
                    break;
                case 'Y':
                    ts.fillGradientType = TEXT_GRADIENT.LINEAR_VERTICAL;
                    break;
            }
            if (this.options.stopPoints) {
                ts.fillGradientStops = this.options.stopPoints;
            }
            tf.style = ts;
        }
        else {
            utils_Logger.error('Unsupported DisplayObject for effect StrokeEffect');
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/effect/EffectFactory.ts




class EffectFactory {
    static create(effectData) {
        try {
            switch (effectData.type) {
                case 'dropShadow':
                    return new DropShadowEffect(effectData.options);
                case 'stroke':
                    return new StrokeEffect(effectData.options);
                case 'gradient':
                    return new GradientEffect(effectData.options);
                default:
                    throw new Error(`Unknown effect type: ${effectData.type}`);
            }
        }
        catch (e) {
            utils_Logger.warning(e.toString());
            return null;
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutDescription.ts
var LayoutElementType;
(function (LayoutElementType) {
    LayoutElementType["SPRITE"] = "starling.display.Sprite";
    LayoutElementType["IMAGE"] = "starling.display.Image";
    LayoutElementType["TEXT_FIELD"] = "starling.text.TextField";
    LayoutElementType["QUAD"] = "starling.display.Quad";
    LayoutElementType["MOVIE_CLIP"] = "starling.display.MovieClip";
})(LayoutElementType || (LayoutElementType = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/model/LayoutElementFactory.ts











class LayoutElementFactory {
    static create(descriptionObject) {
        var _a, _b, _c;
        let le;
        switch (descriptionObject.cls) {
            case LayoutElementType.IMAGE:
                le = new LayoutElementImage(descriptionObject.params.name, descriptionObject.constructorParams[0].textureName);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                if (descriptionObject.params.hasOwnProperty('scale9Grid')) {
                    const scale9GridParams = descriptionObject.params.scale9Grid.params;
                    if (!scale9GridParams.hasOwnProperty('x')) {
                        scale9GridParams.x = 0;
                    }
                    if (!scale9GridParams.hasOwnProperty('y')) {
                        scale9GridParams.y = 0;
                    }
                    le.scale9Grid = new Rectangle(parseInt(scale9GridParams.x), parseInt(scale9GridParams.y), parseInt(scale9GridParams.width), parseInt(scale9GridParams.height));
                }
                if (descriptionObject.params.hasOwnProperty('tileGrid')) {
                    const tileGridParams = descriptionObject.params.tileGrid.params;
                    if (!tileGridParams.hasOwnProperty('x')) {
                        tileGridParams.x = 0;
                    }
                    if (!tileGridParams.hasOwnProperty('y')) {
                        tileGridParams.y = 0;
                    }
                    le.tileGrid = new Rectangle(parseInt(tileGridParams.x), parseInt(tileGridParams.y), parseInt(tileGridParams.width), parseInt(tileGridParams.height));
                }
                if (descriptionObject.params.hasOwnProperty('anchorX')) {
                    le.anchorX = descriptionObject.params.anchorX;
                }
                if (descriptionObject.params.hasOwnProperty('anchorY')) {
                    le.anchorY = descriptionObject.params.anchorY;
                }
                break;
            case LayoutElementType.TEXT_FIELD:
                let text = descriptionObject.params.text;
                if (descriptionObject.hasOwnProperty('tweenData') && descriptionObject.tweenData.hasOwnProperty('translation-key')) {
                    text = translations_Translation.t(descriptionObject.tweenData['translation-key']);
                }
                le = new LayoutElementTextField(descriptionObject.params.name, text, descriptionObject.params.format.params);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                le.textFormat.color = le.textFormat.color || 0;
                break;
            case LayoutElementType.SPRITE:
                le = new LayoutElement(descriptionObject.params.name);
                le.children = LayoutElementFactory.parseLayoutElementChildren(descriptionObject.children);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                        // tag 'instance' means that the layout should not be redeclared/resaved but initialized as an instance instead
                        if (!descriptionObject.customParams.hasOwnProperty('tag') || (descriptionObject.customParams.hasOwnProperty('tag') && descriptionObject.customParams.tag != 'instance')) {
                            const existingLayout = assets_AssetsManager.layouts.get(le.customClass);
                            if (existingLayout) {
                                assets_AssetsManager.layouts.delete(le.customClass);
                                assets_AssetsManager.layouts.set(le.customClass + '-' + existingLayout.name, existingLayout);
                                assets_AssetsManager.layouts.set(le.customClass + '-' + le.name, le);
                            }
                            else {
                                assets_AssetsManager.layouts.set(le.customClass, le);
                            }
                        }
                    }
                }
                break;
            case LayoutElementType.QUAD:
                let fillColor = 0xFFFFFF;
                if (descriptionObject.params.hasOwnProperty('color')) {
                    fillColor = descriptionObject.params.color;
                }
                le = new LayoutElementQuad(descriptionObject.params.name, fillColor);
                if (descriptionObject.hasOwnProperty('constructorParams')) {
                    for (const param of descriptionObject.constructorParams) {
                        switch (param.name) {
                            case 'width':
                                const scaleX = descriptionObject.params.scaleX ? descriptionObject.params.scaleX : 1;
                                const pivotX = descriptionObject.params.pivotX ? descriptionObject.params.pivotX : 0;
                                descriptionObject.params.width = Math.round(param.value) * scaleX;
                                descriptionObject.params.pivotX = pivotX * scaleX;
                                descriptionObject.params.scaleX = 1;
                                break;
                            case 'height':
                                const scaleY = descriptionObject.params.scaleY ? descriptionObject.params.scaleY : 1;
                                const pivotY = descriptionObject.params.pivotY ? descriptionObject.params.pivotY : 0;
                                descriptionObject.params.height = Math.round(param.value) * scaleY;
                                descriptionObject.params.pivotY = pivotY * scaleY;
                                descriptionObject.params.scaleY = 1;
                                break;
                        }
                    }
                }
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                break;
            case LayoutElementType.MOVIE_CLIP:
                const fps = descriptionObject.params.fps ? descriptionObject.params.fps : 30;
                let loop = true;
                if (descriptionObject.params.hasOwnProperty('loop')) {
                    loop = descriptionObject.params.loop;
                }
                le = new LayoutElementAnimation(descriptionObject.params.name, LayoutElementFactory.getConstructorParamValue(descriptionObject, 'textures'), fps, loop);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                break;
            default:
                throw new Error('Unknown LayoutElement type: ' + descriptionObject.cls);
        }
        le.x = descriptionObject.params.x ? descriptionObject.params.x : 0;
        le.y = descriptionObject.params.y ? descriptionObject.params.y : 0;
        le.width = descriptionObject.params.width ? descriptionObject.params.width : 0;
        le.height = descriptionObject.params.height ? descriptionObject.params.height : 0;
        le.scaleX = descriptionObject.params.scaleX ? descriptionObject.params.scaleX : 1;
        le.scaleY = descriptionObject.params.scaleY ? descriptionObject.params.scaleY : 1;
        le.pivotX = descriptionObject.params.pivotX ? descriptionObject.params.pivotX : 0;
        le.pivotY = descriptionObject.params.pivotY ? descriptionObject.params.pivotY : 0;
        le.rotation = descriptionObject.params.rotation ? descriptionObject.params.rotation : 0;
        le.alpha = (_a = descriptionObject.params.alpha) !== null && _a !== void 0 ? _a : 1;
        le.color = (_b = descriptionObject.params.color) !== null && _b !== void 0 ? _b : 0xFFFFFF;
        if (descriptionObject.hasOwnProperty('customParams')) {
            if (descriptionObject.customParams.hasOwnProperty('forEditor')) {
                if (descriptionObject.customParams.forEditor == true) {
                    le.render = false;
                }
            }
        }
        if (descriptionObject.hasOwnProperty('tweenData')) {
            if ('hitArea' in descriptionObject.tweenData && descriptionObject.tweenData.hitArea instanceof Array) {
                le.hitArea = descriptionObject.tweenData.hitArea;
            }
            if (descriptionObject.tweenData.hasOwnProperty('effects') && descriptionObject.tweenData.effects instanceof Array) {
                descriptionObject.tweenData.effects.map((effectData) => {
                    const effect = EffectFactory.create(effectData);
                    if (effect) {
                        le.effects.push(effect);
                    }
                });
            }
        }
        if (descriptionObject.params.hasOwnProperty('mask')) {
            le.mask = LayoutElementFactory.create(descriptionObject.params.mask);
            // in Starling mask position is relative to masked object
            le.mask.x += le.x;
            le.mask.y += le.y;
        }
        const layouts = (_c = descriptionObject === null || descriptionObject === void 0 ? void 0 : descriptionObject.tweenData) === null || _c === void 0 ? void 0 : _c.layouts;
        if (layouts) {
            for (const orientation of layouts) {
                if (!le.children.has(orientation)) {
                    utils_Logger.warning(`Cannot find layout element for defined screen orientation "${orientation}" on element "${le.name}"!`);
                }
                else {
                    le.layouts.set(orientation, le.children.get(orientation));
                }
            }
        }
        return le;
    }
    static parseLayoutDescription(descriptionFile) {
        return LayoutElementFactory.create(descriptionFile.layout);
    }
    static getConstructorParamValue(descriptionObject, parameterName) {
        if (descriptionObject.hasOwnProperty('constructorParams')) {
            for (const param of descriptionObject.constructorParams) {
                if (param.name == parameterName) {
                    return param.value;
                }
            }
        }
    }
    static parseLayoutElementChildren(childrenDescription) {
        const children = new Map();
        for (const layoutElementDescription of childrenDescription) {
            try {
                const le = LayoutElementFactory.create(layoutElementDescription);
                if (le) {
                    if (children.has(le.name)) {
                        utils_Logger.warning('LayoutElement ' + le.name + ' already exists! Please use unique identifiers within a single parent!');
                    }
                    else {
                        children.set(le.name, le);
                    }
                }
            }
            catch (e) {
                utils_Logger.error('LayoutElementFactory: ' + e.toString());
            }
        }
        return children;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/load/AssetType.ts
var AssetType;
(function (AssetType) {
    AssetType["TEXTURE"] = "texture";
    AssetType["LAYOUT"] = "layout";
    AssetType["VIDEO"] = "video";
    AssetType["SPINE"] = "spine";
    AssetType["XML"] = "xml";
    AssetType["WEB_FONT"] = "webfont";
    AssetType["BITMAP_FONT"] = "bitmapfont";
})(AssetType || (AssetType = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/load/AssetsConfigLoader.ts








class AssetsConfigLoader extends (eventemitter3_default()) {
    constructor(configFileUrl, renderer = null, autostart = false) {
        super();
        this.childConfigsBeingLoaded = 0;
        this.configOnly = false;
        this._itemsToLoad = 0;
        this._itemsLoaded = 0;
        this._pixiLoaderProgress = 0;
        this.childLoaders = [];
        this.configFileUrl = configFileUrl;
        this.baseUrl = configFileUrl.substring(0, configFileUrl.lastIndexOf('/') + 1);
        this.bundle = {};
        // Adding a renderer here allows us to preload textures into GPU memory after they load
        this.renderer = renderer;
        Assets.add(configFileUrl, configFileUrl);
        if (autostart) {
            this.load();
        }
    }
    // PUBLIC API
    load(configOnly = false) {
        this.configOnly = configOnly;
        Assets.load(this.configFileUrl)
            .then((configFile) => {
            this.onConfigFileLoaded(configFile);
        })
            .catch((reason) => {
            this.onError(reason);
        });
    }
    loadAssets() {
        Assets.addBundle(this.configFileUrl, this.bundle);
        Assets.loadBundle(this.configFileUrl, (progress) => {
            this._pixiLoaderProgress = progress * 100;
            utils_Logger.debug(`Loaded ${this.getSharedProgress()}%`);
            this.emit(AssetsConfigLoader.EVENT_LOADING_PROGRESS, this.getSharedProgress());
        })
            .then((resources) => {
            this.onAllAssetsLoaded(resources);
        })
            .catch((reason) => {
            this.onError(reason);
        });
    }
    addAsset(id, type, url) {
        this.bundle[AssetsConfigLoader.assetPrefix(type) + id] = url;
    }
    static assetPrefix(type) {
        return `${type}-`;
    }
    // public addChildLoader(l: AssetsConfigLoader): void {
    //     l.assetsLoader = this.assetsLoader;
    //     this.childLoaders.push(l);
    // }
    //
    // PRIVATE API
    onConfigFileLoaded(configObject) {
        utils_Logger.debug(`Assets config file: ${this.configFileUrl} loaded.`);
        if (configObject.textures) {
            for (const textureObject of configObject.textures) {
                this.addAsset(textureObject.name, AssetType.TEXTURE, this.baseUrl + textureObject.url);
            }
        }
        if (configObject.spine) {
            for (const spineObject of configObject.spine) {
                this.addAsset(spineObject.name, AssetType.SPINE, this.baseUrl + spineObject.url + '.json');
            }
        }
        if (configObject.videos) {
            for (const videoObject of configObject.videos) {
                this.addAsset(videoObject.name, AssetType.VIDEO, this.baseUrl + videoObject.url);
            }
        }
        if (configObject.xmls) {
            for (const xmlObject of configObject.xmls) {
                this.addAsset(xmlObject.name, AssetType.XML, this.baseUrl + xmlObject.url);
            }
        }
        if (configObject.layouts) {
            for (const layoutObject of configObject.layouts) {
                this.addAsset(layoutObject.name, AssetType.LAYOUT, this.baseUrl + layoutObject.url);
            }
        }
        if (configObject.scripts) {
            for (const scriptUrl of configObject.scripts) {
                this._itemsToLoad++;
                this.loadScript(this.baseUrl + scriptUrl, () => {
                    this.onScriptLoaded();
                });
            }
        }
        if (configObject.sounds) {
            for (const soundObject of configObject.sounds) {
                const name = soundObject.name;
                if (assets_AssetsManager.sounds.get(name)) {
                    utils_Logger.warning(`Trying to load sound with name that already exists: ${name}`);
                    continue;
                }
                this._itemsToLoad++;
                for (let i = 0; i < soundObject.url.length; i++) {
                    soundObject.url[i] = this.baseUrl + soundObject.url[i];
                }
                const sound = new howler.Howl({
                    src: soundObject.url,
                });
                sound.once('load', () => {
                    assets_AssetsManager.sounds.set(name, sound);
                    if (soundObject.channel) {
                        sound_SoundManager.addSoundToChannel(name, sound, soundObject.channel);
                    }
                    else {
                        sound_SoundManager.addSoundToChannel(name, sound);
                    }
                    this._itemsLoaded++;
                    this.emit(AssetsConfigLoader.EVENT_LOADING_PROGRESS, this.getSharedProgress());
                });
            }
        }
        if (configObject.fonts) {
            for (const fontObject of configObject.fonts) {
                if (!fontObject.hasOwnProperty('type')) {
                    fontObject.type = 'web';
                }
                switch (fontObject.type) {
                    case 'bitmap':
                        this.addAsset(fontObject.name, AssetType.BITMAP_FONT, this.baseUrl + fontObject.url);
                        break;
                    case 'web':
                        this.addAsset(fontObject.name, AssetType.WEB_FONT, this.baseUrl + fontObject.url);
                        break;
                    default:
                        utils_Logger.warning(`Unknown font type: ${fontObject.type}`);
                        break;
                }
            }
        }
        let loadingChildConfigs = false;
        for (const cl of this.childLoaders) {
            loadingChildConfigs = true;
            this.childConfigsBeingLoaded++;
            cl.once(AssetsConfigLoader.EVENT_CONFIG_LOADED, () => {
                this.onChildConfigLoaded();
            });
            cl.load(true);
        }
        if (!loadingChildConfigs) {
            this.emit(AssetsConfigLoader.EVENT_CONFIG_LOADED);
            if (!this.configOnly) {
                this.loadAssets();
            }
        }
    }
    loadScript(url, callback) {
        const head = document.getElementsByTagName('head')[0];
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url;
        // Then bind the event to the callback function.
        script.onload = callback;
        // Fire the loading
        head.appendChild(script);
    }
    onScriptLoaded() {
        this._itemsLoaded++;
        utils_Logger.debug('Loaded script');
        this.emit(AssetsConfigLoader.EVENT_LOADING_PROGRESS, this.getSharedProgress());
    }
    onChildConfigLoaded() {
        this.childConfigsBeingLoaded--;
        if (!this.childConfigsBeingLoaded) {
            this.emit(AssetsConfigLoader.EVENT_CONFIG_LOADED);
            if (!this.configOnly) {
                this.loadAssets();
            }
        }
    }
    getSharedProgress() {
        return this._itemsToLoad > 0 ? this._pixiLoaderProgress * 0.9 + (this._itemsLoaded / this._itemsToLoad) * 10 : this._pixiLoaderProgress;
    }
    onAllAssetsLoaded(resources) {
        if (this.getSharedProgress() >= 100) {
            let preloadingTexturesIntoGPUMemory = false;
            let emptyResources = true;
            for (const resourceName in resources) {
                const resource = resources[resourceName];
                const assetType = resourceName.substring(0, resourceName.indexOf('-'));
                const assetName = resourceName.substring(resourceName.indexOf('-') + 1);
                emptyResources = false;
                switch (assetType) {
                    case AssetType.LAYOUT:
                        assets_AssetsManager.layouts.set(assetName, LayoutElementFactory.parseLayoutDescription(resource));
                        // Logger.debug("Loaded layout: " + assetName);
                        break;
                    case AssetType.VIDEO:
                        assets_AssetsManager.videos.set(assetName, resource);
                        break;
                    case AssetType.TEXTURE:
                        if (resource instanceof Spritesheet) {
                            preloadingTexturesIntoGPUMemory = this.checkSpriteSheet(resource);
                            resource.linkedSheets.forEach((spritesheet) => {
                                preloadingTexturesIntoGPUMemory = this.checkSpriteSheet(spritesheet);
                            });
                        }
                        else {
                            assets_AssetsManager.textures.set(assetName, resource);
                            utils_Logger.debug('Loaded texture: ' + assetName);
                            if (this.renderer) {
                                preloadingTexturesIntoGPUMemory = true;
                                //this.renderer.prepare.add(resource);
                            }
                        }
                        break;
                    case AssetType.SPINE:
                        assets_AssetsManager.spine.set(assetName, resource.spineData);
                        break;
                    case AssetType.XML:
                        const parser = new DOMParser();
                        assets_AssetsManager.xmls.set(assetName, parser.parseFromString(resource, 'text/xml'));
                        break;
                    case AssetType.WEB_FONT:
                        const fontFace = resource;
                        assets_AssetsManager.webFonts.set(assetName, fontFace);
                        break;
                    case AssetType.BITMAP_FONT:
                        const bitmapFont = resource;
                        assets_AssetsManager.bitmapFonts.set(bitmapFont.font, bitmapFont);
                        // Logger.debug(`Loaded bitmap font: ${bitmapFont.font}`);
                        break;
                }
            }
            if (preloadingTexturesIntoGPUMemory && this.renderer.rendererLogId != 'Canvas') {
                if (this.renderer) {
                    this.renderer.prepare.upload()
                        .then(() => {
                        // Assets.reset();
                        this.emit(AssetsConfigLoader.EVENT_LOADING_COMPLETE);
                    });
                    return;
                }
            }
            //Assets.reset();
            if (!emptyResources)
                Assets.reset();
            this.emit(AssetsConfigLoader.EVENT_LOADING_COMPLETE);
        }
        else {
            utils_Logger.debug('Waiting for sounds and script assets to load.');
            setTimeout(() => {
                this.onAllAssetsLoaded(resources);
            }, 1000);
        }
    }
    checkSpriteSheet(spritesheet) {
        let preloadingTexturesIntoGPUMemory = false;
        for (const assetName in spritesheet.textures) {
            assets_AssetsManager.textures.set(assetName, spritesheet.textures[assetName]);
        }
        return preloadingTexturesIntoGPUMemory;
    }
    onError(reason) {
        console.log(reason);
    }
}
AssetsConfigLoader.EVENT_CONFIG_LOADED = 'onConfigLoaded';
AssetsConfigLoader.EVENT_LOADING_PROGRESS = 'onLoadingProgress';
AssetsConfigLoader.EVENT_LOADING_COMPLETE = 'onLoadingComplete';
/* harmony default export */ const load_AssetsConfigLoader = (AssetsConfigLoader);

;// CONCATENATED MODULE: ./src/ignition-interactive/core/utils/MobileBrowserLog.ts
class MobileBrowserLog {
    constructor() {
        this.isOpen = false;
        this.container = document.createElement('div');
        document.body.append(this.container);
        this.container.style.zIndex = '100';
        const ta = document.createElement('textarea');
        this.container.append(ta);
        ta.id = 'log';
        [this.container, ta].forEach(el => {
            el.style.position = 'absolute';
            el.style.width = '100%';
            el.style.height = '100%';
        });
        console.log = (...args) => {
            ta.value += `\n${args}`;
        };
        const btn = document.createElement('div');
        document.body.append(btn);
        btn.style.width = '50px';
        btn.style.height = '50px';
        btn.style.position = 'absolute';
        btn.style.bottom = '0';
        btn.style.right = '0';
        btn.style.backgroundColor = '#FF0000';
        btn.style.zIndex = '101';
        btn.onclick = () => {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        this.close();
    }
    open() {
        this.container.style.visibility = 'visible';
        this.isOpen = true;
    }
    close() {
        this.container.style.visibility = 'hidden';
        this.isOpen = false;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/ResizeMethod.ts
/**
 * Various Screen and Application resize methods
 * @readonly
 * @enum {string}
 */
var ResizeMethod;
(function (ResizeMethod) {
    /**
     * Application keeps its base size and will not resize automatically.
     * Screens will be displayed on top of each other in their base size and will not scale automatically.
     * Any overflowing screens will not be displayed.
     *
     * Useful for: Application where the size is preset and cannot change.
     */
    ResizeMethod[ResizeMethod["NONE"] = 0] = "NONE";
    /**
     * Application resolution will match the available area. Ignores the Application base size.
     * Application will stretch and scale-down similar to CSS object-fit:fill
     * Screens resolution also will match the available area and all screens will be displayed on top of each other. Ignores the Screens base size.
     * Pixi renderer is set to new screen resolution but the stage is not scaled.
     *
     * Useful for: Application where the window can change its size, and Pixi scene should expand its boundaries i.e. visual editor, painting app.
     */
    ResizeMethod[ResizeMethod["DEFAULT"] = 1] = "DEFAULT";
    /**
     * Application will scale to fit in the available area while keeping the aspect ratio.
     * Application will be letterboxed similar to CSS object-fit:contain.
     * Screens will keep the aspect ratio and will all be fitted in the Application available area on top of each other.
     * Pixi renderer is set to new screen resolution and the stage is scaled according to base size to new size ratio.
     *
     * Useful for: Games that do not offer responsive UI, do not have safe area graphics and only aspect ratio has to be kept.
     */
    ResizeMethod[ResizeMethod["CONTAIN"] = 2] = "CONTAIN";
    /**
     * Application resolution will match the available area. Ignores the Application base size.
     * Application will stretch and scale-down similar to CSS object-fit:fill
     * Screens resolution also will match the available area and all screens will be displayed on top of each other. Ignores the Screens base size.
     * Pixi renderer is set to new screen resolution and the stage is scaled accordingly.
     *
     * Useful for: Games that offer responsive UI or have safe area graphics.
     */
    ResizeMethod[ResizeMethod["SHOW_ALL"] = 3] = "SHOW_ALL";
    /**
     * Application resolution will match the available area. Ignores the Application base size.
     * Application will stretch and scale-down similar to CSS object-fit:fill
     * Screens resolution also will match the available area and all screens will be displayed on top of each other. Ignores the Screens base size.
     * Pixi renderer will be stretched to new screen resolution and the stage is scaled accordingly.
     *
     * Useful for: Games that are not responsive and need to fill the entire screen ie. games for cabinets.
     */
    ResizeMethod[ResizeMethod["EXACT_FIT"] = 4] = "EXACT_FIT";
})(ResizeMethod || (ResizeMethod = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/Application.ts



class Application_Application {
    constructor(config) {
        this.defaultConfig = {
            backgroundColor: 0x000000,
            baseWidth: 1920,
            baseHeight: 1080,
            autoUpdateSizeToOrientation: false,
            fps: 60,
            resizeMethod: ResizeMethod.NONE,
            debug: true
        };
        this.screens = [];
        // merge config with default values
        config = Object.assign(Object.assign({}, this.defaultConfig), config);
        this.id = config.id;
        this.container = config.container;
        this.baseWidth = config.baseWidth;
        this.baseHeight = config.baseHeight;
        this.autoUpdateSizeToOrientation = config.autoUpdateSizeToOrientation;
        this.defaultResizeMethod = config.resizeMethod;
        this.container.style.backgroundColor = Color_Color.shared.setValue(config.backgroundColor).toHex();
        this.container.style.overflow = 'hidden';
        this.container.style.position = 'absolute';
        this.container.style.top = '50%';
        this.container.style.left = '50%';
        this.container.style.transform = 'translate(-50%, -50%)';
        this.container.style.display = 'flex';
        this.container.style.flexDirection = 'column';
        this.container.style.justifyContent = 'center';
        this.container.style.alignItems = 'center';
        // Attach resize listener
        window.addEventListener('resize', () => {
            this.onWindowResize();
        });
        window.addEventListener('orientationchange', () => {
            this.onWindowResize();
        });
        this.onWindowResize();
    }
    addScreen(screen) {
        if (this.getScreen(screen.id)) {
            utils_Logger.warning(`Screen with id: ${screen.id} already exists!`);
            return;
        }
        this.screens.push(screen);
        this.container.prepend(screen.view);
        this.onWindowResize();
    }
    getScreen(id) {
        return this.screens.find((existingScreen) => {
            return existingScreen.id === id;
        });
    }
    get numScreens() {
        return this.screens.length;
    }
    resize(availableWidth, availableHeight, resizeMethod) {
        resizeMethod = resizeMethod || this.defaultResizeMethod || ResizeMethod.NONE;
        let applicationWidth;
        let applicationHeight;
        let singleScreenWidth;
        let singleScreenHeight;
        let baseWidth = this.baseWidth;
        let baseHeight = this.baseHeight;
        if (this.autoUpdateSizeToOrientation) {
            if (availableHeight > availableWidth) {
                baseWidth = Math.min(this.baseWidth, this.baseHeight);
                baseHeight = Math.max(this.baseWidth, this.baseHeight);
            }
            else {
                baseWidth = Math.max(this.baseWidth, this.baseHeight);
                baseHeight = Math.min(this.baseWidth, this.baseHeight);
            }
        }
        this.baseWidth = baseWidth;
        this.baseHeight = baseHeight;
        // console.log(baseWidth, baseHeight);
        switch (resizeMethod) {
            case ResizeMethod.DEFAULT:
            case ResizeMethod.SHOW_ALL:
            case ResizeMethod.EXACT_FIT:
                applicationWidth = availableWidth;
                applicationHeight = availableHeight;
                singleScreenWidth = availableWidth;
                singleScreenHeight = Math.round(availableHeight / this.numScreens);
                break;
            case ResizeMethod.CONTAIN:
                let scale = availableWidth / baseWidth;
                if (scale * baseHeight > availableHeight) {
                    scale = availableHeight / baseHeight;
                }
                applicationWidth = Math.round(scale * baseWidth);
                applicationHeight = Math.round(scale * baseHeight);
                singleScreenWidth = applicationWidth;
                singleScreenHeight = Math.round(applicationHeight / this.numScreens);
                break;
            case ResizeMethod.NONE:
            default:
                applicationWidth = singleScreenWidth = baseWidth;
                applicationHeight = singleScreenHeight = baseHeight;
                break;
        }
        this.container.style.width = `${applicationWidth}px`;
        this.container.style.height = `${applicationHeight}px`;
        this.screens.forEach((screen) => {
            screen.resize(singleScreenWidth, singleScreenHeight, resizeMethod, this.autoUpdateSizeToOrientation);
        });
    }
    onWindowResize() {
        this.resize(window.innerWidth, window.innerHeight, this.defaultResizeMethod);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/Screen.ts



class Screen extends (eventemitter3_default()) {
    constructor(config) {
        super();
        this.defaultConfig = {
            backgroundColor: 0x000000,
            baseWidth: 1920,
            baseHeight: 1080,
            fps: 0, // no limit
            debug: true
        };
        // merge config with default values
        config = Object.assign(Object.assign({}, this.defaultConfig), config);
        this.id = config.id;
        this.baseWidth = this._width = config.baseWidth;
        this.baseHeight = this._height = config.baseHeight;
        this.baseOrientation = this._orientation = this.calculateOrientation(this.baseWidth, this.baseHeight);
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get orientation() {
        return this._orientation;
    }
    resize(availableWidth, availableHeight, resizeMethod, autoUpdateSizeToOrientation) {
        // Logger.debug(`Screen ${this.id} resize: ${availableWidth}, ${availableHeight}`);
        resizeMethod = resizeMethod || ResizeMethod.NONE;
        const oldWidth = this._width;
        const oldHeight = this._height;
        const oldOrientation = this.orientation;
        this._orientation = this.calculateOrientation(availableWidth, availableHeight);
        // each screen type should implement its own resizing logic
        this.doResize(availableWidth, availableHeight, resizeMethod, autoUpdateSizeToOrientation);
        if (oldWidth != this._width || oldHeight != this.height) {
            if (oldOrientation != this.orientation) {
                this.emit('change-orientation', this.orientation);
            }
            this.emit('resize', this.width, this.height);
        }
    }
    calculateOrientation(width, height) {
        return height > width ? ScreenOrientation.VERTICAL : ScreenOrientation.HORIZONTAL;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/ScreenPixi.ts



class ScreenPixi extends Screen {
    constructor(config) {
        super(config);
        // Create PIXI application
        this.pixi = new Application({
            backgroundColor: config.backgroundColor,
            width: this.baseWidth,
            height: this.baseHeight,
            autoDensity: true,
            resolution: window.devicePixelRatio || 1,
            hello: true,
            backgroundAlpha: config.backgroundAlpha,
        });
        console.log(`window.devicePixelRatio: ${window.devicePixelRatio}`);
        Ticker.shared.maxFPS = config.fps;
        this.view.id = this.id;
    }
    get view() {
        return this.pixi.view;
    }
    get stage() {
        return this.pixi.stage;
    }
    doResize(availableWidth, availableHeight, resizeMethod, autoUpdateSizeToOrientation) {
        const renderer = this.pixi.renderer;
        let baseWidth = this.baseWidth;
        let baseHeight = this.baseHeight;
        let screenWidth;
        let screenHeight;
        let rendererWidth;
        let rendererHeight;
        let stageScaleX = 1;
        let stageScaleY = 1;
        if (autoUpdateSizeToOrientation) {
            if (this._orientation == this.baseOrientation) {
                baseWidth = this.baseWidth;
                baseHeight = this.baseHeight;
            }
            else {
                baseWidth = this.baseHeight;
                baseHeight = this.baseWidth;
            }
        }
        let scale = availableWidth / baseWidth;
        if (scale * baseHeight > availableHeight) {
            scale = availableHeight / baseHeight;
        }
        // Logger.debug(`Base size: ${baseWidth}x${baseHeight}`);
        switch (resizeMethod) {
            case ResizeMethod.DEFAULT:
                this._width = screenWidth = availableWidth;
                this._height = screenHeight = availableHeight;
                rendererWidth = availableWidth;
                rendererHeight = availableHeight;
                break;
            case ResizeMethod.CONTAIN:
                this._width = baseWidth;
                this._height = baseHeight;
                screenWidth = rendererWidth = Math.ceil(scale * baseWidth);
                screenHeight = rendererHeight = Math.ceil(scale * baseHeight);
                stageScaleX = stageScaleY = scale;
                break;
            case ResizeMethod.SHOW_ALL:
                screenWidth = rendererWidth = availableWidth;
                screenHeight = rendererHeight = availableHeight;
                stageScaleX = stageScaleY = scale;
                this._width = rendererWidth / scale;
                this._height = rendererHeight / scale;
                break;
            case ResizeMethod.EXACT_FIT:
                this._width = baseWidth;
                this._height = baseHeight;
                screenWidth = rendererWidth = availableWidth;
                screenHeight = rendererHeight = availableHeight;
                stageScaleX = availableWidth / baseWidth;
                stageScaleY = availableHeight / baseHeight;
                break;
            case ResizeMethod.NONE:
            default:
                this._width = screenWidth = rendererWidth = baseWidth;
                this._height = screenHeight = rendererHeight = baseHeight;
                break;
        }
        this.view.style.width = `${screenWidth}px`;
        this.view.style.height = `${screenHeight}px`;
        renderer.resize(rendererWidth, rendererHeight);
        this.stage.scale.set(stageScaleX, stageScaleY);
        // console.log(`Screen resized: ${this._width}x${this._height} Renderer resized: ${rendererWidth}x${rendererHeight}`);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/BrowserApplication.ts


class BrowserApplication extends Application_Application {
    constructor(container, config) {
        var _a;
        super(config);
        const mainScreenConfig = {
            id: 'main',
            backgroundColor: 0x000000,
            baseWidth: config.baseWidth,
            baseHeight: config.baseHeight,
            fps: config.fps,
            debug: config.debug,
            backgroundAlpha: (_a = config.backgroundAlpha) !== null && _a !== void 0 ? _a : 1
        };
        // initialize one and only application screen (browser application)
        this.mainScreen = new ScreenPixi(mainScreenConfig);
        this.addScreen(this.mainScreen);
        // this.mainScreen.on('resize', this.onScreenResize, this);
        // this.onScreenResize();
    }
    get width() {
        return this.mainScreen.width;
    }
    get height() {
        return this.mainScreen.height;
    }
    get stage() {
        if (this.mainScreen) {
            return this.mainScreen.stage;
        }
        else {
            return null;
        }
    }
    get pixi() {
        return this.mainScreen.pixi;
    }
    get orientation() {
        return this.mainScreen.orientation;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/effect/SwapViewsEffectFadeToBlack.ts


class SwapViewsEffectFadeToBlack {
    constructor(maskRect, fadeOutTime = 0.5, fadeInTime = 0.5) {
        this.fade = new Graphics_Graphics();
        this.fade.clear();
        this.fade.lineStyle(0);
        this.fade.beginFill(0x000000);
        this.fade.drawRect(maskRect.x, maskRect.y, maskRect.width, maskRect.height);
        this.fade.endFill();
        this.fadeOutTime = fadeOutTime;
        this.fadeInTime = fadeInTime;
    }
    // PUBLIC API
    apply(viewOut, viewIn, container, onComplete) {
        const outViewIndex = container.getChildIndex(viewOut);
        container.addChildAt(this.fade, outViewIndex + 1);
        this.fade.alpha = 0;
        ignitionTween.Tweener.addTween(this.fade, { alpha: 1, time: this.fadeOutTime, transition: 'easeOutQuad', onComplete: () => {
                container.removeChild(viewOut);
                container.addChildAt(viewIn, outViewIndex);
            } });
        ignitionTween.Tweener.addTween(this.fade, { alpha: 0, time: this.fadeInTime, transition: 'easeInQuad', delay: this.fadeOutTime, onComplete: () => {
                container.removeChild(this.fade);
                if (onComplete) {
                    onComplete();
                }
            } });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/SlotMachineState.ts
var SlotMachineState;
(function (SlotMachineState) {
    SlotMachineState["NOT_INITIALIZED"] = "NotInitialized";
    SlotMachineState["IDLE"] = "Idle";
    SlotMachineState["SPINNING"] = "Spinning";
    SlotMachineState["SPIN_END"] = "SpinEnd";
    SlotMachineState["SPIN_RESULT_MULTI_WIN"] = "SpinResultMultiWin";
    SlotMachineState["SPIN_RESULT_SCATTER"] = "SpinResultScatter";
    SlotMachineState["SPIN_RESULT_CASCADE"] = "SpinResultCascade";
    SlotMachineState["SPIN_RESULT_BONUS_GAME"] = "SpinResultBonusGame";
    SlotMachineState["SPIN_RESULT_FREE_SPINS"] = "SpinResultFreeSpins";
    SlotMachineState["BONUS_GAME"] = "BonusGame";
    SlotMachineState["FREE_SPINS_ROUND_START"] = "FreeSpinsRoundStart";
    SlotMachineState["FREE_SPINS"] = "FreeSpins";
    SlotMachineState["FREE_SPINS_ROUND_END"] = "FreeSpinsRoundEnd";
    SlotMachineState["BIG_WIN"] = "BigWin";
    SlotMachineState["BIG_WIN_FREE_SPIN"] = "BigWinFreeSpin";
    SlotMachineState["COMMUNICATION_ERROR"] = "CommunicationError";
})(SlotMachineState || (SlotMachineState = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/event/SlotMachineEvent.ts
var SlotMachineEvent;
(function (SlotMachineEvent) {
    SlotMachineEvent["STATE_CHANGED"] = "onSlotMachineStateChanged";
    SlotMachineEvent["BET_VALUE_CHANGED"] = "onSlotMachineBetValueChanged";
    SlotMachineEvent["GAME_SPEED_LEVEL_CHANGED"] = "onSlotMachineGameSpeedLevelChanged";
    SlotMachineEvent["NEW_LINE_SHOW"] = "onNewLineShow";
})(SlotMachineEvent || (SlotMachineEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/event/AutoplayEvent.ts
var AutoplayEvent;
(function (AutoplayEvent) {
    AutoplayEvent["ENABLED"] = "onAutoplayEnabled";
    AutoplayEvent["DISABLED"] = "onAutoplayDisabled";
    AutoplayEvent["SPINS_LEFT_CHANGED"] = "onAutoplaySpinsLeftChanged";
})(AutoplayEvent || (AutoplayEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/Autoplay.ts



class Autoplay extends (eventemitter3_default()) {
    constructor() {
        super();
        this._spinsLeft = -1;
        this._enabled = false;
        this._settings = null;
        this._startBalance = 0;
    }
    // PUBLIC API
    get spinsLeft() {
        return this._spinsLeft;
    }
    set spinsLeft(value) {
        if (this._spinsLeft == value) {
            return;
        }
        this._spinsLeft = value;
        this.emit(AutoplayEvent.SPINS_LEFT_CHANGED);
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        if (this._enabled == value) {
            return;
        }
        this._enabled = value;
        if (this._enabled) {
            this.emit(AutoplayEvent.ENABLED);
        }
        else {
            this.emit(AutoplayEvent.DISABLED);
        }
    }
    get settings() {
        return this._settings;
    }
    set settings(value) {
        this.spinsLeft = value.spinsLeft;
        this._settings = value;
    }
    canAutoSpin(latestRound, balance) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // Check if there are spins left
        if (this.spinsLeft === 0) {
            return false;
        }
        // Check if there are settings
        if (!this._settings)
            return true;
        if ((_a = this._settings) === null || _a === void 0 ? void 0 : _a.onAnyWin) {
            if ((latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue) > 0) {
                utils_Logger.debug('OnAnyWin STOP ' + (latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue));
                return false;
            }
        }
        if ((_b = this.settings) === null || _b === void 0 ? void 0 : _b.onBonusGameWon) {
            if (latestRound.spins[latestRound.spins.length - 1].freespins) {
                utils_Logger.debug('OnBonusGameWon ' + latestRound);
                return false;
            }
        }
        if ((_c = this._settings) === null || _c === void 0 ? void 0 : _c.onSingleWinExceed) {
            if (this._settings.onSingleWinExceed < (latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue)) {
                utils_Logger.debug('OnSingleWinExceed STOP ' + this._settings.onSingleWinExceed + ' ' + (latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue));
                return false;
            }
        }
        if ((_d = this._settings) === null || _d === void 0 ? void 0 : _d.onCashBalanceIncreaseBy) {
            if (balance > this._startBalance + ((_e = this._settings) === null || _e === void 0 ? void 0 : _e.onCashBalanceIncreaseBy)) {
                utils_Logger.debug('OnCashBalanceIncreaseBy STOP ' + balance + ' ' + (this._startBalance + ((_f = this._settings) === null || _f === void 0 ? void 0 : _f.onCashBalanceIncreaseBy)));
                return false;
            }
        }
        if ((_g = this._settings) === null || _g === void 0 ? void 0 : _g.onCashBalanceDecreaseBy) {
            if (balance < this._startBalance - ((_h = this._settings) === null || _h === void 0 ? void 0 : _h.onCashBalanceDecreaseBy)) {
                utils_Logger.debug('OnCashBalanceDecreaseBy STOP ' + balance + ' ' + (this._startBalance - ((_j = this._settings) === null || _j === void 0 ? void 0 : _j.onCashBalanceDecreaseBy)));
                return false;
            }
        }
        return true;
    }
    set startBalance(value) {
        this._startBalance = value;
        utils_Logger.debug('start balance ' + this._startBalance);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/SlotMachine.ts




class SlotMachine extends (eventemitter3_default()) {
    constructor(description, options = null) {
        super();
        this.defaultDescription = {
            lines: [],
            wildcards: [],
            bigWinMultiplierLevels: []
        };
        this.defaultOptions = {
            gameSpeedLevels: [
                {
                    spin: {
                        tilt: 0.3,
                        time: 0.4,
                        delayPerReel: 0.1
                    },
                    stop: {
                        time: 0.3,
                        delayPerReel: 0.12,
                        delay: 1,
                    }
                },
            ]
        };
        this._currentState = SlotMachineState.NOT_INITIALIZED;
        this._currentGameSpeedLevel = 0;
        this._betQuantity = 1;
        // TODO: Think about moving these to round object
        // RESETTABLE STATUS VARS
        this.showFreeSpinsPopup = true;
        this.reelsStarted = false;
        this.stopRequested = false;
        this.spinTimeLapsed = false;
        this.bigWinShown = false;
        this.roundResult = null;
        this.previousRoundResult = null;
        // merge config with default values
        this.description = Object.assign(Object.assign({}, this.defaultDescription), description);
        this.options = Object.assign(Object.assign({}, this.defaultOptions), options);
        this._currentBetValue = this.description.betLimits[0];
        this.autoplay = new Autoplay();
    }
    // PUBLIC API
    set betQuantity(value) {
        if (this._betQuantity == value || value > 10 || value <= 0) {
            return;
        }
        this._betQuantity = value;
        this.emit(SlotMachineEvent.BET_VALUE_CHANGED);
    }
    get betQuantity() {
        return this._betQuantity;
    }
    get currentState() {
        return this._currentState;
    }
    set currentState(value) {
        if (this._currentState == value) {
            return;
        }
        const previousState = this._currentState;
        this._currentState = value;
        this.emit(SlotMachineEvent.STATE_CHANGED, this._currentState, previousState);
    }
    get numLines() {
        return this.description.lines.length;
    }
    get combinations() {
        return this.description.combinations;
    }
    get currentBetValue() {
        return this._currentBetValue;
    }
    set currentBetValue(value) {
        if (this._currentBetValue == value) {
            return;
        }
        this._currentBetValue = value;
        this.emit(SlotMachineEvent.BET_VALUE_CHANGED, this._currentBetValue);
    }
    get totalBet() {
        return this._currentBetValue * ((this.numLines == 0) ? this.combinations : this.numLines) * this.betQuantity;
    }
    get currentGameSpeedLevel() {
        return this._currentGameSpeedLevel;
    }
    set currentGameSpeedLevel(value) {
        if (this._currentGameSpeedLevel == value) {
            return;
        }
        this._currentGameSpeedLevel = value;
        this.emit(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this._currentGameSpeedLevel);
    }
    get currentSpinResult() {
        if (this.roundResult) {
            return this.roundResult.spins[this.roundResult.spinIndex];
        }
        else {
            return null;
        }
    }
    get nextSpinResult() {
        if (this.roundResult && this.roundResult.spins.length > this.roundResult.spinIndex + 1) {
            return this.roundResult.spins[this.roundResult.spinIndex + 1];
        }
        else {
            return null;
        }
    }
    get previousSpinResult() {
        if (this.roundResult) {
            return this.roundResult.spins[this.roundResult.spinIndex - 1];
        }
        else {
            return null;
        }
    }
    multiWinPattern(spinResult) {
        // create empty pattern
        const pattern = [];
        for (let i = 0; i < spinResult.result.length; i++) {
            pattern.push([]);
            for (let j = 0; j < spinResult.result[i].length; j++) {
                pattern[i].push(0);
            }
        }
        // iterate over line wins and mark winning symbols
        if (spinResult.win.lines) {
            for (const win of spinResult.win.lines) {
                for (let i = 0; i < pattern.length; i++) {
                    for (let j = 0; j < pattern[i].length; j++) {
                        pattern[i][j] = pattern[i][j] || win.pattern[i][j];
                    }
                }
            }
        }
        if (spinResult.win.combinations) {
            // iterate over combination wins and mark winning symbols
            for (const win of spinResult.win.combinations) {
                for (let i = 0; i < pattern.length; i++) {
                    for (let j = 0; j < pattern[i].length; j++) {
                        pattern[i][j] = pattern[i][j] || win.pattern[i][j];
                    }
                }
            }
        }
        if (spinResult.win.scatters) {
            // iterate over scatter wins and mark winning symbols
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    pattern[i][j] = pattern[i][j] || spinResult.win.scatters.pattern[i][j];
                }
            }
        }
        if (spinResult.win.freespins) {
            // iterate over scatter wins and mark winning symbols
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    pattern[i][j] = pattern[i][j] || spinResult.win.freespins.pattern[i][j];
                }
            }
        }
        return pattern;
    }
    lineWinValue(spinResult) {
        return spinResult.win.lines.reduce((totalWin, win) => {
            return totalWin + win.winValue;
        }, 0);
    }
    bigWinLevel(roundResult) {
        var _a;
        const winMultiplierRatio = (_a = roundResult.actualSpinWinValue) !== null && _a !== void 0 ? _a : roundResult.totalWinValue / roundResult.totalBet;
        let level = -1;
        for (let i = 0; i < this.description.bigWinMultiplierLevels.length; i++) {
            if (winMultiplierRatio >= this.description.bigWinMultiplierLevels[i]) {
                level = i;
            }
        }
        return level;
    }
    findRule(symbolId, symbolCount) {
        return this.description.rules.find((rd) => {
            if (rd.pattern.symbolId == symbolId && rd.pattern.symbolCount.includes(symbolCount)) {
                return true;
            }
            return false;
        });
    }
    findDoubledSymbol(symbolsToSort, indexMap) {
        return symbolsToSort.sort((a, b) => {
            const indexA = indexMap.get(a.id);
            const indexB = indexMap.get(b.id);
            if (indexA === undefined || indexB === undefined) {
                return 0;
            }
            return indexA - indexB;
        });
    }
    set currentLineWin(value) {
        this._currentLineWin = value;
        this.emit(SlotMachineEvent.NEW_LINE_SHOW, this.currentLineWin);
    }
    get currentLineWin() {
        return this._currentLineWin;
    }
    //Dummy round result is used for lost connection error when user has no previous data (ERROR -> stop on previous round result)
    getDummyRoundResult(result = null) {
        // create empty pattern
        const pattern = [];
        for (let i = 0; i < this.description.reels.regular.reels.length; i++) {
            pattern.push([]);
            for (let j = 0; j < this.description.reels.regular.reels[0].numRows; j++) {
                pattern[i].push(this.description.symbols[Math.floor(Math.random() * this.description.symbols.length)]);
            }
        }
        return {
            id: 0,
            betLines: 0,
            lineBetValue: 0,
            spinIndex: 0,
            spins: [
                {
                    result: result ? result.spins[result.spins.length - 1].result : pattern,
                    winValue: 0,
                    totalWinMultiplier: 1,
                    currentTotalWinValue: 0
                }
            ],
            totalBet: 0,
            totalWinValue: 0,
            nextType: result ? result.nextType : null,
            complete: false
        };
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/event/SlotGameEvent.ts
var SlotGameEvent;
(function (SlotGameEvent) {
    SlotGameEvent["SPIN_START"] = "onSlotGameSpinStart";
    SlotGameEvent["REELS_STARTED"] = "onSlotGameReelsStarted";
    SlotGameEvent["SPIN_TIME_LAPSED"] = "onSlotGameSpinTimeLapsed";
    SlotGameEvent["ROUND_RESULT_OBTAINED"] = "onSlotGameRoundresultObtained";
    SlotGameEvent["STOP_REQUESTED"] = "onSlotGameStopRequested";
    SlotGameEvent["SPIN_STOP"] = "onSlotGameSpinStop";
    SlotGameEvent["REELS_STOPPED"] = "onSlotGameReelsStopped";
    SlotGameEvent["MULTI_WIN_SHOWN"] = "onSlotGameMultiWinShown";
    SlotGameEvent["WINLINE_WIN_SHOWN"] = "onSlotGameWinlineWinShown";
    SlotGameEvent["SCATTER_WIN_SHOWN"] = "onSlotGameScatterWinShown";
    SlotGameEvent["CASCADE_WIN_SHOWN"] = "onSlotGameCascadeWinShown";
    SlotGameEvent["BONUS_GAME_WIN_SHOWN"] = "onSlotGameBonusGameWinShown";
    SlotGameEvent["BONUS_GAME_STARTED"] = "onSlotGameBonusGamePlayStarted";
    SlotGameEvent["BONUS_GAME_COMPLETE"] = "onSlotGameBonusGamePlayComplete";
    SlotGameEvent["FREE_SPIN_WIN_SHOWN"] = "onSlotGameFreeSpinWinShown";
    SlotGameEvent["FREE_SPIN_ROUND_STARTED"] = "onSlotGameFreeSpinRoundStarted";
    SlotGameEvent["FREE_SPIN_START"] = "onSlotGameFreeSpinStart";
    SlotGameEvent["FREE_SPIN_ROUND_COMPLETE"] = "onSlotGameFreeSpinRoundComplete";
    SlotGameEvent["FREE_SPIN_RESULT_READY"] = "onFreeSpinResultReady";
    SlotGameEvent["BIG_WIN_SHOWN"] = "onSlotGameBigWinShown";
    SlotGameEvent["SPIN_RESULT_READY"] = "onSlotGameSpinResultReady";
    SlotGameEvent["ROUND_COMPLETE"] = "onSlotGameRoundComplete";
})(SlotGameEvent || (SlotGameEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/event/WalletEvent.ts
var WalletEvent;
(function (WalletEvent) {
    WalletEvent["BALANCE_CHANGED"] = "onWalletBalanceChanged";
    WalletEvent["NOT_ENOUGH_BALANCE"] = "onWalletNotEnoughBalance";
    WalletEvent["COIN_VALUE_CHANGED"] = "onCoinValueChanged";
})(WalletEvent || (WalletEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/Wallet.ts


class Wallet extends (eventemitter3_default()) {
    constructor(denomination, currency, coinValuesLimits) {
        super();
        this._balance = 0;
        if (coinValuesLimits) {
            this.coinValueLimits = coinValuesLimits;
            this._coinValue = this.coinValueLimits[0];
        }
        Wallet._denomination = denomination;
        Wallet.currency = currency;
    }
    // PUBLIC API
    static get denomination() {
        return this._denomination;
    }
    get credits() {
        return Math.floor(this._balance / Wallet._denomination);
    }
    get balance() {
        return this._balance;
    }
    set balance(value) {
        if (this._balance == value) {
            return;
        }
        this._balance = value;
        this.emit(WalletEvent.BALANCE_CHANGED);
    }
    set coinValue(value) {
        if (this._coinValue == value) {
            return;
        }
        this._coinValue = value;
        this.emit(WalletEvent.COIN_VALUE_CHANGED, this._coinValue);
    }
    get coinValue() {
        return this._coinValue;
    }
    getCurrencyValue(value, showIsoCode = true) {
        const amount = Number((value / Wallet._denomination).toFixed(Wallet.currency.precision));
        const isoCode = Wallet.currency.isoCode && showIsoCode ? ' ' + Wallet.currency.isoCode : '';
        return `${amount.toLocaleString('de-DE')}${isoCode}`;
    }
}
Wallet._denomination = 100;
/* harmony default export */ const model_Wallet = (Wallet);

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/CompleteRoundCommand.ts







class CompleteRoundCommand extends ControlCommand {
    execute() {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.roundResult.complete = true;
        wallet.balance += sm.roundResult.totalWinValue;
        if (sm.autoplay.enabled && sm.autoplay.canAutoSpin(sm.roundResult, wallet.credits)) {
            if (sm.autoplay.spinsLeft > 0)
                sm.autoplay.spinsLeft -= 1;
            new ControlEvent(SlotGameEvent.SPIN_START).dispatch();
        }
        else {
            sm.autoplay.spinsLeft = 0;
            sm.autoplay.enabled = false;
            sm.currentState = SlotMachineState.IDLE;
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
}

const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0]
  }

  return str;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

/* harmony default export */ const utils = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const core_AxiosError = (AxiosError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js
// eslint-disable-next-line strict
/* harmony default export */ const helpers_null = (null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (helpers_null || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const helpers_toFormData = (toFormData);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const core_InterceptorManager = (InterceptorManager);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ const defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js


/* harmony default export */ const classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/Blob.js


/* harmony default export */ const classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js




/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
 const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();


/* harmony default export */ const browser = ({
  isBrowser: true,
  classes: {
    URLSearchParams: classes_URLSearchParams,
    FormData: classes_FormData,
    Blob: classes_Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new browser.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (browser.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js










const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: browser.classes.FormData,
    Blob: browser.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

/* harmony default export */ const lib_defaults = (defaults);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ const cancel_CanceledError = (CanceledError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js





/* harmony default export */ const cookies = (browser.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })());

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js





/* harmony default export */ const isURLSameOrigin = (browser.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })());

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const helpers_speedometer = (speedometer);

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js
















function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      if (browser.isStandardBrowserEnv || browser.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else {
        requestHeaders.setContentType('multipart/form-data;', false); // mobile/desktop app frameworks
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || defaults_transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (browser.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && browser.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js





const knownAdapters = {
  http: helpers_null,
  xhr: xhr
}

utils.forEach(knownAdapters, (fn, value) => {
  if(fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

/* harmony default export */ const adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new core_AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          'ERR_NOT_SUPPORT'
        );
      }

      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
          `Adapter '${nameOrAdapter}' is not available in the build` :
          `Unknown adapter '${nameOrAdapter}'`
      );
    }

    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js
const data_VERSION = "1.4.0";
;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + data_VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const validator = ({
  assertOptions,
  validators
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: Axios_validators.function,
          serialize: Axios_validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    contextHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const core_Axios = (Axios);

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const cancel_CancelToken = (CancelToken);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);

;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js



















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = data_VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const lib_axios = (axios);

;// CONCATENATED MODULE: ./node_modules/jwt-decode/build/jwt-decode.esm.js
function jwt_decode_esm_e(e){this.message=e}jwt_decode_esm_e.prototype=new Error,jwt_decode_esm_e.prototype.name="InvalidCharacterError";var jwt_decode_esm_r="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new jwt_decode_esm_e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function jwt_decode_esm_t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw"Illegal base64url string!"}try{return function(e){return decodeURIComponent(jwt_decode_esm_r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return jwt_decode_esm_r(t)}}function jwt_decode_esm_n(e){this.message=e}function jwt_decode_esm_o(e,r){if("string"!=typeof e)throw new jwt_decode_esm_n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(jwt_decode_esm_t(e.split(".")[o]))}catch(e){throw new jwt_decode_esm_n("Invalid token specified: "+e.message)}}jwt_decode_esm_n.prototype=new Error,jwt_decode_esm_n.prototype.name="InvalidTokenError";/* harmony default export */ const jwt_decode_esm = (jwt_decode_esm_o);
//# sourceMappingURL=jwt-decode.esm.js.map

;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/native.js
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const esm_browser_native = ({
  randomUUID
});
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_browser_stringify = ((/* unused pure expression or super */ null && (stringify)));
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js




function v4(options, buf, offset) {
  if (esm_browser_native.randomUUID && !buf && !options) {
    return esm_browser_native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

/* harmony default export */ const esm_browser_v4 = (v4);
;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/HoldAndSpinnerStaticSymbolMap.ts
class HoldAndSpinnerStaticSymbolMap {
    constructor() {
        this.initializedSymbolsMap = [];
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/model/SlotMachineDescription.ts
var SlotMachineType;
(function (SlotMachineType) {
    SlotMachineType["LINES"] = "lines";
    SlotMachineType["WAYS"] = "ways";
    SlotMachineType["COMBINATIONS"] = "combinations";
})(SlotMachineType || (SlotMachineType = {}));
var WildcardType;
(function (WildcardType) {
    WildcardType["REGULAR"] = "regular";
    WildcardType["EXPANDING"] = "expanding";
    WildcardType["EXPANDED"] = "expaneded";
})(WildcardType || (WildcardType = {}));
var PatternType;
(function (PatternType) {
    PatternType["LEFTMOST"] = "leftmost";
    PatternType["BOTH_WAYS"] = "bothWays";
    PatternType["SCATTER"] = "scatter";
})(PatternType || (PatternType = {}));

;// CONCATENATED MODULE: ./src/the-miner/model/LocalStorageUtils.ts
function saveToLocalStorage(key, data) {
    localStorage.setItem(key, JSON.stringify(data));
}
function getFromLocalStorage(key) {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
}

;// CONCATENATED MODULE: ./src/the-miner/model/TransactionType.ts
var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["REGULAR"] = 1] = "REGULAR";
    TransactionType[TransactionType["FREESPIN"] = 10] = "FREESPIN";
    TransactionType[TransactionType["HOLD_AND_SPINNER"] = 11] = "HOLD_AND_SPINNER";
})(TransactionType || (TransactionType = {}));

;// CONCATENATED MODULE: ./src/the-miner/services/event/GameServiceEvent.ts
var GameServiceEvent;
(function (GameServiceEvent) {
    GameServiceEvent["ERROR"] = "on_error_received";
    GameServiceEvent["DOUBLE_CHANCE_CHANGED"] = "onDoubleChanceChanged";
    GameServiceEvent["SETTINGS_CHANGED"] = "onSettingsChanged";
    GameServiceEvent["AUTOSPIN_SETTINGS_CHANGED"] = "onAutospinSettingsChanged";
})(GameServiceEvent || (GameServiceEvent = {}));

;// CONCATENATED MODULE: ./src/the-miner/services/text-json-files/DataSource.ts
const jsonAdress = {
    'EN': 'translations/translationFileEN.json',
    'TR': 'translations/translationFileTR.json',
};
const currencyCode = {
    'EUR': '',
    'TRY': ''
};

;// CONCATENATED MODULE: ./src/the-miner/services/GameService.ts
var GameService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GameService_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var GameService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};














let GameService = class GameService extends (eventemitter3_default()) {
    constructor(baseUrl, historyUrl, jwtToken, gameCode, userLoginUrl = '', creditUrl = '') {
        var _a;
        super();
        // token will refresh if less than X seconds left to expiry
        this.tokenRefreshThreshold = 300;
        this.featureBuy = {
            config: [],
            currentRoundType: 1
        };
        this._doubleChanceEnabled = false;
        this.jwtToken = jwtToken;
        this.gameCode = gameCode;
        this.userLoginUrl = userLoginUrl;
        this.ax = lib_axios.create({
            baseURL: baseUrl,
            headers: {
                'Authorization': `Bearer ${this.jwtToken}`
            }
        });
        this.ax.interceptors.request.use((config) => GameService_awaiter(this, void 0, void 0, function* () {
            if (config.url != 'Game/KeepAlive') {
                yield this.checkAndUpdateToken();
            }
            return config;
        }), error => {
            Promise.reject(error);
        });
        this.hx = lib_axios.create({
            baseURL: historyUrl,
            headers: {
                'Authorization': `Bearer ${this.jwtToken}`
            }
        });
        this._settings = (_a = getFromLocalStorage('settings')) !== null && _a !== void 0 ? _a : {
            ambientMusic: true,
            soundFx: true,
        };
        this._autospinSettings = {
            skipScreens: false,
            limitlessAutoSpin: false,
            turboSpin: false,
            sliderAmount: 0
        };
    }
    // PUBLIC API
    initialize() {
        var _a, _b;
        return GameService_awaiter(this, void 0, void 0, function* () {
            const operatorLogin = yield this.operatorLogin();
            yield this.userLogin(operatorLogin);
            const data = yield this.login();
            data.GameInfo.SymbolMultiplier['HS'] = data.GameInfo.SymbolMultiplier.FS;
            const denomination = 1;
            const wallet = new model_Wallet(denomination, {
                isoCode: currencyCode[data.Player.Currency],
                precision: 2
            }, [1]);
            const description = {
                autospinSteps: Array.from({ length: 100 }, (_, i) => (i + 1) * 10),
                rtp: 'unknown',
                type: SlotMachineType.LINES,
                betLimits: data.GameInfo.LineBet,
                betMaxQuantity: 10,
                totalWinMultipliers: [
                    1, 2, 3, 4, 5
                ],
                lines: this.parseLinePattern(data),
                bigWinMultiplierLevels: [10, 20, 30, 40],
                symbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                // this array should have max possible multipliers 
                // for ex. third options will get multipliers from 51 to 500
                multiplierCompartment: [
                    10, 50, 500, 1000
                ],
                reels: {
                    regular: {
                        cascading: false,
                        reels: [
                            {
                                numRows: 3,
                                availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                            }
                        ]
                    },
                    freeSpins: [
                        {
                            id: 0,
                            cascading: true,
                            reels: [
                                {
                                    numRows: 3,
                                    availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                                },
                                {
                                    numRows: 3,
                                    availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                                },
                                {
                                    numRows: 3,
                                    availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                                },
                                {
                                    numRows: 3,
                                    availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                                },
                                {
                                    numRows: 3,
                                    availableSymbols: [25, 105, 104, 103, 102, 101, 204, 203, 202, 201, 302],
                                }
                            ]
                        },
                    ],
                },
                bonusGames: {
                    reel: {
                        cascading: false,
                        reels: [
                            {
                                numRows: 3,
                                availableSymbols: [1000],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [1000]
                            },
                            {
                                numRows: 3,
                                availableSymbols: [1000],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [1000],
                            },
                            {
                                numRows: 3,
                                availableSymbols: [1000],
                            }
                        ]
                    }
                },
                rules: [
                    ...this.parseSymbolMultiplier(data),
                ]
            };
            this.description = description;
            wallet.balance = data.Player.Balance;
            const slotMachine = new SlotMachine(description, {
                gameSpeedLevels: [
                    {
                        spin: {
                            tilt: 0.3,
                            time: 0.4,
                            delayPerReel: 0.1
                        },
                        stop: {
                            time: 0.3,
                            delayPerReel: 0.12,
                            delay: 1,
                        }
                    },
                    {
                        spin: {
                            tilt: 0.2,
                            time: 0.25,
                            delayPerReel: 0.1
                        },
                        stop: {
                            time: 0.15,
                            delayPerReel: 0.12,
                            delay: 1
                        }
                    },
                    {
                        spin: {
                            time: 0.25,
                        },
                        stop: {
                            time: 0.2,
                            delay: 0.5
                        }
                    },
                ]
            });
            let roundResult;
            if (data.Current) {
                roundResult = this.parseTransactDataToRoundResult(data, false);
                slotMachine.currentBetValue = (data.GameInfo.LineBet.includes(data.Current.Round.LineBet)
                    ? data.Current.Round.LineBet
                    : data.GameInfo.LineBet[0]) * model_Wallet.denomination;
            }
            else {
                roundResult = slotMachine.getDummyRoundResult(null);
                roundResult.nextType = data.Next.Type;
            }
            this.removeBlockElementFromSpinResult(roundResult);
            slotMachine.roundResult = roundResult;
            slotMachine.previousRoundResult = slotMachine.getDummyRoundResult(roundResult);
            data.GameInfo.BuyFeature.forEach((feature, index) => {
                this.featureBuy.config.push(feature);
            });
            this.featureBuy.currentRoundType = 1;
            if ((_b = (_a = data === null || data === void 0 ? void 0 : data.Current) === null || _a === void 0 ? void 0 : _a.Round) === null || _b === void 0 ? void 0 : _b.LineBet) {
                slotMachine.currentBetValue = data.Current.Round.LineBet;
            }
            return [wallet, slotMachine];
        });
    }
    get doubleUpChance() {
        return this._doubleChanceEnabled;
    }
    set doubleUpChance(isActive) {
        if (this._doubleChanceEnabled == isActive)
            return;
        this._doubleChanceEnabled = isActive;
        this.emit(GameServiceEvent.DOUBLE_CHANCE_CHANGED);
    }
    spin() {
        return GameService_awaiter(this, void 0, void 0, function* () {
            const sm = dependency_container_instance.resolve(SlotMachine);
            const wallet = dependency_container_instance.resolve(model_Wallet);
            const totalBet = (sm.currentBetValue * wallet.coinValue);
            return this.getFullRoundResultFromTransact(1, totalBet);
        });
    }
    removeBlockElementFromSpinResult(roundResult) {
        roundResult.spins.forEach((spin) => {
            for (let i = 0; i < spin.result.length; i++) {
                for (let j = 0; j < spin.result[i].length; j++) {
                    if (spin.result[i][j] == 0) {
                        spin.result[i].splice(j, 1);
                    }
                }
            }
        });
    }
    buyFeature() {
        return GameService_awaiter(this, void 0, void 0, function* () {
            const totalBet = (dependency_container_instance.resolve(SlotMachine).currentBetValue * dependency_container_instance.resolve(model_Wallet).coinValue);
            return this.getFullRoundResultFromTransact(this.featureBuyConfig.currentRoundType, totalBet);
        });
    }
    operatorLogin() {
        return GameService_awaiter(this, void 0, void 0, function* () {
            const res = yield this.ax.post('https://operator1-staging.exagaming.com/api/v1/auth/login', {
                userName: 'lobbyuser2',
                currencyCode: 'EUR'
            });
            return res.data.accessToken;
        });
    }
    userLogin(userToken) {
        return GameService_awaiter(this, void 0, void 0, function* () {
            const res = yield this.ax.post(this.userLoginUrl, {
                operatorId: '1',
                operatorUserToken: userToken,
                currencyCode: 'EUR',
                gameId: 37
            });
            this.ax.defaults.headers.Authorization = `Bearer ${res.data.data.accessToken}`;
            this.hx.defaults.headers.Authorization = `Bearer ${res.data.data.accessToken}`;
        });
    }
    login() {
        return GameService_awaiter(this, void 0, void 0, function* () {
            utils_Logger.debug('GameService.login');
            const res = yield this.ax.post('preload', {
                GameCode: this.gameCode
            });
            return res.data.data;
        });
    }
    keepAlive() {
        return GameService_awaiter(this, void 0, void 0, function* () {
            utils_Logger.debug('GameService.keepAlive');
            // const res: AxiosResponse = await this.ax.post('Game/KeepAlive', {
            //     GameCode: this.gameCode
            // })
            // this.jwtToken = res.data.Jwt;
            // this.ax.defaults.headers.Authorisation = `Bearer ${this.jwtToken}`;
        });
    }
    //Round type: 1 - base game, 2 - feature buy
    transact(lineBet, numLines, type, roundType = 1) {
        return GameService_awaiter(this, void 0, void 0, function* () {
            utils_Logger.debug('GameService.transact');
            const res = yield this.ax.post('transact', {
                Type: type !== null && type !== void 0 ? type : 1,
                BetValue: 1,
                Line: numLines,
                LineBet: lineBet,
                RoundType: roundType,
            });
            return res.data.data;
        });
    }
    get featureBuyConfig() {
        return this.featureBuy;
    }
    saveAutoSpinSettings() {
        this.emit(GameServiceEvent.AUTOSPIN_SETTINGS_CHANGED);
    }
    getAutospinSettings() {
        return this._autospinSettings;
    }
    saveSettings() {
        saveToLocalStorage('settings', this._settings);
        this.emit(GameServiceEvent.SETTINGS_CHANGED, this);
    }
    get settings() {
        return this._settings;
    }
    // PRIVATE API
    checkAndUpdateToken() {
        return GameService_awaiter(this, void 0, void 0, function* () {
            const expirationTimestamp = jwt_decode_esm(this.jwtToken)['exp'] * 1000;
            const timeLeftSeconds = (expirationTimestamp - Date.now()) / 1000;
            if (timeLeftSeconds < this.tokenRefreshThreshold) {
                yield this.keepAlive();
            }
        });
    }
    getFullRoundResultFromTransact(roundType = 1, bet) {
        return GameService_awaiter(this, void 0, void 0, function* () {
            const sm = dependency_container_instance.resolve(SlotMachine);
            const wallet = dependency_container_instance.resolve(model_Wallet);
            let data = null;
            const totalBet = (sm.totalBet * wallet.coinValue);
            try {
                data = yield this.transact(bet / model_Wallet.denomination, sm.numLines, sm.previousRoundResult.nextType, roundType);
            }
            catch (e) {
                console.log(e);
                this.emit(GameServiceEvent.ERROR);
                throw (e);
            }
            const roundResult = this.parseTransactDataToRoundResult(data);
            console.log('main result type: ' + roundResult.nextType);
            const freespins = roundResult.spins[0].freespins;
            roundResult.spins.forEach((spin) => {
                if (roundResult.spins[0].freespins) {
                    spin.freespins = freespins;
                }
            });
            return roundResult;
        });
    }
    parseTransactDataToRoundResult(data, fullParse = true) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const pNextType = (_a = data.Current) === null || _a === void 0 ? void 0 : _a.Type;
        const winResultMap = {
            [TransactionType.REGULAR]: () => { var _a, _b; return (_b = (_a = data.Current) === null || _a === void 0 ? void 0 : _a.Result.WR) === null || _b === void 0 ? void 0 : _b[0]; },
            [TransactionType.HOLD_AND_SPINNER]: () => null,
            [TransactionType.FREESPIN]: () => { var _a, _b; return (_b = (_a = data.Current) === null || _a === void 0 ? void 0 : _a.Result.WR) === null || _b === void 0 ? void 0 : _b[0]; }
        };
        const multiplierMapMap = {
            [TransactionType.REGULAR]: () => { var _a; return (_a = data.Current) === null || _a === void 0 ? void 0 : _a.Result.base; },
            [TransactionType.HOLD_AND_SPINNER]: () => data.Current.Result.money,
            [TransactionType.FREESPIN]: () => { var _a; return (_a = data.Current) === null || _a === void 0 ? void 0 : _a.Result.wild; }
        };
        const multiplierResult = pNextType ? multiplierMapMap[pNextType]() : null;
        const winResult = pNextType ? winResultMap[pNextType]() : null;
        // TEST RESULTS
        const dummyHook = {
            active: true,
            details: [
                {
                    reelIndex: 0,
                    newReel: '301,301,302'
                },
                {
                    reelIndex: 3,
                    newReel: '105,104,101'
                },
            ]
        };
        const dummyBazooka = {
            'active': true,
            'R': '25,101,302|25,101,302|25,101,302|25,101,302|25,101,302'
        };
        const roundResult = {
            complete: false,
            id: esm_browser_v4(),
            lineBetValue: data.Current ? data.Current.Round.LineBet * model_Wallet.denomination : 0,
            betLines: data.Current ? data.Current.Round.Line : 0,
            totalBet: data.Current ? data.Current.Round.Bet : 0,
            totalWinValue: data.Current ? data.Current.Round.Payout : 0,
            actualSpinWinValue: data.Current ? data.Current.TotalWin : 0,
            spinIndex: 0,
            nextType: data.Next.Type,
            spins: [
                {
                    result: data.Current ?
                        data.Current.Type == TransactionType.HOLD_AND_SPINNER ?
                            this.holdAndSpinnerOutput(data.Current.Result.R, multiplierResult) :
                            (data.Current.Type == TransactionType.FREESPIN && ((_b = data.Current.Result.hook) === null || _b === void 0 ? void 0 : _b.active)) ?
                                this.parseReelsOutput(data.Current.Result.hook.beforeHookR) :
                                this.parseReelsOutput(data.Current.Result.R) :
                        this.dummyResultArray(),
                    winValue: data.Current ? data.Current.AccWin : 0,
                    currentTotalWinValue: data.Current ? data.Current.Round.Payout : 0,
                    win: (data.Current && fullParse && ((_c = winResult === null || winResult === void 0 ? void 0 : winResult.R) === null || _c === void 0 ? void 0 : _c.length)) ? {
                        multiWinShown: false,
                        lines: this.parseLineWins(this.parseReelsOutput(data.Current.Result.R), winResult.Details),
                        scatterWinShown: false,
                        scatters: data.Current.Result.SC > 0 ? this.parseScatterWins(data.Current.Result.R, data.Current.Result.R) : null,
                    } : null,
                    freespins: (data.Current && (data.Next.FreeSpin || data.Current.FreeSpin)) ? {
                        freespinId: data.Current.FreeSpin ? data.Current.FreeSpin.Current : 0,
                        totalCount: data.Current.FreeSpin ? data.Current.FreeSpin.Total : data.Next.FreeSpin.Total,
                        remainingCount: (data.Current.FreeSpin ? data.Current.FreeSpin.Total - data.Current.FreeSpin.Current : data.Next.FreeSpin.Total), //data.Next.FreeSpin? data.Next.FreeSpin.Total - (data.Next.FreeSpin.Next-1):data.Current.FreeSpin? data.Current.FreeSpin.Total - data.Current.FreeSpin.Current: 0,// (data.Current.FreeSpin ? data.Current.FreeSpin.Total - (data.Current.FreeSpin.Current+1) :(data.Next.FreeSpin?data.Next.FreeSpin.Total:0)),
                        roundStarted: (data.Current.FreeSpin && data.Current.FreeSpin.Current > 0),
                        moreAwarded: ((_d = data.Next.FreeSpin) === null || _d === void 0 ? void 0 : _d.MoreAwarded) ? (_e = data.Next.FreeSpin) === null || _e === void 0 ? void 0 : _e.MoreAwarded : null,
                        roundComplete: false,
                    } : null,
                    bonus: data.Next.Type == TransactionType.HOLD_AND_SPINNER || data.Current.Type == TransactionType.HOLD_AND_SPINNER ? {
                        bonusGameComplete: (data.Next.Type !== TransactionType.HOLD_AND_SPINNER && data.Current.Type !== TransactionType.HOLD_AND_SPINNER),
                        bonusGameShown: data.Current.Type == TransactionType.HOLD_AND_SPINNER
                    } : null
                }
            ],
            // EXTENDS
            holdAndSpinner: (data.Current && (data.Next.Type == TransactionType.HOLD_AND_SPINNER || data.Current.Type == TransactionType.HOLD_AND_SPINNER)) ? {
                remainingCount: data.Next.spinsLeft,
            } : null,
            holdAndSpinnerMultiplierMap: data.Current ? this.parseMultiplierMap(multiplierResult, data.Next.Type, (_f = data.Current) === null || _f === void 0 ? void 0 : _f.Result.hook, ((_h = (_g = data.Current) === null || _g === void 0 ? void 0 : _g.Result.bazooka) === null || _h === void 0 ? void 0 : _h.active) ? (_j = data.Current) === null || _j === void 0 ? void 0 : _j.Result.bazooka : null) : null,
            hook: ((_l = (_k = data.Current) === null || _k === void 0 ? void 0 : _k.Result.hook) === null || _l === void 0 ? void 0 : _l.active) ? this.parseHook(data.Current.Result.hook) : null,
            bazooka: ((_o = (_m = data.Current) === null || _m === void 0 ? void 0 : _m.Result.bazooka) === null || _o === void 0 ? void 0 : _o.active) ? this.parseBazooka(data.Current.Result.bazooka) : null,
        };
        console.log(roundResult.nextType);
        return roundResult;
    }
    parseHook(data) {
        const active = data.active;
        const detailsArr = [];
        data.details.forEach((item) => {
            const rsd = item.newReel.split(',');
            const resultArr = [];
            rsd.forEach((rd) => {
                resultArr.push(Number(rd));
            });
            detailsArr.push({
                reelId: item.reelIndex,
                newReel: resultArr,
            });
        });
        return {
            shown: false,
            active: active,
            result: detailsArr,
        };
    }
    holdAndSpinnerOutput(data, multiplierResult) {
        const staticSymbolID = 302;
        const hSMap = dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap;
        // in this feature all the symbols except the main symbol should be replaced
        const result = this.parseReelsOutput(data);
        result.forEach((row, rowIndex) => {
            row.forEach((symbol, symbolIndex) => {
                if (symbol != staticSymbolID)
                    row[symbolIndex] = this.description.bonusGames.reel.reels[0].availableSymbols[0];
                if (symbol == staticSymbolID) {
                    if (hSMap.length) {
                        hSMap.forEach((hsSymbol) => {
                            if (hsSymbol.x == rowIndex && hsSymbol.y == symbolIndex) {
                                row[symbolIndex] = this.description.bonusGames.reel.reels[0].availableSymbols[0];
                            }
                        });
                    }
                }
            });
        });
        return result;
    }
    parseBazooka(data) {
        return {
            shown: false,
            active: data.active,
            R: data.R.split('|')
                .map((value) => {
                return value.split(',')
                    .map((value) => {
                    return parseInt(value);
                });
            })
        };
    }
    dummyResultArray() {
        const pattern = [];
        for (let i = 0; i < this.description.reels.regular.reels.length; i++) {
            pattern.push([]);
            for (let j = 0; j < this.description.reels.regular.reels[0].numRows; j++) {
                pattern[i].push(this.description.symbols[Math.floor(Math.random() * this.description.symbols.length)]);
            }
        }
        return pattern;
    }
    parseWaysWins(winRoundResult, patternResult) {
        const roundResult = this.buildScatterPattern(winRoundResult);
        const pattern = [];
        //Initialize empty pattern
        for (let i = 0; i < roundResult.length; i++) {
            const reel = [];
            for (let j = 0; j < roundResult[i].length; j++) {
                reel.push(0);
            }
            pattern.push(reel);
        }
        for (let i = 0; i < patternResult.length; i++) {
            for (let j = 0; j < patternResult[i].length; j++) {
                pattern[i][patternResult[i][j]] = 1;
            }
        }
        return {
            winValue: 0,
            symbolId: 0,
            pattern: pattern
        };
    }
    parseReelsOutput(data) {
        return data.split('|')
            .map((value) => {
            return value.split(',')
                .map((value) => {
                return parseInt(value);
            });
        });
    }
    parseCombinationWin(wrResult) {
        return wrResult.map(item => {
            const symbol = item.symbol;
            const wayPayout = item.wayPayout;
            const way = item.way.map(w => w.split('-').map(Number));
            const multiplier = item.multiplier;
            const pattern = this.buildCombinationPattern(way);
            return {
                multiplier: multiplier,
                symbol: symbol,
                way: way,
                wayPayout: wayPayout,
                pattern: pattern
            };
        });
    }
    parseMultiplierMap(data, nextType, hook, bazooka) {
        var _a, _b, _c, _d, _e;
        if (data == null)
            return null;
        const parseMap = (map) => {
            return Object.entries(map).map(([key, value]) => {
                const [x, y] = key.split(',').map(Number);
                return {
                    x,
                    y,
                    multiplier: Number(value),
                    createOnInitialization: true
                };
            });
        };
        // in base spins the moneyMultiplier map is getting only basic Multiplier map array =>( x,y -> multiplier )
        // in H&S feature the same map is transformed into object with two arrays of Multiplier map => ( newSymbols (x,y -> multiplier), initSymbol (x,y -> multiplier) ),
        // so after reload we can know which symbols are the static symbols ( the ones which should stay on reel during spin )
        const freespinsSymbolMultiplierMap = data.fishSymbolMultiplierMap ? parseMap(data.fishSymbolMultiplierMap) : null;
        //!!!If there is a hook feature the symbol shouldn't get any multiplier, because it will appear after the reel pull
        if (hook === null || hook === void 0 ? void 0 : hook.active) {
            freespinsSymbolMultiplierMap.forEach((value, index) => {
                hook.details.forEach(hookDetail => {
                    if (hookDetail.reelIndex == value.x) {
                        freespinsSymbolMultiplierMap[index].createOnInitialization = false;
                    }
                });
            });
        }
        if (bazooka === null || bazooka === void 0 ? void 0 : bazooka.active) {
            freespinsSymbolMultiplierMap.forEach((value, index) => {
                freespinsSymbolMultiplierMap[index].createOnInitialization = false;
            });
        }
        // this const is using only to pass it to ReelsView
        const baseHoldAndSpinnerSymbolMap = data.moneySymbolMultiplierMap ? parseMap(data.moneySymbolMultiplierMap) : null;
        // these consts are ar used in Hold&SpinnerView for mechanics
        const featureHoldAndSpinnerStaticSymbolMultiplierMap = ((_a = data.moneySymbolMultiplierMap) === null || _a === void 0 ? void 0 : _a.initialFixedMap) ? parseMap(data.moneySymbolMultiplierMap.initialFixedMap) : null;
        const featureHoldAndSpinnerNewSymbolMultiplierMap = ((_b = data.moneySymbolMultiplierMap) === null || _b === void 0 ? void 0 : _b.newWinningsMap) ? parseMap(data.moneySymbolMultiplierMap.newWinningsMap) : null;
        const moneySymbolMM = {
            initialFixedMap: featureHoldAndSpinnerStaticSymbolMultiplierMap,
            newWinningsMap: featureHoldAndSpinnerNewSymbolMultiplierMap
        };
        return Object.assign(Object.assign(Object.assign({ collectedCount: (_c = data.collectedCount) !== null && _c !== void 0 ? _c : null, featureMultiplier: (_d = data.featureMultiplier) !== null && _d !== void 0 ? _d : null, wildPosition: ((_e = data.position) === null || _e === void 0 ? void 0 : _e.length) ?
                this.parseWildMap(data.position) :
                null, toCollect: !!data.toCollect || !!data.position }, (data.fishSymbolMultiplierMap ?
            { featureSymbolMultiplierMap: freespinsSymbolMultiplierMap } :
            {})), (data.moneySymbolMultiplierMap ?
            { moneySymbolMultiplierMap: moneySymbolMM } :
            {})), { 
            // this array is passed to ReelView to create multiplier on each symbol
            // featureHoldAndSpinnerStaticSymbolMultiplierMap is passed only when the next result is Regular spin and initializedSymbolsMap is empty
            // this is because during H&S feature symbols' multipliers are already on H&S feature view on static symbols so we don't want to create them on reel stripe
            // THE API IS RESPONDING WITH RANDOM SYMBOLS ID DURING H&S BUT WHE SHOULD HAVE ONLY ONE ID FOR STATIC SYMBOL DURING H&S
            // ( we have to manually transform the Result of reel to adjust it to feature reference ) - at least for now
            initializationMap: [].concat(baseHoldAndSpinnerSymbolMap || [], (featureHoldAndSpinnerStaticSymbolMultiplierMap &&
                nextType == TransactionType.REGULAR &&
                !dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.length) ? featureHoldAndSpinnerStaticSymbolMultiplierMap : [], featureHoldAndSpinnerNewSymbolMultiplierMap || [], freespinsSymbolMultiplierMap || []) });
    }
    parseWildMap(data) {
        const wm = data.split(',');
        const x = parseInt(wm[0]);
        const y = parseInt(wm[1]);
        return {
            x: x,
            y: y
        };
    }
    parseLineWins(ReelsOutput, Details) {
        if (!Details.length)
            return null;
        const lineWins = [];
        const sm = dependency_container_instance.resolve(SlotMachine);
        Details.forEach(detail => {
            if (detail.payout > 0) {
                const pattern = this.buildLinePattern(detail.pattern, detail.symbol, ReelsOutput, detail.matched);
                const winValue = detail.payout;
                const symbolId = detail.symbol;
                const symbolCount = detail.matched;
                const winningRule = sm.findRule(symbolId, symbolCount);
                lineWins.push({
                    pattern: pattern,
                    winValue: winValue,
                    ruleId: winningRule.id,
                    winMultiplier: 1
                });
            }
        });
        return lineWins;
    }
    parseScatterWins(winRoundResult, roundResult) {
        const swd = winRoundResult.split(',');
        // CoinPayout,Line,TotalSymbolMatched,Symbol
        const winValue = parseFloat(swd[0]) * model_Wallet.denomination;
        const symbolId = parseInt(swd[2]);
        return {
            winValue: winValue,
            symbolId: symbolId,
            pattern: this.buildScatterPattern(roundResult, symbolId)
        };
    }
    buildCombinationPattern(indexArray) {
        const desc = this.description;
        const pattern = [];
        desc.reels.regular.reels.forEach((rd) => {
            pattern.push(new Array(rd.numRows).fill(0));
        });
        for (let i = 0; i < indexArray.length; i++) {
            pattern[indexArray[i][0]][indexArray[i][1]] = 1;
        }
        return pattern;
    }
    buildLinePattern(pattern, symbolId, reelsOutput, matched) {
        const desc = dependency_container_instance.resolve(SlotMachine).description;
        const newPattern = [];
        desc.reels.regular.reels.forEach((rd) => {
            newPattern.push(new Array(rd.numRows).fill(0));
        });
        const rows = this.description.reels.regular.reels[0].numRows;
        const reelsCount = this.description.reels.regular.reels.length;
        pattern.forEach((id) => {
            const row = id % reelsCount;
            const col = Math.floor(id / reelsCount);
            if (reelsOutput[row][col] === symbolId && matched > 0) {
                newPattern[row][col] = 1;
                matched--;
            }
        });
        return newPattern;
    }
    buildScatterPattern(data, symbolId = null) {
        const pattern = [];
        data.split('|')
            .map((reelData) => {
            const lwd = reelData.split(',');
            const reel = [];
            lwd.forEach((symbol) => {
                const id = parseInt(symbol);
                reel.push(id === symbolId ? 1 : 0);
            });
            console.log(reel);
            pattern.push(reel);
        });
        return pattern;
    }
    // // DEBUG CODE ONLY
    // private randomResult(sm: SlotMachine): number[][] {
    //     const reelSetDescription: ReelSetDescription = sm.description.reels.regular;
    //     return [
    //         [randomArrayElement(reelSetDescription.reels[0].availableSymbols), randomArrayElement(reelSetDescription.reels[0].availableSymbols), randomArrayElement(reelSetDescription.reels[0].availableSymbols)],
    //         [randomArrayElement(reelSetDescription.reels[1].availableSymbols), randomArrayElement(reelSetDescription.reels[1].availableSymbols), randomArrayElement(reelSetDescription.reels[1].availableSymbols)],
    //         [randomArrayElement(reelSetDescription.reels[2].availableSymbols), randomArrayElement(reelSetDescription.reels[2].availableSymbols), randomArrayElement(reelSetDescription.reels[2].availableSymbols)],
    //         [randomArrayElement(reelSetDescription.reels[3].availableSymbols), randomArrayElement(reelSetDescription.reels[3].availableSymbols), randomArrayElement(reelSetDescription.reels[3].availableSymbols)],
    //         [randomArrayElement(reelSetDescription.reels[4].availableSymbols), randomArrayElement(reelSetDescription.reels[4].availableSymbols), randomArrayElement(reelSetDescription.reels[4].availableSymbols)],
    //     ];
    // }
    pickOneConverter(output, pickOneSymbols) {
        for (let i = 0; i < output.length; i++) {
            for (let j = 0; j < output[i].length; j++) {
                if (pickOneSymbols.includes(output[i][j])) {
                    output[i][j] = this.removeFirstDigit(output[i][j]);
                }
            }
        }
    }
    removeFirstDigit(num) {
        const numStr = num.toString();
        if (numStr.length >= 2) {
            const newNumStr = numStr.slice(1);
            return parseInt(newNumStr);
        }
    }
    parseLinePattern(data) {
        return Object.entries(data.GameInfo.Patterns)
            .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
            .map(entry => entry[1].map(e => Math.floor(e / entry[1].length)));
    }
    parseSymbolMultiplier(data) {
        const symbolMap = {
            HP4: 204,
            HP3: 203,
            HP2: 202,
            HP1: 201,
            LP5: 105,
            LP4: 104,
            LP3: 103,
            LP2: 102,
            LP1: 101,
            FS: 25,
            HS: 301
        };
        return Object.entries(data.GameInfo.SymbolMultiplier)
            .flatMap(entry => Object.entries(entry[1]).flatMap(inner => ({
            id: 0,
            pattern: {
                symbolId: symbolMap[entry[0]],
                symbolCount: [parseInt(inner[0])],
                type: PatternType.BOTH_WAYS
            },
            reward: {
                line: {
                    multiplier: inner[1]
                }
            }
        })));
    }
};
GameService = GameService_decorate([
    decorators_singleton(),
    GameService_metadata("design:paramtypes", [String, String, String, String, String, String])
], GameService);
/* harmony default export */ const services_GameService = (GameService);

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/SpinStartCommand.ts










class SpinStartCommand extends ControlCommand {
    execute() {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (wallet.balance < sm.totalBet) {
            if (sm.autoplay.enabled) {
                sm.autoplay.spinsLeft = 0;
                sm.autoplay.enabled = false;
            }
            sm.currentState = SlotMachineState.IDLE;
            wallet.emit(WalletEvent.NOT_ENOUGH_BALANCE);
            return;
        }
        wallet.balance -= sm.totalBet;
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult.totalWinValue = 0;
        sm.roundResult = null;
        sm.currentState = SlotMachineState.SPINNING;
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.spin()
            .then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
        })
            .catch((e) => {
            utils_Logger.error(e);
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            wallet.balance += sm.totalBet;
            sm.currentState = SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/control/FrontController.ts



class FrontController {
    constructor() {
        this.controlEventDispatcher = ControlEventDispatcher.getInstance();
        this.commands = new Map();
    }
    // PUBLIC API
    addCommand(eventType, commandType, ...rest) {
        if (!this.commands.has(eventType)) {
            this.commands.set(eventType, []);
        }
        const associated = this.commands.get(eventType);
        associated.push(commandType);
        if (!this.controlEventDispatcher.hasEventListener(eventType)) {
            this.controlEventDispatcher.addEventListener(eventType, (e) => {
                this.onEvent(e, ...rest);
            });
        }
    }
    removeCommand(eventType, commandType) {
        if (!this.commands.has(eventType)) {
            this.commands.set(eventType, []);
        }
        const associated = this.commands.get(eventType);
        removeArrayElement(associated, commandType);
    }
    // PRIVATE API
    onEvent(e, ...rest) {
        const associated = this.commands.get(e.type);
        for (const cType of associated) {
            utils_Logger.debug(cType.name);
            const c = new cType();
            c.execute(e.clone(), ...rest);
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/StartGameCommand.ts




class StartGameCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentState = SlotMachineState.IDLE;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/event/UIEvent.ts
var UIEvent;
(function (UIEvent) {
    UIEvent["AUTO_SPIN"] = "onUIAutoSpin";
    UIEvent["BET_QUANTITY_UP"] = "onBetQuantityUp";
    UIEvent["BET_QUANTITY_DOWN"] = "onBetQuantityDown";
    UIEvent["BET_QUANTITY_MAX"] = "onBetQuantityMax";
    UIEvent["COIN_VALUE_UP"] = "onCoinValueUp";
    UIEvent["COIN_VALUE_DOWN"] = "onCoinValueDown";
    UIEvent["COIN_VALUE_MAX"] = "onCoinValueMax";
    UIEvent["BET_UP"] = "onUIBetUp";
    UIEvent["BET_DOWN"] = "onUIBetDown";
    UIEvent["BET_SELECT"] = "onUIBetSelect";
    UIEvent["GAME_SPEED_LEVEL_UP"] = "onUIGameSpeedLevelUp";
    UIEvent["GAME_SPEED_LEVEL_DOWN"] = "onUIGameSpeedLevelDown";
})(UIEvent || (UIEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/AdjustBetCommand.ts





class AdjustBetCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        const betLimits = sm.description.betLimits;
        if (event.type == UIEvent.BET_UP) {
            if (betLimits.indexOf(sm.currentBetValue) < betLimits.length - 1) {
                sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) + 1];
            }
        }
        else if (event.type == UIEvent.BET_DOWN) {
            if (betLimits.indexOf(sm.currentBetValue) != 0) {
                sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) - 1];
            }
        }
        else if (event.type == UIEvent.BET_SELECT && sm.currentState == SlotMachineState.IDLE) {
            const data = event === null || event === void 0 ? void 0 : event.data;
            const id = betLimits.indexOf(data);
            if (betLimits[id] != null) {
                sm.currentBetValue = betLimits[id];
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/AdjustGameSpeedCommand.ts




class AdjustGameSpeedCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (event.type == UIEvent.GAME_SPEED_LEVEL_UP) {
            sm.currentGameSpeedLevel = Math.min(sm.currentGameSpeedLevel + 1, sm.options.gameSpeedLevels.length - 1);
        }
        else if (event.type == UIEvent.GAME_SPEED_LEVEL_DOWN) {
            sm.currentGameSpeedLevel = Math.max(0, sm.currentGameSpeedLevel - 1);
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/AdjustAutoSpinCommand.ts







class AdjustAutoSpinCommand extends ControlCommand {
    execute(event) {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const sm = dependency_container_instance.resolve(SlotMachine);
        const settings = event.data;
        if (!settings) {
            sm.autoplay.enabled = false;
            sm.autoplay.spinsLeft = 0;
        }
        else {
            sm.autoplay.settings = settings;
            if (sm.currentState == SlotMachineState.IDLE && sm.autoplay.spinsLeft != 0) {
                sm.autoplay.startBalance = wallet.credits;
                sm.autoplay.enabled = true;
                if (sm.autoplay.spinsLeft > 0)
                    sm.autoplay.spinsLeft -= 1;
                new ControlEvent(SlotGameEvent.SPIN_START).dispatch();
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmReelsStartedCommand.ts





class ConfirmReelsStartedCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.reelsStarted = true;
        new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmSpinTimeLapsedCommand.ts





class ConfirmSpinTimeLapsedCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.spinTimeLapsed = true;
        new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/SpinStopCommand.ts




class SpinStopCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (!sm.spinTimeLapsed || !sm.reelsStarted || !sm.roundResult || sm.currentState == SlotMachineState.COMMUNICATION_ERROR) {
            return;
        }
        sm.currentState = SlotMachineState.SPIN_END;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmMultiWinCommand.ts





class ConfirmMultiWinCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.win.multiWinShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ProcessSpinResultCommand.ts






class ProcessSpinResultCommand extends ControlCommand {
    execute() {
        var _a, _b;
        const sm = dependency_container_instance.resolve(SlotMachine);
        const roundResult = sm.roundResult;
        console.log('data');
        console.log(sm.roundResult);
        const spinResult = sm.currentSpinResult;
        // show multi win
        if (spinResult.win && !spinResult.win.multiWinShown) {
            sm.currentState = SlotMachineState.SPIN_RESULT_MULTI_WIN;
            return;
        }
        // show scatter wins
        if (spinResult.win && !spinResult.win.scatterWinShown && spinResult.win.scatters) {
            sm.currentState = SlotMachineState.SPIN_RESULT_SCATTER;
            return;
        }
        // cascade to next spin result
        if (sm.description.reels.regular.cascading) {
            if (sm.nextSpinResult) {
                roundResult.spinIndex++;
                sm.currentState = SlotMachineState.SPIN_RESULT_CASCADE;
                return;
            }
        }
        // is bonus game won
        if (spinResult.bonus && !spinResult.bonus.bonusGameShown) {
            sm.currentState = SlotMachineState.SPIN_RESULT_BONUS_GAME;
            return;
        }
        // is bonus game incompleted
        if (spinResult.bonus && !spinResult.bonus.bonusGameComplete) {
            sm.currentState = SlotMachineState.BONUS_GAME;
            return;
        }
        // show free spins scatter wins
        if (spinResult.freespins && ((_a = spinResult.win) === null || _a === void 0 ? void 0 : _a.freespins) && !((_b = spinResult.win) === null || _b === void 0 ? void 0 : _b.freespinWinShown)) {
            sm.currentState = SlotMachineState.SPIN_RESULT_FREE_SPINS;
            return;
        }
        if (spinResult.freespins && !spinResult.freespins.roundComplete) {
            // show free spins start
            if (!spinResult.freespins.roundStarted) {
                sm.currentState = SlotMachineState.FREE_SPINS_ROUND_START;
                return;
            }
            // are any freespins remaining
            if (spinResult.freespins.remainingCount) {
                sm.currentState = SlotMachineState.FREE_SPINS;
                return;
            }
            // show freespin end
            if (!spinResult.freespins.roundComplete) {
                sm.currentState = SlotMachineState.FREE_SPINS_ROUND_END;
                return;
            }
        }
        // show big win
        if (sm.bigWinLevel(roundResult) != -1 && !sm.bigWinShown) {
            sm.currentState = SlotMachineState.BIG_WIN;
            return;
        }
        //if round result is already completed
        if (sm.roundResult.complete == true)
            return;
        new ControlEvent(SlotGameEvent.ROUND_COMPLETE).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmBigWinCommand.ts





class ConfirmBigWinCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.bigWinShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/InitializeCommand.ts





class InitializeCommand extends ControlCommand {
    execute(event) {
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.initialize().then(([wallet, slotMachine]) => {
            dependency_container_instance.registerInstance(model_Wallet, wallet);
            dependency_container_instance.registerInstance(SlotMachine, slotMachine);
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/InstantSpinStopCommand.ts






class InstantSpinStopCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.stopRequested = true;
        sm.spinTimeLapsed = true;
        if (sm.currentState !== SlotMachineState.SPINNING)
            return;
        new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmScatterWinCommand.ts





class ConfirmScatterWinCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.win.scatterWinShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmFreespinsWinCommand.ts





class ConfirmFreespinsWinCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.win.freespinWinShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmFreeSpinsRoundStartedCommand.ts





class ConfirmFreeSpinsRoundStartedCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.freespins.roundStarted = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmFreeSpinsRoundCompleteCommand.ts





class ConfirmFreeSpinsRoundCompleteCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.freespins.roundComplete = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmBonusWinCommand.ts





class ConfirmBonusWinCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.bonus.bonusGameShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/ConfirmBonusGameCompleteCommand.ts





class ConfirmBonusGameCompleteCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.bonus.bonusGameComplete = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/FreeSpinStartCommand.ts








class FreeSpinStartCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult = null;
        sm.currentState = SlotMachineState.SPINNING;
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.spin().then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
        }).catch((e) => {
            utils_Logger.error(e);
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            sm.currentState = SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/command/AdjustCoinValueCommand.ts




class AdjustCoinValueCommand extends ControlCommand {
    execute(event) {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const coinValueLimits = wallet.coinValueLimits;
        if (event.type == UIEvent.COIN_VALUE_UP) {
            if (coinValueLimits.indexOf(wallet.coinValue) < coinValueLimits.length - 1) {
                wallet.coinValue = coinValueLimits[coinValueLimits.indexOf(wallet.coinValue) + 1];
            }
        }
        else if (event.type == UIEvent.COIN_VALUE_DOWN) {
            if (coinValueLimits.indexOf(wallet.coinValue) != 0) {
                wallet.coinValue = coinValueLimits[coinValueLimits.indexOf(wallet.coinValue) - 1];
            }
        }
        else if (event.type == UIEvent.COIN_VALUE_MAX) {
            wallet.coinValue = coinValueLimits[coinValueLimits.length - 1];
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/control/SlotGameFrontController.ts


























class SlotGameFrontController extends FrontController {
    constructor() {
        super();
        this.addCommand(ApplicationEvent.INIT, InitializeCommand);
        this.addCommand(ApplicationEvent.LOADING_COMPLETE, StartGameCommand);
        this.addCommand(UIEvent.COIN_VALUE_UP, AdjustCoinValueCommand);
        this.addCommand(UIEvent.COIN_VALUE_DOWN, AdjustCoinValueCommand);
        this.addCommand(UIEvent.COIN_VALUE_MAX, AdjustCoinValueCommand);
        this.addCommand(UIEvent.BET_UP, AdjustBetCommand);
        this.addCommand(UIEvent.BET_DOWN, AdjustBetCommand);
        this.addCommand(UIEvent.BET_SELECT, AdjustBetCommand);
        this.addCommand(UIEvent.GAME_SPEED_LEVEL_UP, AdjustGameSpeedCommand);
        this.addCommand(UIEvent.GAME_SPEED_LEVEL_DOWN, AdjustGameSpeedCommand);
        this.addCommand(UIEvent.AUTO_SPIN, AdjustAutoSpinCommand);
        this.addCommand(SlotGameEvent.SPIN_START, SpinStartCommand);
        this.addCommand(SlotGameEvent.REELS_STARTED, ConfirmReelsStartedCommand);
        this.addCommand(SlotGameEvent.SPIN_TIME_LAPSED, ConfirmSpinTimeLapsedCommand);
        this.addCommand(SlotGameEvent.SPIN_STOP, SpinStopCommand);
        this.addCommand(SlotGameEvent.STOP_REQUESTED, InstantSpinStopCommand);
        this.addCommand(SlotGameEvent.REELS_STOPPED, ProcessSpinResultCommand);
        this.addCommand(SlotGameEvent.MULTI_WIN_SHOWN, ConfirmMultiWinCommand);
        this.addCommand(SlotGameEvent.SCATTER_WIN_SHOWN, ConfirmScatterWinCommand);
        this.addCommand(SlotGameEvent.CASCADE_WIN_SHOWN, ProcessSpinResultCommand);
        this.addCommand(SlotGameEvent.BONUS_GAME_WIN_SHOWN, ConfirmBonusWinCommand);
        this.addCommand(SlotGameEvent.BONUS_GAME_COMPLETE, ConfirmBonusGameCompleteCommand);
        this.addCommand(SlotGameEvent.FREE_SPIN_WIN_SHOWN, ConfirmFreespinsWinCommand);
        this.addCommand(SlotGameEvent.FREE_SPIN_ROUND_STARTED, ConfirmFreeSpinsRoundStartedCommand);
        this.addCommand(SlotGameEvent.FREE_SPIN_START, FreeSpinStartCommand);
        this.addCommand(SlotGameEvent.FREE_SPIN_ROUND_COMPLETE, ConfirmFreeSpinsRoundCompleteCommand);
        this.addCommand(SlotGameEvent.BIG_WIN_SHOWN, ConfirmBigWinCommand);
        this.addCommand(SlotGameEvent.SPIN_RESULT_READY, ProcessSpinResultCommand);
        this.addCommand(SlotGameEvent.ROUND_COMPLETE, CompleteRoundCommand);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/IgnitionSlots.ts
const IgnitionSlots_VERSION = '1.0.0';

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs
var AttachmentType_AttachmentType = /* @__PURE__ */ ((AttachmentType2) => {
  AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
  AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
  AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
  AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
  AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
  AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
  AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
  return AttachmentType2;
})(AttachmentType_AttachmentType || {});


//# sourceMappingURL=AttachmentType.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/BinaryInput.mjs
class BinaryInput {
  constructor(data, strings = new Array(), index = 0, buffer = new DataView(data.buffer)) {
    this.strings = strings;
    this.index = index;
    this.buffer = buffer;
  }
  readByte() {
    return this.buffer.getInt8(this.index++);
  }
  readUnsignedByte() {
    return this.buffer.getUint8(this.index++);
  }
  readShort() {
    const value = this.buffer.getInt16(this.index);
    this.index += 2;
    return value;
  }
  readInt32() {
    const value = this.buffer.getInt32(this.index);
    this.index += 4;
    return value;
  }
  readInt(optimizePositive) {
    let b = this.readByte();
    let result = b & 127;
    if ((b & 128) != 0) {
      b = this.readByte();
      result |= (b & 127) << 7;
      if ((b & 128) != 0) {
        b = this.readByte();
        result |= (b & 127) << 14;
        if ((b & 128) != 0) {
          b = this.readByte();
          result |= (b & 127) << 21;
          if ((b & 128) != 0) {
            b = this.readByte();
            result |= (b & 127) << 28;
          }
        }
      }
    }
    return optimizePositive ? result : result >>> 1 ^ -(result & 1);
  }
  readStringRef() {
    const index = this.readInt(true);
    return index == 0 ? null : this.strings[index - 1];
  }
  readString() {
    let byteCount = this.readInt(true);
    switch (byteCount) {
      case 0:
        return null;
      case 1:
        return "";
    }
    byteCount--;
    let chars = "";
    for (let i = 0; i < byteCount; ) {
      const b = this.readUnsignedByte();
      switch (b >> 4) {
        case 12:
        case 13:
          chars += String.fromCharCode((b & 31) << 6 | this.readByte() & 63);
          i += 2;
          break;
        case 14:
          chars += String.fromCharCode((b & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
          i += 3;
          break;
        default:
          chars += String.fromCharCode(b);
          i++;
      }
    }
    return chars;
  }
  readFloat() {
    const value = this.buffer.getFloat32(this.index);
    this.index += 4;
    return value;
  }
  readBoolean() {
    return this.readByte() != 0;
  }
}


//# sourceMappingURL=BinaryInput.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/IAnimation.mjs
var MixBlend = /* @__PURE__ */ ((MixBlend2) => {
  MixBlend2[MixBlend2["setup"] = 0] = "setup";
  MixBlend2[MixBlend2["first"] = 1] = "first";
  MixBlend2[MixBlend2["replace"] = 2] = "replace";
  MixBlend2[MixBlend2["add"] = 3] = "add";
  return MixBlend2;
})(MixBlend || {});
var MixDirection = /* @__PURE__ */ ((MixDirection2) => {
  MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
  MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
  return MixDirection2;
})(MixDirection || {});


//# sourceMappingURL=IAnimation.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/IConstraint.mjs
var PositionMode = /* @__PURE__ */ ((PositionMode2) => {
  PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
  PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
  return PositionMode2;
})(PositionMode || {});
var RotateMode = /* @__PURE__ */ ((RotateMode2) => {
  RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
  RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
  RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
  return RotateMode2;
})(RotateMode || {});


//# sourceMappingURL=IConstraint.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/ISkeleton.mjs
var TransformMode = /* @__PURE__ */ ((TransformMode2) => {
  TransformMode2[TransformMode2["Normal"] = 0] = "Normal";
  TransformMode2[TransformMode2["OnlyTranslation"] = 1] = "OnlyTranslation";
  TransformMode2[TransformMode2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
  TransformMode2[TransformMode2["NoScale"] = 3] = "NoScale";
  TransformMode2[TransformMode2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
  return TransformMode2;
})(TransformMode || {});


//# sourceMappingURL=ISkeleton.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs
function filterFromString(text) {
  switch (text.toLowerCase()) {
    case "nearest":
      return TextureFilter.Nearest;
    case "linear":
      return TextureFilter.Linear;
    case "mipmap":
      return TextureFilter.MipMap;
    case "mipmapnearestnearest":
      return TextureFilter.MipMapNearestNearest;
    case "mipmaplinearnearest":
      return TextureFilter.MipMapLinearNearest;
    case "mipmapnearestlinear":
      return TextureFilter.MipMapNearestLinear;
    case "mipmaplinearlinear":
      return TextureFilter.MipMapLinearLinear;
    default:
      throw new Error(`Unknown texture filter ${text}`);
  }
}
function wrapFromString(text) {
  switch (text.toLowerCase()) {
    case "mirroredtepeat":
      return TextureWrap.MirroredRepeat;
    case "clamptoedge":
      return TextureWrap.ClampToEdge;
    case "repeat":
      return TextureWrap.Repeat;
    default:
      throw new Error(`Unknown texture wrap ${text}`);
  }
}
var TextureFilter = /* @__PURE__ */ ((TextureFilter2) => {
  TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
  TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
  TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
  TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
  TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
  TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
  TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
  return TextureFilter2;
})(TextureFilter || {});
var TextureWrap = /* @__PURE__ */ ((TextureWrap2) => {
  TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
  TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
  TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
  return TextureWrap2;
})(TextureWrap || {});
class TextureRegion {
  constructor() {
    // thats for overrides
    this.size = null;
    this.names = null;
    this.values = null;
    this.renderObject = null;
  }
  get width() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.width;
    }
    return tex.orig.width;
  }
  get height() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.height;
    }
    return tex.orig.height;
  }
  get u() {
    return this.texture._uvs.x0;
  }
  get v() {
    return this.texture._uvs.y0;
  }
  get u2() {
    return this.texture._uvs.x2;
  }
  get v2() {
    return this.texture._uvs.y2;
  }
  get offsetX() {
    const tex = this.texture;
    return tex.trim ? tex.trim.x : 0;
  }
  get offsetY() {
    return this.spineOffsetY;
  }
  get pixiOffsetY() {
    const tex = this.texture;
    return tex.trim ? tex.trim.y : 0;
  }
  get spineOffsetY() {
    const tex = this.texture;
    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
  }
  get originalWidth() {
    return this.texture.orig.width;
  }
  get originalHeight() {
    return this.texture.orig.height;
  }
  get x() {
    return this.texture.frame.x;
  }
  get y() {
    return this.texture.frame.y;
  }
  get rotate() {
    return this.texture.rotate !== 0;
  }
  get degrees() {
    return (360 - this.texture.rotate * 45) % 360;
  }
}


//# sourceMappingURL=TextureRegion.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/TextureAtlas.mjs



class RegionFields {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.originalWidth = 0;
    this.originalHeight = 0;
    this.rotate = 0;
    this.index = 0;
  }
}
class TextureAtlas {
  constructor(atlasText, textureLoader, callback) {
    this.pages = new Array();
    this.regions = new Array();
    if (atlasText) {
      this.addSpineAtlas(atlasText, textureLoader, callback);
    }
  }
  addTexture(name, texture) {
    const pages = this.pages;
    let page = null;
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].baseTexture === texture.baseTexture) {
        page = pages[i];
        break;
      }
    }
    if (page === null) {
      page = new TextureAtlasPage();
      page.name = "texturePage";
      const baseTexture = texture.baseTexture;
      page.width = baseTexture.realWidth;
      page.height = baseTexture.realHeight;
      page.baseTexture = baseTexture;
      page.minFilter = page.magFilter = TextureFilter.Nearest;
      page.uWrap = TextureWrap.ClampToEdge;
      page.vWrap = TextureWrap.ClampToEdge;
      pages.push(page);
    }
    const region = new TextureAtlasRegion();
    region.name = name;
    region.page = page;
    region.texture = texture;
    region.index = -1;
    this.regions.push(region);
    return region;
  }
  addTextureHash(textures, stripExtension) {
    for (const key in textures) {
      if (textures.hasOwnProperty(key)) {
        this.addTexture(stripExtension && key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key]);
      }
    }
  }
  addSpineAtlas(atlasText, textureLoader, callback) {
    return this.load(atlasText, textureLoader, callback);
  }
  load(atlasText, textureLoader, callback) {
    if (textureLoader == null) {
      throw new Error("textureLoader cannot be null.");
    }
    const reader = new TextureAtlasReader(atlasText);
    const entry = new Array(4);
    let page = null;
    const pageFields = {};
    let region = null;
    pageFields.size = () => {
      page.width = parseInt(entry[1]);
      page.height = parseInt(entry[2]);
    };
    pageFields.format = () => {
    };
    pageFields.filter = () => {
      page.minFilter = filterFromString(entry[1]);
      page.magFilter = filterFromString(entry[2]);
    };
    pageFields.repeat = () => {
      if (entry[1].indexOf("x") != -1)
        page.uWrap = TextureWrap.Repeat;
      if (entry[1].indexOf("y") != -1)
        page.vWrap = TextureWrap.Repeat;
    };
    pageFields.pma = () => {
      page.pma = entry[1] == "true";
    };
    const regionFields = {};
    regionFields.xy = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
    };
    regionFields.size = () => {
      region.width = parseInt(entry[1]);
      region.height = parseInt(entry[2]);
    };
    regionFields.bounds = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
      region.width = parseInt(entry[3]);
      region.height = parseInt(entry[4]);
    };
    regionFields.offset = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
    };
    regionFields.orig = () => {
      region.originalWidth = parseInt(entry[1]);
      region.originalHeight = parseInt(entry[2]);
    };
    regionFields.offsets = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
      region.originalWidth = parseInt(entry[3]);
      region.originalHeight = parseInt(entry[4]);
    };
    regionFields.rotate = () => {
      const rotateValue = entry[1];
      let rotate = 0;
      if (rotateValue.toLocaleLowerCase() == "true") {
        rotate = 6;
      } else if (rotateValue.toLocaleLowerCase() == "false") {
        rotate = 0;
      } else {
        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;
      }
      region.rotate = rotate;
    };
    regionFields.index = () => {
      region.index = parseInt(entry[1]);
    };
    let line = reader.readLine();
    while (line != null && line.trim().length == 0) {
      line = reader.readLine();
    }
    while (true) {
      if (line == null || line.trim().length == 0)
        break;
      if (reader.readEntry(entry, line) == 0)
        break;
      line = reader.readLine();
    }
    const iterateParser = () => {
      while (true) {
        if (line == null) {
          return callback && callback(this);
        }
        if (line.trim().length == 0) {
          page = null;
          line = reader.readLine();
        } else if (page === null) {
          page = new TextureAtlasPage();
          page.name = line.trim();
          while (true) {
            if (reader.readEntry(entry, line = reader.readLine()) == 0)
              break;
            const field = pageFields[entry[0]];
            if (field)
              field();
          }
          this.pages.push(page);
          textureLoader(page.name, (texture) => {
            if (texture === null) {
              this.pages.splice(this.pages.indexOf(page), 1);
              return callback && callback(null);
            }
            page.baseTexture = texture;
            if (page.pma) {
              texture.alphaMode = ALPHA_MODES.PMA;
            }
            if (!texture.valid) {
              texture.setSize(page.width, page.height);
            }
            page.setFilters();
            if (!page.width || !page.height) {
              page.width = texture.realWidth;
              page.height = texture.realHeight;
              if (!page.width || !page.height) {
                console.log(
                  `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`
                );
              }
            }
            iterateParser();
          });
          break;
        } else {
          region = new RegionFields();
          const atlasRegion = new TextureAtlasRegion();
          atlasRegion.name = line;
          atlasRegion.page = page;
          let names = null;
          let values = null;
          while (true) {
            const count = reader.readEntry(entry, line = reader.readLine());
            if (count == 0)
              break;
            const field = regionFields[entry[0]];
            if (field) {
              field();
            } else {
              if (names == null) {
                names = [];
                values = [];
              }
              names.push(entry[0]);
              const entryValues = [];
              for (let i = 0; i < count; i++) {
                entryValues.push(parseInt(entry[i + 1]));
              }
              values.push(entryValues);
            }
          }
          if (region.originalWidth == 0 && region.originalHeight == 0) {
            region.originalWidth = region.width;
            region.originalHeight = region.height;
          }
          const resolution = page.baseTexture.resolution;
          region.x /= resolution;
          region.y /= resolution;
          region.width /= resolution;
          region.height /= resolution;
          region.originalWidth /= resolution;
          region.originalHeight /= resolution;
          region.offsetX /= resolution;
          region.offsetY /= resolution;
          const swapWH = region.rotate % 4 !== 0;
          const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);
          const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);
          const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);
          atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);
          atlasRegion.index = region.index;
          atlasRegion.texture.updateUvs();
          this.regions.push(atlasRegion);
        }
      }
    };
    iterateParser();
  }
  findRegion(name) {
    for (let i = 0; i < this.regions.length; i++) {
      if (this.regions[i].name == name) {
        return this.regions[i];
      }
    }
    return null;
  }
  dispose() {
    for (let i = 0; i < this.pages.length; i++) {
      this.pages[i].baseTexture.dispose();
    }
  }
}
class TextureAtlasReader {
  constructor(text) {
    this.index = 0;
    this.lines = text.split(/\r\n|\r|\n/);
  }
  readLine() {
    if (this.index >= this.lines.length) {
      return null;
    }
    return this.lines[this.index++];
  }
  readEntry(entry, line) {
    if (line == null)
      return 0;
    line = line.trim();
    if (line.length == 0)
      return 0;
    const colon = line.indexOf(":");
    if (colon == -1)
      return 0;
    entry[0] = line.substr(0, colon).trim();
    for (let i = 1, lastMatch = colon + 1; ; i++) {
      const comma = line.indexOf(",", lastMatch);
      if (comma == -1) {
        entry[i] = line.substr(lastMatch).trim();
        return i;
      }
      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();
      lastMatch = comma + 1;
      if (i == 4)
        return 4;
    }
  }
}
class TextureAtlasPage {
  constructor() {
    this.minFilter = TextureFilter.Nearest;
    this.magFilter = TextureFilter.Nearest;
    this.uWrap = TextureWrap.ClampToEdge;
    this.vWrap = TextureWrap.ClampToEdge;
  }
  setFilters() {
    const tex = this.baseTexture;
    const filter = this.minFilter;
    if (filter == TextureFilter.Linear) {
      tex.scaleMode = SCALE_MODES.LINEAR;
    } else if (this.minFilter == TextureFilter.Nearest) {
      tex.scaleMode = SCALE_MODES.NEAREST;
    } else {
      tex.mipmap = MIPMAP_MODES.POW2;
      if (filter == TextureFilter.MipMapNearestNearest) {
        tex.scaleMode = SCALE_MODES.NEAREST;
      } else {
        tex.scaleMode = SCALE_MODES.LINEAR;
      }
    }
  }
}
class TextureAtlasRegion extends TextureRegion {
}


//# sourceMappingURL=TextureAtlas.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/Utils.mjs
class IntSet {
  constructor() {
    this.array = new Array();
  }
  add(value) {
    const contains = this.contains(value);
    this.array[value | 0] = value | 0;
    return !contains;
  }
  contains(value) {
    return this.array[value | 0] != void 0;
  }
  remove(value) {
    this.array[value | 0] = void 0;
  }
  clear() {
    this.array.length = 0;
  }
}
class StringSet {
  constructor() {
    this.entries = {};
    this.size = 0;
  }
  add(value) {
    const contains = this.entries[value];
    this.entries[value] = true;
    if (!contains) {
      this.size++;
      return true;
    }
    return false;
  }
  addAll(values) {
    const oldSize = this.size;
    for (let i = 0, n = values.length; i < n; i++) {
      this.add(values[i]);
    }
    return oldSize != this.size;
  }
  contains(value) {
    return this.entries[value];
  }
  clear() {
    this.entries = {};
    this.size = 0;
  }
}
const Utils_Color = class {
  constructor(r = 0, g = 0, b = 0, a = 0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  set(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this.clamp();
  }
  setFromColor(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    this.a = c.a;
    return this;
  }
  setFromString(hex) {
    hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
    this.r = parseInt(hex.substr(0, 2), 16) / 255;
    this.g = parseInt(hex.substr(2, 2), 16) / 255;
    this.b = parseInt(hex.substr(4, 2), 16) / 255;
    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;
    return this;
  }
  add(r, g, b, a) {
    this.r += r;
    this.g += g;
    this.b += b;
    this.a += a;
    return this.clamp();
  }
  clamp() {
    if (this.r < 0)
      this.r = 0;
    else if (this.r > 1)
      this.r = 1;
    if (this.g < 0)
      this.g = 0;
    else if (this.g > 1)
      this.g = 1;
    if (this.b < 0)
      this.b = 0;
    else if (this.b > 1)
      this.b = 1;
    if (this.a < 0)
      this.a = 0;
    else if (this.a > 1)
      this.a = 1;
    return this;
  }
  static rgba8888ToColor(color, value) {
    color.r = ((value & 4278190080) >>> 24) / 255;
    color.g = ((value & 16711680) >>> 16) / 255;
    color.b = ((value & 65280) >>> 8) / 255;
    color.a = (value & 255) / 255;
  }
  static rgb888ToColor(color, value) {
    color.r = ((value & 16711680) >>> 16) / 255;
    color.g = ((value & 65280) >>> 8) / 255;
    color.b = (value & 255) / 255;
  }
  static fromString(hex) {
    return new Utils_Color().setFromString(hex);
  }
};
let core_Utils_Color = Utils_Color;
core_Utils_Color.WHITE = new Utils_Color(1, 1, 1, 1);
core_Utils_Color.RED = new Utils_Color(1, 0, 0, 1);
core_Utils_Color.GREEN = new Utils_Color(0, 1, 0, 1);
core_Utils_Color.BLUE = new Utils_Color(0, 0, 1, 1);
core_Utils_Color.MAGENTA = new Utils_Color(1, 0, 1, 1);
const _MathUtils = class {
  static clamp(value, min, max) {
    if (value < min)
      return min;
    if (value > max)
      return max;
    return value;
  }
  static cosDeg(degrees) {
    return Math.cos(degrees * _MathUtils.degRad);
  }
  static sinDeg(degrees) {
    return Math.sin(degrees * _MathUtils.degRad);
  }
  static signum(value) {
    return Math.sign(value);
  }
  static toInt(x) {
    return x > 0 ? Math.floor(x) : Math.ceil(x);
  }
  static cbrt(x) {
    const y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  }
  static randomTriangular(min, max) {
    return _MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
  }
  static randomTriangularWith(min, max, mode) {
    const u = Math.random();
    const d = max - min;
    if (u <= (mode - min) / d)
      return min + Math.sqrt(u * d * (mode - min));
    return max - Math.sqrt((1 - u) * d * (max - mode));
  }
  static isPowerOfTwo(value) {
    return value && (value & value - 1) === 0;
  }
};
let MathUtils = _MathUtils;
MathUtils.PI = 3.1415927;
MathUtils.PI2 = _MathUtils.PI * 2;
MathUtils.radiansToDegrees = 180 / _MathUtils.PI;
MathUtils.radDeg = _MathUtils.radiansToDegrees;
MathUtils.degreesToRadians = _MathUtils.PI / 180;
MathUtils.degRad = _MathUtils.degreesToRadians;
class Interpolation {
  apply(start, end, a) {
    return start + (end - start) * this.applyInternal(a);
  }
}
class Pow extends (/* unused pure expression or super */ null && (Interpolation)) {
  constructor(power) {
    super();
    this.power = 2;
    this.power = power;
  }
  applyInternal(a) {
    if (a <= 0.5)
      return Math.pow(a * 2, this.power) / 2;
    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
  }
}
class PowOut extends (/* unused pure expression or super */ null && (Pow)) {
  applyInternal(a) {
    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
  }
}
const _Utils = class {
  static arrayCopy(source, sourceStart, dest, destStart, numElements) {
    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
      dest[j] = source[i];
    }
  }
  static arrayFill(array, fromIndex, toIndex, value) {
    for (let i = fromIndex; i < toIndex; i++) {
      array[i] = value;
    }
  }
  static setArraySize(array, size, value = 0) {
    const oldSize = array.length;
    if (oldSize == size)
      return array;
    array.length = size;
    if (oldSize < size) {
      for (let i = oldSize; i < size; i++)
        array[i] = value;
    }
    return array;
  }
  static ensureArrayCapacity(array, size, value = 0) {
    if (array.length >= size)
      return array;
    return _Utils.setArraySize(array, size, value);
  }
  static newArray(size, defaultValue) {
    const array = new Array(size);
    for (let i = 0; i < size; i++)
      array[i] = defaultValue;
    return array;
  }
  static newFloatArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Float32Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static newShortArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Int16Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static toFloatArray(array) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
  }
  static toSinglePrecision(value) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
  }
  // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109
  static webkit602BugfixHelper(alpha, blend) {
  }
  static contains(array, element, identity = true) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == element)
        return true;
    }
    return false;
  }
  static enumValue(type, name) {
    return type[name[0].toUpperCase() + name.slice(1)];
  }
};
let Utils_Utils = _Utils;
Utils_Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
class DebugUtils {
  static logBones(skeleton) {
    for (let i = 0; i < skeleton.bones.length; i++) {
      const bone = skeleton.bones[i];
      const mat = bone.matrix;
      console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);
    }
  }
}
class Utils_Pool {
  constructor(instantiator) {
    this.items = new Array();
    this.instantiator = instantiator;
  }
  obtain() {
    return this.items.length > 0 ? this.items.pop() : this.instantiator();
  }
  free(item) {
    if (item.reset)
      item.reset();
    this.items.push(item);
  }
  freeAll(items) {
    for (let i = 0; i < items.length; i++) {
      this.free(items[i]);
    }
  }
  clear() {
    this.items.length = 0;
  }
}
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  length() {
    const x = this.x;
    const y = this.y;
    return Math.sqrt(x * x + y * y);
  }
  normalize() {
    const len = this.length();
    if (len != 0) {
      this.x /= len;
      this.y /= len;
    }
    return this;
  }
}
class TimeKeeper {
  constructor() {
    this.maxDelta = 0.064;
    this.framesPerSecond = 0;
    this.delta = 0;
    this.totalTime = 0;
    this.lastTime = Date.now() / 1e3;
    this.frameCount = 0;
    this.frameTime = 0;
  }
  update() {
    const now = Date.now() / 1e3;
    this.delta = now - this.lastTime;
    this.frameTime += this.delta;
    this.totalTime += this.delta;
    if (this.delta > this.maxDelta)
      this.delta = this.maxDelta;
    this.lastTime = now;
    this.frameCount++;
    if (this.frameTime > 1) {
      this.framesPerSecond = this.frameCount / this.frameTime;
      this.frameTime = 0;
      this.frameCount = 0;
    }
  }
}
class WindowedMean {
  constructor(windowSize = 32) {
    this.addedValues = 0;
    this.lastValue = 0;
    this.mean = 0;
    this.dirty = true;
    this.values = new Array(windowSize);
  }
  hasEnoughData() {
    return this.addedValues >= this.values.length;
  }
  addValue(value) {
    if (this.addedValues < this.values.length)
      this.addedValues++;
    this.values[this.lastValue++] = value;
    if (this.lastValue > this.values.length - 1)
      this.lastValue = 0;
    this.dirty = true;
  }
  getMean() {
    if (this.hasEnoughData()) {
      if (this.dirty) {
        let mean = 0;
        for (let i = 0; i < this.values.length; i++) {
          mean += this.values[i];
        }
        this.mean = mean / this.values.length;
        this.dirty = false;
      }
      return this.mean;
    }
    return 0;
  }
}


//# sourceMappingURL=Utils.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/core/SkeletonBoundsBase.mjs



class SkeletonBoundsBase_SkeletonBoundsBase {
  constructor() {
    /** The left edge of the axis aligned bounding box. */
    this.minX = 0;
    /** The bottom edge of the axis aligned bounding box. */
    this.minY = 0;
    /** The right edge of the axis aligned bounding box. */
    this.maxX = 0;
    /** The top edge of the axis aligned bounding box. */
    this.maxY = 0;
    /** The visible bounding boxes. */
    this.boundingBoxes = new Array();
    /** The world vertices for the bounding box polygons. */
    this.polygons = new Array();
    this.polygonPool = new Pool(() => Utils.newFloatArray(16));
  }
  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding
   * box's polygon.
   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the
   *           SkeletonBounds AABB methods will always return true. */
  update(skeleton, updateAabb) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    const boundingBoxes = this.boundingBoxes;
    const polygons = this.polygons;
    const polygonPool = this.polygonPool;
    const slots = skeleton.slots;
    const slotCount = slots.length;
    boundingBoxes.length = 0;
    polygonPool.freeAll(polygons);
    polygons.length = 0;
    for (let i = 0; i < slotCount; i++) {
      const slot = slots[i];
      if (!slot.bone.active)
        continue;
      const attachment = slot.getAttachment();
      if (attachment != null && attachment.type === AttachmentType.BoundingBox) {
        const boundingBox = attachment;
        boundingBoxes.push(boundingBox);
        let polygon = polygonPool.obtain();
        if (polygon.length != boundingBox.worldVerticesLength) {
          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);
        }
        polygons.push(polygon);
        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
      }
    }
    if (updateAabb) {
      this.aabbCompute();
    } else {
      this.minX = Number.POSITIVE_INFINITY;
      this.minY = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.maxY = Number.NEGATIVE_INFINITY;
    }
  }
  aabbCompute() {
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      const polygon = polygons[i];
      const vertices = polygon;
      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {
        const x = vertices[ii];
        const y = vertices[ii + 1];
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /** Returns true if the axis aligned bounding box contains the point. */
  aabbContainsPoint(x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
  }
  /** Returns true if the axis aligned bounding box intersects the line segment. */
  aabbIntersectsSegment(x1, y1, x2, y2) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {
      return false;
    }
    const m = (y2 - y1) / (x2 - x1);
    let y = m * (minX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    y = m * (maxX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    let x = (minY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    x = (maxY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    return false;
  }
  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
  aabbIntersectsSkeleton(bounds) {
    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
  }
  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.
   * Cannot be done here because BoundingBoxAttachment is not a thing yet*/
  containsPoint(x, y) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.containsPointPolygon(polygons[i], x, y))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains the point. */
  containsPointPolygon(polygon, x, y) {
    const vertices = polygon;
    const nn = polygon.length;
    let prevIndex = nn - 2;
    let inside = false;
    for (let ii = 0; ii < nn; ii += 2) {
      const vertexY = vertices[ii + 1];
      const prevY = vertices[prevIndex + 1];
      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
        const vertexX = vertices[ii];
        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
          inside = !inside;
      }
      prevIndex = ii;
    }
    return inside;
  }
  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it
   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns
   * true. */
  intersectsSegment(x1, y1, x2, y2) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains any part of the line segment. */
  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {
    const vertices = polygon;
    const nn = polygon.length;
    const width12 = x1 - x2;
    const height12 = y1 - y2;
    const det1 = x1 * y2 - y1 * x2;
    let x3 = vertices[nn - 2];
    let y3 = vertices[nn - 1];
    for (let ii = 0; ii < nn; ii += 2) {
      const x4 = vertices[ii];
      const y4 = vertices[ii + 1];
      const det2 = x3 * y4 - y3 * x4;
      const width34 = x3 - x4;
      const height34 = y3 - y4;
      const det3 = width12 * height34 - height12 * width34;
      const x = (det1 * width34 - width12 * det2) / det3;
      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
        const y = (det1 * height34 - height12 * det2) / det3;
        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))
          return true;
      }
      x3 = x4;
      y3 = y4;
    }
    return false;
  }
  /** Returns the polygon for the specified bounding box, or null. */
  getPolygon(boundingBox) {
    if (!boundingBox)
      throw new Error("boundingBox cannot be null.");
    const index = this.boundingBoxes.indexOf(boundingBox);
    return index == -1 ? null : this.polygons[index];
  }
  /** The width of the axis aligned bounding box. */
  getWidth() {
    return this.maxX - this.minX;
  }
  /** The height of the axis aligned bounding box. */
  getHeight() {
    return this.maxY - this.minY;
  }
}


//# sourceMappingURL=SkeletonBoundsBase.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/settings.mjs
const settings_settings = {
  yDown: true,
  /**
   * pixi-spine gives option to not fail at certain parsing errors
   * spine-ts fails here
   */
  FAIL_ON_NON_EXISTING_SKIN: false,
  /**
   * past Spine.globalAutoUpdate
   */
  GLOBAL_AUTO_UPDATE: true,
  /**
   * past Spine.globalDelayLimit
   */
  GLOBAL_DELAY_LIMIT: 0,
  /**
   * shows error in console if atlas page loading somehow failed
   */
  REPORT_TEXTURE_LOADER_ERROR: true
};


//# sourceMappingURL=settings.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/SpineBase.mjs










const tempRgb = [0, 0, 0];
class SpineSprite extends Sprite {
  constructor() {
    super(...arguments);
    this.region = null;
    this.attachment = null;
  }
}
class SpineMesh extends SimpleMesh {
  constructor(texture, vertices, uvs, indices, drawMode) {
    super(texture, vertices, uvs, indices, drawMode);
    this.region = null;
    this.attachment = null;
  }
}
const _SpineBase = class extends Container_Container {
  constructor(spineData) {
    super();
    if (!spineData) {
      throw new Error("The spineData param is required.");
    }
    if (typeof spineData === "string") {
      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
    }
    this.spineData = spineData;
    this.createSkeleton(spineData);
    this.slotContainers = [];
    this.tempClipContainers = [];
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.newContainer();
      this.slotContainers.push(slotContainer);
      this.addChild(slotContainer);
      this.tempClipContainers.push(null);
      if (!attachment) {
        continue;
      }
      if (attachment.type === AttachmentType_AttachmentType.Region) {
        const spriteName = attachment.name;
        const sprite = this.createSprite(slot, attachment, spriteName);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
      } else if (attachment.type === AttachmentType_AttachmentType.Mesh) {
        const mesh = this.createMesh(slot, attachment);
        slot.currentMesh = mesh;
        slot.currentMeshId = attachment.id;
        slot.currentMeshName = attachment.name;
        slotContainer.addChild(mesh);
      } else if (attachment.type === AttachmentType_AttachmentType.Clipping) {
        this.createGraphics(slot, attachment);
        slotContainer.addChild(slot.clippingContainer);
        slotContainer.addChild(slot.currentGraphics);
      }
    }
    this.tintRgb = new Float32Array([1, 1, 1]);
    this.autoUpdate = true;
    this.visible = true;
  }
  get debug() {
    return this._debug;
  }
  set debug(value) {
    if (value == this._debug) {
      return;
    }
    this._debug?.unregisterSpine(this);
    value?.registerSpine(this);
    this._debug = value;
  }
  /**
   * If this flag is set to true, the spine animation will be automatically updated every
   * time the object id drawn. The down side of this approach is that the delta time is
   * automatically calculated and you could miss out on cool effects like slow motion,
   * pause, skip ahead and the sorts. Most of these effects can be achieved even with
   * autoUpdate enabled but are harder to achieve.
   *
   * @member {boolean}
   * @memberof spine.Spine#
   * @default true
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      this.updateTransform = value ? _SpineBase.prototype.autoUpdateTransform : Container_Container.prototype.updateTransform;
    }
  }
  /**
   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
   *
   * @member {number}
   * @memberof spine.Spine#
   * @default 0xFFFFFF
   */
  get tint() {
    return rgb2hex(this.tintRgb);
  }
  set tint(value) {
    this.tintRgb = hex2rgb(value, this.tintRgb);
  }
  /**
   * Limit value for the update dt with Spine.globalDelayLimit
   * that can be overridden with localDelayLimit
   * @return {number} - Maximum processed dt value for the update
   */
  get delayLimit() {
    const limit = typeof this.localDelayLimit !== "undefined" ? this.localDelayLimit : settings_settings.GLOBAL_DELAY_LIMIT;
    return limit || Number.MAX_VALUE;
  }
  /**
   * Update the spine skeleton and its animations by delta time (dt)
   *
   * @param dt {number} Delta time. Time by which the animation should be updated
   */
  update(dt) {
    const delayLimit = this.delayLimit;
    if (dt > delayLimit)
      dt = delayLimit;
    this.state.update(dt);
    this.state.apply(this.skeleton);
    if (!this.skeleton) {
      return;
    }
    this.skeleton.updateWorldTransform();
    const slots = this.skeleton.slots;
    const globalClr = this.color;
    let light = null;
    let dark = null;
    if (globalClr) {
      light = globalClr.light;
      dark = globalClr.dark;
    } else {
      light = this.tintRgb;
    }
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.slotContainers[i];
      if (!attachment) {
        slotContainer.visible = false;
        continue;
      }
      let spriteColor = null;
      if (attachment.sequence) {
        attachment.sequence.apply(slot, attachment);
      }
      let region = attachment.region;
      const attColor = attachment.color;
      switch (attachment != null && attachment.type) {
        case AttachmentType_AttachmentType.Region:
          const transform = slotContainer.transform;
          transform.setFromMatrix(slot.bone.matrix);
          region = attachment.region;
          if (slot.currentMesh) {
            slot.currentMesh.visible = false;
            slot.currentMesh = null;
            slot.currentMeshId = void 0;
            slot.currentMeshName = void 0;
          }
          if (!region) {
            if (slot.currentSprite) {
              slot.currentSprite.renderable = false;
            }
            break;
          }
          if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
            const spriteName = attachment.name;
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
            }
            slot.sprites = slot.sprites || {};
            if (slot.sprites[spriteName] !== void 0) {
              slot.sprites[spriteName].visible = true;
            } else {
              const sprite = this.createSprite(slot, attachment, spriteName);
              slotContainer.addChild(sprite);
            }
            slot.currentSprite = slot.sprites[spriteName];
            slot.currentSpriteName = spriteName;
          }
          slot.currentSprite.renderable = true;
          if (!slot.hackRegion) {
            this.setSpriteRegion(attachment, slot.currentSprite, region);
          }
          if (slot.currentSprite.color) {
            spriteColor = slot.currentSprite.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentSprite.tint = rgb2hex(tempRgb);
          }
          slot.currentSprite.blendMode = slot.blendMode;
          break;
        case AttachmentType_AttachmentType.Mesh:
          if (slot.currentSprite) {
            slot.currentSprite.visible = false;
            slot.currentSprite = null;
            slot.currentSpriteName = void 0;
            const transform2 = new Transform();
            transform2._parentID = -1;
            transform2._worldID = slotContainer.transform._worldID;
            slotContainer.transform = transform2;
          }
          if (!region) {
            if (slot.currentMesh) {
              slot.currentMesh.renderable = false;
            }
            break;
          }
          const id = attachment.id;
          if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {
            const meshId = id;
            if (slot.currentMesh) {
              slot.currentMesh.visible = false;
            }
            slot.meshes = slot.meshes || {};
            if (slot.meshes[meshId] !== void 0) {
              slot.meshes[meshId].visible = true;
            } else {
              const mesh = this.createMesh(slot, attachment);
              slotContainer.addChild(mesh);
            }
            slot.currentMesh = slot.meshes[meshId];
            slot.currentMeshName = attachment.name;
            slot.currentMeshId = meshId;
          }
          slot.currentMesh.renderable = true;
          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
          if (slot.currentMesh.color) {
            spriteColor = slot.currentMesh.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentMesh.tint = rgb2hex(tempRgb);
          }
          slot.currentMesh.blendMode = slot.blendMode;
          if (!slot.hackRegion) {
            this.setMeshRegion(attachment, slot.currentMesh, region);
          }
          break;
        case AttachmentType_AttachmentType.Clipping:
          if (!slot.currentGraphics) {
            this.createGraphics(slot, attachment);
            slotContainer.addChild(slot.clippingContainer);
            slotContainer.addChild(slot.currentGraphics);
          }
          this.updateGraphics(slot, attachment);
          slotContainer.alpha = 1;
          slotContainer.visible = true;
          continue;
        default:
          slotContainer.visible = false;
          continue;
      }
      slotContainer.visible = true;
      if (spriteColor) {
        let r0 = slot.color.r * attColor.r;
        let g0 = slot.color.g * attColor.g;
        let b0 = slot.color.b * attColor.b;
        spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
        if (slot.darkColor) {
          r0 = slot.darkColor.r;
          g0 = slot.darkColor.g;
          b0 = slot.darkColor.b;
        } else {
          r0 = 0;
          g0 = 0;
          b0 = 0;
        }
        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
      }
      slotContainer.alpha = slot.color.a;
    }
    const drawOrder = this.skeleton.drawOrder;
    let clippingAttachment = null;
    let clippingContainer = null;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = slots[drawOrder[i].data.index];
      const slotContainer = this.slotContainers[drawOrder[i].data.index];
      if (!clippingContainer) {
        if (slotContainer.parent !== null && slotContainer.parent !== this) {
          slotContainer.parent.removeChild(slotContainer);
          slotContainer.parent = this;
        }
      }
      if (slot.currentGraphics && slot.getAttachment()) {
        clippingContainer = slot.clippingContainer;
        clippingAttachment = slot.getAttachment();
        clippingContainer.children.length = 0;
        this.children[i] = slotContainer;
        if (clippingAttachment.endSlot === slot.data) {
          clippingAttachment.endSlot = null;
        }
      } else if (clippingContainer) {
        let c = this.tempClipContainers[i];
        if (!c) {
          c = this.tempClipContainers[i] = this.newContainer();
          c.visible = false;
        }
        this.children[i] = c;
        slotContainer.parent = null;
        clippingContainer.addChild(slotContainer);
        if (clippingAttachment.endSlot == slot.data) {
          clippingContainer.renderable = true;
          clippingContainer = null;
          clippingAttachment = null;
        }
      } else {
        this.children[i] = slotContainer;
      }
    }
    this._debug?.renderDebug(this);
  }
  setSpriteRegion(attachment, sprite, region) {
    if (sprite.attachment === attachment && sprite.region === region) {
      return;
    }
    sprite.region = region;
    sprite.attachment = attachment;
    sprite.texture = region.texture;
    sprite.rotation = attachment.rotation * MathUtils.degRad;
    sprite.position.x = attachment.x;
    sprite.position.y = attachment.y;
    sprite.alpha = attachment.color.a;
    if (!region.size) {
      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
    } else {
      sprite.scale.x = region.size.width / region.originalWidth;
      sprite.scale.y = -region.size.height / region.originalHeight;
    }
  }
  setMeshRegion(attachment, mesh, region) {
    if (mesh.attachment === attachment && mesh.region === region) {
      return;
    }
    mesh.region = region;
    mesh.attachment = attachment;
    mesh.texture = region.texture;
    region.texture.updateUvs();
    mesh.uvBuffer.update(attachment.regionUVs);
  }
  /**
   * When autoupdate is set to yes this function is used as pixi's updateTransform function
   *
   * @private
   */
  autoUpdateTransform() {
    if (settings_settings.GLOBAL_AUTO_UPDATE) {
      this.lastTime = this.lastTime || Date.now();
      const timeDelta = (Date.now() - this.lastTime) * 1e-3;
      this.lastTime = Date.now();
      this.update(timeDelta);
    } else {
      this.lastTime = 0;
    }
    Container_Container.prototype.updateTransform.call(this);
  }
  /**
   * Create a new sprite to be used with core.RegionAttachment
   *
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createSprite(slot, attachment, defName) {
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
    }
    const texture = region ? region.texture : null;
    const sprite = this.newSprite(texture);
    sprite.anchor.set(0.5);
    if (region) {
      this.setSpriteRegion(attachment, sprite, attachment.region);
    }
    slot.sprites = slot.sprites || {};
    slot.sprites[defName] = sprite;
    return sprite;
  }
  /**
   * Creates a Strip from the spine data
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createMesh(slot, attachment) {
    if (!attachment.region && attachment.sequence) {
      attachment.sequence.apply(slot, attachment);
    }
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
      slot.hackAttachment = null;
      slot.hackRegion = null;
    }
    const strip = this.newMesh(
      region ? region.texture : null,
      new Float32Array(attachment.regionUVs.length),
      attachment.regionUVs,
      new Uint16Array(attachment.triangles),
      DRAW_MODES.TRIANGLES
    );
    if (typeof strip._canvasPadding !== "undefined") {
      strip._canvasPadding = 1.5;
    }
    strip.alpha = attachment.color.a;
    strip.region = attachment.region;
    if (region) {
      this.setMeshRegion(attachment, strip, region);
    }
    slot.meshes = slot.meshes || {};
    slot.meshes[attachment.id] = strip;
    return strip;
  }
  // @ts-ignore
  createGraphics(slot, clip) {
    const graphics = this.newGraphics();
    const poly = new Polygon([]);
    graphics.clear();
    graphics.beginFill(16777215, 1);
    graphics.drawPolygon(poly);
    graphics.renderable = false;
    slot.currentGraphics = graphics;
    slot.clippingContainer = this.newContainer();
    slot.clippingContainer.mask = slot.currentGraphics;
    return graphics;
  }
  updateGraphics(slot, clip) {
    const geom = slot.currentGraphics.geometry;
    const vertices = geom.graphicsData[0].shape.points;
    const n = clip.worldVerticesLength;
    vertices.length = n;
    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
    geom.invalidate();
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotIndex {number}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const attachment = slot.getAttachment();
    let region = attachment.region;
    if (texture) {
      region = new TextureRegion();
      region.texture = texture;
      region.size = size;
      slot.hackRegion = region;
      slot.hackAttachment = attachment;
    } else {
      slot.hackRegion = null;
      slot.hackAttachment = null;
    }
    if (slot.currentSprite) {
      this.setSpriteRegion(attachment, slot.currentSprite, region);
    } else if (slot.currentMesh) {
      this.setMeshRegion(attachment, slot.currentMesh, region);
    }
    return true;
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotName(slotName, texture = null, size = null) {
    const index = this.skeleton.findSlotIndex(slotName);
    if (index == -1) {
      return false;
    }
    return this.hackTextureBySlotIndex(index, texture, size);
  }
  /**
   * Changes texture of an attachment
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param attachmentName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureAttachment(slotName, attachmentName, texture, size = null) {
    const slotIndex = this.skeleton.findSlotIndex(slotName);
    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);
    attachment.region.texture = texture;
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const currentAttachment = slot.getAttachment();
    if (attachmentName === currentAttachment.name) {
      let region = attachment.region;
      if (texture) {
        region = new TextureRegion();
        region.texture = texture;
        region.size = size;
        slot.hackRegion = region;
        slot.hackAttachment = currentAttachment;
      } else {
        slot.hackRegion = null;
        slot.hackAttachment = null;
      }
      if (slot.currentSprite && slot.currentSprite.region != region) {
        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);
        slot.currentSprite.region = region;
      } else if (slot.currentMesh && slot.currentMesh.region != region) {
        this.setMeshRegion(currentAttachment, slot.currentMesh, region);
      }
      return true;
    }
    return false;
  }
  // those methods can be overriden to spawn different classes
  newContainer() {
    return new Container_Container();
  }
  newSprite(tex) {
    return new SpineSprite(tex);
  }
  newGraphics() {
    return new Graphics_Graphics();
  }
  newMesh(texture, vertices, uvs, indices, drawMode) {
    return new SpineMesh(texture, vertices, uvs, indices, drawMode);
  }
  transformHack() {
    return 1;
  }
  /**
   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer
   * @param nameSuffix
   * @param group
   * @param outGroup
   */
  hackAttachmentGroups(nameSuffix, group, outGroup) {
    if (!nameSuffix) {
      return void 0;
    }
    const list_d = [];
    const list_n = [];
    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {
      const slot = this.skeleton.slots[i];
      const name = slot.currentSpriteName || slot.currentMeshName || "";
      const target = slot.currentSprite || slot.currentMesh;
      if (name.endsWith(nameSuffix)) {
        target.parentGroup = group;
        list_n.push(target);
      } else if (outGroup && target) {
        target.parentGroup = outGroup;
        list_d.push(target);
      }
    }
    return [list_d, list_n];
  }
  destroy(options) {
    this.debug = null;
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      for (const name in slot.meshes) {
        slot.meshes[name].destroy(options);
      }
      slot.meshes = null;
      for (const name in slot.sprites) {
        slot.sprites[name].destroy(options);
      }
      slot.sprites = null;
    }
    for (let i = 0, n = this.slotContainers.length; i < n; i++) {
      this.slotContainers[i].destroy(options);
    }
    this.spineData = null;
    this.skeleton = null;
    this.slotContainers = null;
    this.stateData = null;
    this.state = null;
    this.tempClipContainers = null;
    super.destroy(options);
  }
};
let SpineBase = _SpineBase;
SpineBase.clippingPolygon = [];
Object.defineProperty(SpineBase.prototype, "visible", {
  get() {
    return this._visible;
  },
  set(value) {
    if (value !== this._visible) {
      this._visible = value;
      if (value) {
        this.lastTime = 0;
      }
    }
  }
});


//# sourceMappingURL=SpineBase.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/SpineDebugRenderer.mjs





class SpineDebugRenderer {
  constructor() {
    this.registeredSpines = /* @__PURE__ */ new Map();
    this.drawDebug = true;
    this.drawMeshHull = true;
    this.drawMeshTriangles = true;
    this.drawBones = true;
    this.drawPaths = true;
    this.drawBoundingBoxes = true;
    this.drawClipping = true;
    this.drawRegionAttachments = true;
    this.lineWidth = 1;
    this.regionAttachmentsColor = 30975;
    this.meshHullColor = 30975;
    this.meshTrianglesColor = 16763904;
    this.clippingPolygonColor = 16711935;
    this.boundingBoxesRectColor = 65280;
    this.boundingBoxesPolygonColor = 65280;
    this.boundingBoxesCircleColor = 65280;
    this.pathsCurveColor = 16711680;
    this.pathsLineColor = 16711935;
    this.skeletonXYColor = 16711680;
    this.bonesColor = 61132;
  }
  /**
   * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update
   */
  registerSpine(spine) {
    if (this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!", spine);
    }
    const debugDisplayObjects = {
      parentDebugContainer: new Container(),
      bones: new Container(),
      skeletonXY: new Graphics(),
      regionAttachmentsShape: new Graphics(),
      meshTrianglesLine: new Graphics(),
      meshHullLine: new Graphics(),
      clippingPolygon: new Graphics(),
      boundingBoxesRect: new Graphics(),
      boundingBoxesCircle: new Graphics(),
      boundingBoxesPolygon: new Graphics(),
      pathsCurve: new Graphics(),
      pathsLine: new Graphics()
    };
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);
    spine.addChild(debugDisplayObjects.parentDebugContainer);
    this.registeredSpines.set(spine, debugDisplayObjects);
  }
  renderDebug(spine) {
    if (!this.registeredSpines.has(spine)) {
      this.registerSpine(spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.skeletonXY.clear();
    debugDisplayObjects.regionAttachmentsShape.clear();
    debugDisplayObjects.meshTrianglesLine.clear();
    debugDisplayObjects.meshHullLine.clear();
    debugDisplayObjects.clippingPolygon.clear();
    debugDisplayObjects.boundingBoxesRect.clear();
    debugDisplayObjects.boundingBoxesCircle.clear();
    debugDisplayObjects.boundingBoxesPolygon.clear();
    debugDisplayObjects.pathsCurve.clear();
    debugDisplayObjects.pathsLine.clear();
    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {
      debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });
    }
    const scale = spine.scale.x || spine.scale.y || 1;
    const lineWidth = this.lineWidth / scale;
    if (this.drawBones) {
      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);
    }
    if (this.drawPaths) {
      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawBoundingBoxes) {
      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawClipping) {
      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawMeshHull || this.drawMeshTriangles) {
      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawRegionAttachments) {
      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);
    }
  }
  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {
    const skeleton = spine.skeleton;
    const skeletonX = skeleton.x;
    const skeletonY = skeleton.y;
    const bones = skeleton.bones;
    debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);
    for (let i = 0, len = bones.length; i < len; i++) {
      const bone = bones[i];
      const boneLen = bone.data.length;
      const starX = skeletonX + bone.matrix.tx;
      const starY = skeletonY + bone.matrix.ty;
      const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;
      const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;
      if (bone.data.name === "root" || bone.data.parent === null) {
        continue;
      }
      const w = Math.abs(starX - endX);
      const h = Math.abs(starY - endY);
      const a2 = Math.pow(w, 2);
      const b = h;
      const b2 = Math.pow(h, 2);
      const c = Math.sqrt(a2 + b2);
      const c2 = Math.pow(c, 2);
      const rad = Math.PI / 180;
      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;
      if (c === 0) {
        continue;
      }
      const gp = new Graphics();
      debugDisplayObjects.bones.addChild(gp);
      const refRation = c / 50 / scale;
      gp.beginFill(this.bonesColor, 1);
      gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);
      gp.endFill();
      gp.x = starX;
      gp.y = starY;
      gp.pivot.y = c;
      let rotation = 0;
      if (starX < endX && starY < endY) {
        rotation = -B + 180 * rad;
      } else if (starX > endX && starY < endY) {
        rotation = 180 * rad + B;
      } else if (starX > endX && starY > endY) {
        rotation = -B;
      } else if (starX < endX && starY > endY) {
        rotation = B;
      } else if (starY === endY && starX < endX) {
        rotation = 90 * rad;
      } else if (starY === endY && starX > endX) {
        rotation = -90 * rad;
      } else if (starX === endX && starY < endY) {
        rotation = 180 * rad;
      } else if (starX === endX && starY > endY) {
        rotation = 0;
      }
      gp.rotation = rotation;
      gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);
      gp.beginFill(0, 0.6);
      gp.drawCircle(0, c, refRation * 1.2);
      gp.endFill();
    }
    const startDotSize = lineWidth * 3;
    debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);
    debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);
  }
  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Region) {
        continue;
      }
      const regionAttachment = attachment;
      const vertices = new Float32Array(8);
      if (regionAttachment.updateOffset)
        regionAttachment.updateOffset();
      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);
      debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));
    }
  }
  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);
    debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Mesh) {
        continue;
      }
      const meshAttachment = attachment;
      const vertices = new Float32Array(meshAttachment.worldVerticesLength);
      const triangles = meshAttachment.triangles;
      let hullLength = meshAttachment.hullLength;
      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);
      if (this.drawMeshTriangles) {
        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {
          const v1 = triangles[i2] * 2;
          const v2 = triangles[i2 + 1] * 2;
          const v3 = triangles[i2 + 2] * 2;
          debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);
        }
      }
      if (this.drawMeshHull && hullLength > 0) {
        hullLength = (hullLength >> 1) * 2;
        let lastX = vertices[hullLength - 2];
        let lastY = vertices[hullLength - 1];
        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {
          const x = vertices[i2];
          const y = vertices[i2 + 1];
          debugDisplayObjects.meshHullLine.moveTo(x, y);
          debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);
          lastX = x;
          lastY = y;
        }
      }
    }
  }
  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Clipping) {
        continue;
      }
      const clippingAttachment = attachment;
      const nn = clippingAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));
    }
  }
  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {
    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);
    const bounds = new SkeletonBoundsBase();
    bounds.update(spine.skeleton, true);
    debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
    const polygons = bounds.polygons;
    const drawPolygon = (polygonVertices, _offset, count) => {
      debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);
      debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);
      if (count < 3) {
        throw new Error("Polygon must contain at least 3 vertices");
      }
      const paths = [];
      const dotSize = lineWidth * 2;
      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {
        const x1 = polygonVertices[i];
        const y1 = polygonVertices[i + 1];
        debugDisplayObjects.boundingBoxesCircle.lineStyle(0);
        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);
        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);
        debugDisplayObjects.boundingBoxesCircle.endFill();
        paths.push(x1, y1);
      }
      debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);
      debugDisplayObjects.boundingBoxesPolygon.endFill();
    };
    for (let i = 0, len = polygons.length; i < len; i++) {
      const polygon = polygons[i];
      drawPolygon(polygon, 0, polygon.length);
    }
  }
  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);
    debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Path) {
        continue;
      }
      const pathAttachment = attachment;
      let nn = pathAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      let x1 = world[2];
      let y1 = world[3];
      let x2 = 0;
      let y2 = 0;
      if (pathAttachment.closed) {
        const cx1 = world[0];
        const cy1 = world[1];
        const cx2 = world[nn - 2];
        const cy2 = world[nn - 1];
        x2 = world[nn - 4];
        y2 = world[nn - 3];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
      }
      nn -= 4;
      for (let ii = 4; ii < nn; ii += 6) {
        const cx1 = world[ii];
        const cy1 = world[ii + 1];
        const cx2 = world[ii + 2];
        const cy2 = world[ii + 3];
        x2 = world[ii + 4];
        y2 = world[ii + 5];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
        x1 = x2;
        y1 = y2;
      }
    }
  }
  unregisterSpine(spine) {
    if (!this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!", spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });
    this.registeredSpines.delete(spine);
  }
}


//# sourceMappingURL=SpineDebugRenderer.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/base/lib/index.mjs












//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/loader-base/lib/atlasLoader.mjs




const spineTextureAtlasLoader = {
  extension: ExtensionType.Asset,
  // cache: {
  //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,
  //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),
  // },
  loader: {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    test(url) {
      return checkExtension(url, ".atlas");
    },
    async load(url) {
      const response = await settings.ADAPTER.fetch(url);
      const txt = await response.text();
      return txt;
    },
    testParse(asset, options) {
      const isExtensionRight = checkExtension(options.src, ".atlas");
      const isString = typeof asset === "string";
      return Promise.resolve(isExtensionRight && isString);
    },
    async parse(asset, options, loader) {
      const metadata = options.data;
      let basePath = path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let resolve = null;
      let reject = null;
      const retPromise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      let retval;
      const resolveCallback = (newAtlas) => {
        if (!newAtlas) {
          reject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
        }
        resolve(retval);
      };
      if (metadata.image || metadata.images) {
        const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);
        retval = new TextureAtlas(
          asset,
          (line, callback) => {
            const page = pages[line] || pages.default;
            if (page && page.baseTexture)
              callback(page.baseTexture);
            else
              callback(page);
          },
          resolveCallback
        );
      } else {
        retval = new TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);
      }
      return await retPromise;
    },
    unload(atlas) {
      atlas.dispose();
    }
  }
};
const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata) => {
  return async (pageName, textureLoadedCallback) => {
    try {
      const url = path.normalize([...atlasBasePath.split(path.sep), pageName].join(path.sep));
      const texture = await loader.load({ src: url, data: imageMetadata });
      textureLoadedCallback(texture.baseTexture);
    } catch (e) {
      if (settings_settings.REPORT_TEXTURE_LOADER_ERROR) {
        console.error("Spine: error in texture loader", e);
      }
      textureLoadedCallback(null);
    }
  };
};
extensions.add(spineTextureAtlasLoader);


//# sourceMappingURL=atlasLoader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/loader-base/lib/SpineLoaderAbstract.mjs





function isJson(resource) {
  return resource.hasOwnProperty("bones");
}
function SpineLoaderAbstract_isBuffer(resource) {
  return resource instanceof ArrayBuffer;
}
class SpineLoaderAbstract {
  constructor() {
  }
  installLoader() {
    const spineAdapter = this;
    const spineLoaderExtension = {
      extension: ExtensionType.Asset,
      loader: {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        // #region Downloading skel buffer data
        test(url) {
          return checkExtension(url, ".skel");
        },
        async load(url) {
          const response = await settings.ADAPTER.fetch(url);
          const buffer = await response.arrayBuffer();
          return buffer;
        },
        // #endregion
        // #region Parsing spine data
        testParse(asset, options) {
          const isJsonSpineModel = checkExtension(options.src, ".json") && isJson(asset);
          const isBinarySpineModel = checkExtension(options.src, ".skel") && SpineLoaderAbstract_isBuffer(asset);
          const isMetadataAngry = options.data?.spineAtlas === false;
          return Promise.resolve(isJsonSpineModel && !isMetadataAngry || isBinarySpineModel);
        },
        async parse(asset, loadAsset, loader) {
          const fileExt = path.extname(loadAsset.src).toLowerCase();
          const fileName = path.basename(loadAsset.src, fileExt);
          let basePath = path.dirname(loadAsset.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          const isJsonSpineModel = checkExtension(loadAsset.src, ".json") && isJson(asset);
          let parser = null;
          let dataToParse = asset;
          if (isJsonSpineModel) {
            parser = spineAdapter.createJsonParser();
          } else {
            parser = spineAdapter.createBinaryParser();
            dataToParse = new Uint8Array(asset);
          }
          const metadata = loadAsset.data || {};
          const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;
          if (metadataSkeletonScale) {
            parser.scale = metadataSkeletonScale;
          }
          const metadataAtlas = metadata.spineAtlas;
          if (metadataAtlas && metadataAtlas.pages) {
            return spineAdapter.parseData(parser, metadataAtlas, dataToParse);
          }
          const textAtlas = metadata.atlasRawData;
          if (textAtlas) {
            let auxResolve = null;
            let auxReject = null;
            const atlasPromise = new Promise((resolve, reject) => {
              auxResolve = resolve;
              auxReject = reject;
            });
            const atlas = new TextureAtlas(textAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), (newAtlas) => {
              if (!newAtlas) {
                auxReject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
              }
              auxResolve(atlas);
            });
            const textureAtlas2 = await atlasPromise;
            return spineAdapter.parseData(parser, textureAtlas2, dataToParse);
          }
          let atlasPath = metadata.spineAtlasFile;
          if (!atlasPath) {
            atlasPath = `${basePath + fileName}.atlas`;
          }
          const textureAtlas = await loader.load({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });
          return spineAdapter.parseData(parser, textureAtlas, dataToParse);
        }
        // #endregion
        // unload(asset: ISpineResource<SKD>, loadAsset, loader) {
        // 	???
        // },
      }
    };
    extensions.add(spineLoaderExtension);
    return spineLoaderExtension;
  }
}


//# sourceMappingURL=SpineLoaderAbstract.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/loader-base/lib/index.mjs


//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs


class Attachment {
  constructor(name) {
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    /** The unique ID for this attachment. */
    this.id = _VertexAttachment.nextID++;
    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting
     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null
     * if this attachment has no weights. */
    this.bones = null;
    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`
     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting
     * each vertex. */
    this.vertices = [];
    /** The maximum number of world vertex values that can be output by
     * {@link #computeWorldVertices()} using the `count` parameter. */
    this.worldVerticesLength = 0;
    /** Timelines for the timeline attachment are also applied to this attachment.
     * May be null if no attachment-specific timelines should be applied. */
    this.timelineAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is
   * not empty, it is used to deform the vertices.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide.
   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.
   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *
   *           `stride` / 2.
   * @param offset The `worldVertices` index to begin writing values.
   * @param stride The number of `worldVertices` entries between the value pairs written. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (!bones) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Does not copy id (generated) or name (set on construction). **/
  copyTo(attachment) {
    if (this.bones) {
      attachment.bones = new Array(this.bones.length);
      Utils_Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices) {
      attachment.vertices = Utils_Utils.newFloatArray(this.vertices.length);
      Utils_Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    }
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.timelineAttachment = this.timelineAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;


//# sourceMappingURL=Attachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs



class BoundingBoxAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType_AttachmentType.BoundingBox;
    this.color = new core_Utils_Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=BoundingBoxAttachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs



class ClippingAttachment extends VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = AttachmentType_AttachmentType.Clipping;
    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of
     * the skeleton's rendering. */
    this.endSlot = null;
    // Nonessential.
    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons
     * are not usually rendered at runtime. */
    this.color = new core_Utils_Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=ClippingAttachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs



class MeshAttachment extends VertexAttachment {
  constructor(name, path) {
    super(name);
    this.type = AttachmentType_AttachmentType.Mesh;
    this.region = null;
    /** Triplets of vertex indices which describe the mesh's triangulation. */
    this.triangles = [];
    /** The color to tint the mesh. */
    this.color = new core_Utils_Color(1, 1, 1, 1);
    /** The width of the mesh's image. Available only when nonessential data was exported. */
    this.width = 0;
    /** The height of the mesh's image. Available only when nonessential data was exported. */
    this.height = 0;
    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */
    this.hullLength = 0;
    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if
     * nonessential data was exported. Triangulation is not performed at runtime. */
    this.edges = [];
    this.parentMesh = null;
    this.sequence = null;
    this.tempColor = new core_Utils_Color(0, 0, 0, 0);
    this.path = path;
  }
  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},
   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the
   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh)
      return this.newLinkedMesh();
    const copy = new MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    Utils_Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    Utils_Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    if (this.edges) {
      copy.edges = new Array(this.edges.length);
      Utils_Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);
  }
  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/
  newLinkedMesh() {
    const copy = new MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    copy.timelineAttachment = this.timelineAttachment;
    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);
    return copy;
  }
}


//# sourceMappingURL=MeshAttachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs



class PathAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType_AttachmentType.Path;
    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */
    this.lengths = [];
    /** If true, the start and end knots are connected. */
    this.closed = false;
    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer
     * calculations are performed but calculating positions along the path is less accurate. */
    this.constantSpeed = false;
    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually
     * rendered at runtime. */
    this.color = new core_Utils_Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    Utils_Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=PathAttachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PointAttachment.mjs



class PointAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType_AttachmentType.Point;
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments
     * are not usually rendered at runtime. */
    this.color = new core_Utils_Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = MathUtils.cosDeg(this.rotation);
    const sin = MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * MathUtils.radDeg;
  }
  copy() {
    const copy = new PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=PointAttachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs



const _RegionAttachment = class extends Attachment {
  constructor(name, path) {
    super(name);
    this.type = AttachmentType_AttachmentType.Region;
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local scaleX. */
    this.scaleX = 1;
    /** The local scaleY. */
    this.scaleY = 1;
    /** The local rotation. */
    this.rotation = 0;
    /** The width of the region attachment in Spine. */
    this.width = 0;
    /** The height of the region attachment in Spine. */
    this.height = 0;
    /** The color to tint the region attachment. */
    this.color = new core_Utils_Color(1, 1, 1, 1);
    this.rendererObject = null;
    this.region = null;
    this.sequence = null;
    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.
     *
     * See {@link #updateOffset()}. */
    this.offset = Utils_Utils.newFloatArray(8);
    this.uvs = Utils_Utils.newFloatArray(8);
    this.tempColor = new core_Utils_Color(1, 1, 1, 1);
    this.path = path;
  }
  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */
  updateRegion() {
    if (!this.region)
      throw new Error("Region not set.");
    const region = this.region;
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const x = this.x;
    const y = this.y;
    const localXCos = localX * cos + x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[0] = localXCos - localYSin;
    offset[1] = localYCos + localXSin;
    offset[2] = localXCos - localY2Sin;
    offset[3] = localY2Cos + localXSin;
    offset[4] = localX2Cos - localY2Sin;
    offset[5] = localY2Cos + localX2Sin;
    offset[6] = localX2Cos - localYSin;
    offset[7] = localYCos + localX2Sin;
    const uvs = this.uvs;
    if (region.degrees == 90) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may
   * be changed.
   * <p>
   * See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
   * Runtimes Guide.
   * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.
   * @param offset The <code>worldVertices</code> index to begin writing values.
   * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */
  computeWorldVertices(slot, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    const bone = slot.bone;
    const vertexOffset = this.offset;
    const mat = bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[0];
    offsetY = vertexOffset[1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[2];
    offsetY = vertexOffset[3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[4];
    offsetY = vertexOffset[5];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[6];
    offsetY = vertexOffset[7];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment(this.name, this.path);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    Utils_Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    Utils_Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    return copy;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;


//# sourceMappingURL=RegionAttachment.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs


const _Sequence = class {
  constructor(count) {
    this.id = _Sequence.nextID();
    this.start = 0;
    this.digits = 0;
    /** The index of the region to show for the setup pose. */
    this.setupIndex = 0;
    this.regions = new Array(count);
  }
  copy() {
    const copy = new _Sequence(this.regions.length);
    Utils_Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);
    copy.start = this.start;
    copy.digits = this.digits;
    copy.setupIndex = this.setupIndex;
    return copy;
  }
  apply(slot, attachment) {
    let index = slot.sequenceIndex;
    if (index == -1)
      index = this.setupIndex;
    if (index >= this.regions.length)
      index = this.regions.length - 1;
    const region = this.regions[index];
    if (attachment.region != region) {
      attachment.region = region;
    }
  }
  getPath(basePath, index) {
    let result = basePath;
    const frame = (this.start + index).toString();
    for (let i = this.digits - frame.length; i > 0; i--)
      result += "0";
    result += frame;
    return result;
  }
  static nextID() {
    return _Sequence._nextID++;
  }
};
let Sequence = _Sequence;
Sequence._nextID = 0;
var SequenceMode = /* @__PURE__ */ ((SequenceMode2) => {
  SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
  SequenceMode2[SequenceMode2["once"] = 1] = "once";
  SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
  SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
  SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
  SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
  SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
  return SequenceMode2;
})(SequenceMode || {});
const SequenceModeValues = [
  0 /* hold */,
  1 /* once */,
  2 /* loop */,
  3 /* pingpong */,
  4 /* onceReverse */,
  5 /* loopReverse */,
  6 /* pingpongReverse */
];


//# sourceMappingURL=Sequence.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs





class Animation {
  constructor(name, timelines, duration) {
    this.timelines = [];
    this.timelineIds = new StringSet();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
    this.setTimelines(timelines);
    this.duration = duration;
  }
  setTimelines(timelines) {
    if (!timelines)
      throw new Error("timelines cannot be null.");
    this.timelines = timelines;
    this.timelineIds.clear();
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds.addAll(timelines[i].getPropertyIds());
  }
  hasTimeline(ids) {
    for (let i = 0; i < ids.length; i++)
      if (this.timelineIds.contains(ids[i]))
        return true;
    return false;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
}
const Property = {
  rotate: 0,
  x: 1,
  y: 2,
  scaleX: 3,
  scaleY: 4,
  shearX: 5,
  shearY: 6,
  rgb: 7,
  alpha: 8,
  rgb2: 9,
  attachment: 10,
  deform: 11,
  event: 12,
  drawOrder: 13,
  ikConstraint: 14,
  transformConstraint: 15,
  pathConstraintPosition: 16,
  pathConstraintSpacing: 17,
  pathConstraintMix: 18,
  sequence: 19
};
class Timeline {
  constructor(frameCount, propertyIds) {
    this.propertyIds = propertyIds;
    this.frames = Utils_Utils.newFloatArray(frameCount * this.getFrameEntries());
  }
  getPropertyIds() {
    return this.propertyIds;
  }
  getFrameEntries() {
    return 1;
  }
  getFrameCount() {
    return this.frames.length / this.getFrameEntries();
  }
  getDuration() {
    return this.frames[this.frames.length - this.getFrameEntries()];
  }
  static search1(frames, time) {
    const n = frames.length;
    for (let i = 1; i < n; i++)
      if (frames[i] > time)
        return i - 1;
    return n - 1;
  }
  static search(frames, time, step) {
    const n = frames.length;
    for (let i = step; i < n; i += step)
      if (frames[i] > time)
        return i - step;
    return n - step;
  }
}
class CurveTimeline extends Timeline {
  // type, x, y, ...
  constructor(frameCount, bezierCount, propertyIds) {
    super(frameCount, propertyIds);
    this.curves = Utils_Utils.newFloatArray(
      frameCount + bezierCount * 18
      /* BEZIER_SIZE*/
    );
    this.curves[frameCount - 1] = 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frame) {
    this.curves[frame] = 0;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frame) {
    this.curves[frame] = 1;
  }
  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger
   * than the actual number of Bezier curves. */
  shrink(bezierCount) {
    const size = this.getFrameCount() + bezierCount * 18;
    if (this.curves.length > size) {
      const newCurves = Utils_Utils.newFloatArray(size);
      Utils_Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
      this.curves = newCurves;
    }
  }
  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than
   * one curve per frame.
   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified
   *           in the constructor), inclusive.
   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.
   * @param value The index of the value for this frame that this curve is used for.
   * @param time1 The time for the first key.
   * @param value1 The value for the first key.
   * @param cx1 The time for the first Bezier handle.
   * @param cy1 The value for the first Bezier handle.
   * @param cx2 The time of the second Bezier handle.
   * @param cy2 The value for the second Bezier handle.
   * @param time2 The time for the second key.
   * @param value2 The value for the second key. */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = value1 + dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  /** Returns the Bezier interpolated value for the specified time.
   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.
   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.
   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */
  getBezierValue(time, frameIndex, valueOffset, i) {
    const curves = this.curves;
    if (curves[i] > time) {
      const x2 = this.frames[frameIndex];
      const y2 = this.frames[frameIndex + valueOffset];
      return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    frameIndex += this.getFrameEntries();
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);
  }
}
class CurveTimeline1 extends CurveTimeline {
  constructor(frameCount, bezierCount, propertyId) {
    super(frameCount, bezierCount, [propertyId]);
  }
  getFrameEntries() {
    return 2;
  }
  /** Sets the time and value for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value) {
    frame <<= 1;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE*/
    ] = value;
  }
  /** Returns the interpolated value for the specified time. */
  getCurveValue(time) {
    const frames = this.frames;
    let i = frames.length - 2;
    for (let ii = 2; ii <= i; ii += 2) {
      if (frames[ii] > time) {
        i = ii - 2;
        break;
      }
    }
    const curveType = this.curves[i >> 1];
    switch (curveType) {
      case 0:
        const before = frames[i];
        const value = frames[
          i + 1
          /* VALUE*/
        ];
        return value + (time - before) / (frames[
          i + 2
          /* ENTRIES*/
        ] - before) * (frames[
          i + 2 + 1
          /* VALUE*/
        ] - value);
      case 1:
        return frames[
          i + 1
          /* VALUE*/
        ];
    }
    return this.getBezierValue(
      time,
      i,
      1,
      curveType - 2
      /* BEZIER*/
    );
  }
}
class CurveTimeline2 extends CurveTimeline {
  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.
   * @param propertyIds Unique identifiers for the properties the timeline modifies. */
  constructor(frameCount, bezierCount, propertyId1, propertyId2) {
    super(frameCount, bezierCount, [propertyId1, propertyId2]);
  }
  getFrameEntries() {
    return 3;
  }
  /** Sets the time and values for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value1, value2) {
    frame *= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE1*/
    ] = value1;
    this.frames[
      frame + 2
      /* VALUE2*/
    ] = value2;
  }
}
class RotateTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case MixBlend.first:
          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;
      }
      return;
    }
    let r = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.rotation = bone.data.rotation + r * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case MixBlend.add:
        bone.rotation += r * alpha;
    }
  }
}
class TranslateTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
}
class TranslateXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x;
          return;
        case MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        break;
      case MixBlend.add:
        bone.x += x * alpha;
    }
  }
}
class TranslateYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.y = bone.data.y;
          return;
        case MixBlend.first:
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.y = bone.data.y + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case MixBlend.add:
        bone.y += y * alpha;
    }
  }
}
class ScaleTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    x *= bone.data.scaleX;
    y *= bone.data.scaleY;
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
}
class ScaleXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          return;
        case MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time) * bone.data.scaleX;
    if (alpha == 1) {
      if (blend == MixBlend.add)
        bone.scaleX += x - bone.data.scaleX;
      else
        bone.scaleX = x;
    } else {
      let bx = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            bx = bone.data.scaleX;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = bone.scaleX;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      }
    }
  }
}
class ScaleYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleY = bone.data.scaleY;
          return;
        case MixBlend.first:
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time) * bone.data.scaleY;
    if (alpha == 1) {
      if (blend == MixBlend.add)
        bone.scaleY += y - bone.data.scaleY;
      else
        bone.scaleY = y;
    } else {
      let by = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            by = bone.data.scaleY;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            by = bone.scaleY;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            by = Math.abs(bone.scaleY) * MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
class ShearXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX;
          return;
        case MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        break;
      case MixBlend.add:
        bone.shearX += x * alpha;
    }
  }
}
class ShearYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearY = bone.data.shearY;
          return;
        case MixBlend.first:
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case MixBlend.add:
        bone.shearY += y * alpha;
    }
  }
}
class RGBATimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 5;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b, a) {
    frame *= 5;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case MixBlend.setup:
          color.setFromColor(setup);
          return;
        case MixBlend.first:
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    const i = Timeline.search(
      frames,
      time,
      5
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 5
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        const t = (time - before) / (frames[
          i + 5
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 5 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 5 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 5 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 5 + 4
          /* A*/
        ] - a) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1)
      color.set(r, g, b, a);
    else {
      if (blend == MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
}
class RGBTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 4;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b) {
    frame <<= 2;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case MixBlend.setup:
          color.r = setup.r;
          color.g = setup.g;
          color.b = setup.b;
          return;
        case MixBlend.first:
          color.r += (setup.r - color.r) * alpha;
          color.g += (setup.g - color.g) * alpha;
          color.b += (setup.b - color.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 4 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 4 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 4 + 3
          /* B*/
        ] - b) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      color.r = r;
      color.g = g;
      color.b = b;
    } else {
      if (blend == MixBlend.setup) {
        const setup = slot.data.color;
        color.r = setup.r;
        color.g = setup.g;
        color.b = setup.b;
      }
      color.r += (r - color.r) * alpha;
      color.g += (g - color.g) * alpha;
      color.b += (b - color.b) * alpha;
    }
  }
}
class AlphaTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const color = slot.color;
    if (time < this.frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case MixBlend.setup:
          color.a = setup.a;
          return;
        case MixBlend.first:
          color.a += (setup.a - color.a) * alpha;
      }
      return;
    }
    const a = this.getCurveValue(time);
    if (alpha == 1)
      color.a = a;
    else {
      if (blend == MixBlend.setup)
        color.a = slot.data.color.a;
      color.a += (a - color.a) * alpha;
    }
  }
}
class RGBA2Timeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 8;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, a, r2, g2, b2) {
    frame <<= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
    this.frames[
      frame + 5
      /* R2*/
    ] = r2;
    this.frames[
      frame + 6
      /* G2*/
    ] = g2;
    this.frames[
      frame + 7
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case MixBlend.setup:
          light.setFromColor(setupLight);
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case MixBlend.first:
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      8
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 3];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 8
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 8 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 8 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 8 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 8 + 4
          /* A*/
        ] - a) * t;
        r2 += (frames[
          i + 8 + 5
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 8 + 6
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 8 + 7
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          7,
          curveType + 18 * 6 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.set(r, g, b, a);
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == MixBlend.setup) {
        light.setFromColor(slot.data.color);
        const setupDark = slot.data.darkColor;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
}
class RGB2Timeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, r2, g2, b2) {
    frame *= 7;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* R2*/
    ] = r2;
    this.frames[
      frame + 5
      /* G2*/
    ] = g2;
    this.frames[
      frame + 6
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case MixBlend.setup:
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case MixBlend.first:
          light.r += (setupLight.r - light.r) * alpha;
          light.g += (setupLight.g - light.g) * alpha;
          light.b += (setupLight.b - light.b) * alpha;
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 7 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 7 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 7 + 3
          /* B*/
        ] - b) * t;
        r2 += (frames[
          i + 7 + 4
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 7 + 5
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 7 + 6
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.r = r;
      light.g = g;
      light.b = b;
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == MixBlend.setup) {
        const setupLight = slot.data.color;
        const setupDark = slot.data.darkColor;
        light.r = setupLight.r;
        light.g = setupLight.g;
        light.b = setupLight.b;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.r += (r - light.r) * alpha;
      light.g += (g - light.g) * alpha;
      light.b += (b - light.b) * alpha;
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
}
class AttachmentTimeline extends Timeline {
  constructor(frameCount, slotIndex) {
    super(frameCount, [`${Property.attachment}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachmentNames = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frame, time, attachmentName) {
    this.frames[frame] = time;
    this.attachmentNames[frame] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == MixDirection.mixOut) {
      if (blend == MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
class DeformTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex, attachment) {
    super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachment = attachment;
    this.vertices = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frame, time, vertices) {
    this.frames[frame] = time;
    this.vertices[frame] = vertices;
  }
  /** @param value1 Ignored (0 is used for a deform timeline).
   * @param value2 Ignored (1 is used for a deform timeline). */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = cy2 * 0.03 - cy1 * 0.06;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = (cy1 - cy2 + 0.33333333) * 0.018;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  getCurvePercent(time, frame) {
    const curves = this.curves;
    let i = curves[frame];
    switch (i) {
      case 0:
        const x2 = this.frames[frame];
        return (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);
      case 1:
        return 0;
    }
    i -= 2;
    if (curves[i] > time) {
      const x2 = this.frames[frame];
      return curves[i + 1] * (time - x2) / (curves[i] - x2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!slotAttachment)
      return;
    if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != this.attachment)
      return;
    const deform = slot.deform;
    if (deform.length == 0)
      blend = MixBlend.setup;
    const vertices = this.vertices;
    const vertexCount = vertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          deform.length = 0;
          return;
        case MixBlend.first:
          if (alpha == 1) {
            deform.length = 0;
            return;
          }
          deform.length = vertexCount;
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (setupVertices[i] - deform[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform[i] *= alpha;
          }
      }
      return;
    }
    deform.length = vertexCount;
    if (time >= frames[frames.length - 1]) {
      const lastVertices = vertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i] - setupVertices[i];
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else
          Utils_Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
      } else {
        switch (blend) {
          case MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (!vertexAttachment2.bones) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++)
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Timeline.search1(frames, time);
    const percent = this.getCurvePercent(time, frame);
    const prevVertices = vertices[frame];
    const nextVertices = vertices[frame + 1];
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (!vertexAttachment.bones) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (!vertexAttachment2.bones) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case MixBlend.first:
        case MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
const _EventTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _EventTimeline.propertyIds);
    this.events = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frame, event) {
    this.frames[frame] = event.time;
    this.events[frame] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (!firedEvents)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let i = 0;
    if (lastTime < frames[0])
      i = 0;
    else {
      i = Timeline.search1(frames, lastTime) + 1;
      const frameTime = frames[i];
      while (i > 0) {
        if (frames[i - 1] != frameTime)
          break;
        i--;
      }
    }
    for (; i < frameCount && time >= frames[i]; i++)
      firedEvents.push(this.events[i]);
  }
};
let EventTimeline = _EventTimeline;
EventTimeline.propertyIds = [`${Property.event}`];
const _DrawOrderTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _DrawOrderTimeline.propertyIds);
    this.drawOrders = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frame, time, drawOrder) {
    this.frames[frame] = time;
    this.drawOrders[frame] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (direction == MixDirection.mixOut) {
      if (blend == MixBlend.setup)
        Utils_Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        Utils_Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const idx = Timeline.search1(this.frames, time);
    const drawOrderToSetupIndex = this.drawOrders[idx];
    if (!drawOrderToSetupIndex)
      Utils_Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
    else {
      const drawOrder = skeleton.drawOrder;
      const slots = skeleton.slots;
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
};
let DrawOrderTimeline = _DrawOrderTimeline;
DrawOrderTimeline.propertyIds = [`${Property.drawOrder}`];
class IkConstraintTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, ikConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);
    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */
    this.ikConstraintIndex = 0;
    this.ikConstraintIndex = ikConstraintIndex;
  }
  getFrameEntries() {
    return 6;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {
    frame *= 6;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* MIX*/
    ] = mix;
    this.frames[
      frame + 2
      /* SOFTNESS*/
    ] = softness;
    this.frames[
      frame + 3
      /* BEND_DIRECTION*/
    ] = bendDirection;
    this.frames[
      frame + 4
      /* COMPRESS*/
    ] = compress ? 1 : 0;
    this.frames[
      frame + 5
      /* STRETCH*/
    ] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    let mix = 0;
    let softness = 0;
    const i = Timeline.search(
      frames,
      time,
      6
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 6
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        const t = (time - before) / (frames[
          i + 6
          /* ENTRIES*/
        ] - before);
        mix += (frames[
          i + 6 + 1
          /* MIX*/
        ] - mix) * t;
        softness += (frames[
          i + 6 + 2
          /* SOFTNESS*/
        ] - softness) * t;
        break;
      case 1:
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        break;
      default:
        mix = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        softness = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    if (blend == MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
      if (direction == MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    } else {
      constraint.mix += (mix - constraint.mix) * alpha;
      constraint.softness += (softness - constraint.softness) * alpha;
      if (direction == MixDirection.mixIn) {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    }
  }
}
class TransformConstraintTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, transformConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);
    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */
    this.transformConstraintIndex = 0;
    this.transformConstraintIndex = transformConstraintIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
    const frames = this.frames;
    frame *= 7;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
    frames[
      frame + 4
      /* SCALEX*/
    ] = mixScaleX;
    frames[
      frame + 5
      /* SCALEY*/
    ] = mixScaleY;
    frames[
      frame + 6
      /* SHEARY*/
    ] = mixShearY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case MixBlend.setup:
          constraint.mixRotate = data.mixRotate;
          constraint.mixX = data.mixX;
          constraint.mixY = data.mixY;
          constraint.mixScaleX = data.mixScaleX;
          constraint.mixScaleY = data.mixScaleY;
          constraint.mixShearY = data.mixShearY;
          return;
        case MixBlend.first:
          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (data.mixY - constraint.mixY) * alpha;
          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    let scaleX;
    let scaleY;
    let shearY;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 7 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 7 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 7 + 3
          /* Y*/
        ] - y) * t;
        scaleX += (frames[
          i + 7 + 4
          /* SCALEX*/
        ] - scaleX) * t;
        scaleY += (frames[
          i + 7 + 5
          /* SCALEY*/
        ] - scaleY) * t;
        shearY += (frames[
          i + 7 + 6
          /* SHEARY*/
        ] - shearY) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        scaleX = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        scaleY = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        shearY = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (blend == MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;
      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;
      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;
      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;
      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;
    }
  }
}
class PathConstraintPositionTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);
    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    const position = this.getCurveValue(time);
    if (blend == MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
}
class PathConstraintSpacingTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);
    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    const spacing = this.getCurveValue(time);
    if (blend == MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
class PathConstraintMixTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);
    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  getFrameEntries() {
    return 4;
  }
  setFrame(frame, time, mixRotate, mixX, mixY) {
    const frames = this.frames;
    frame <<= 2;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.mixRotate = constraint.data.mixRotate;
          constraint.mixX = constraint.data.mixX;
          constraint.mixY = constraint.data.mixY;
          return;
        case MixBlend.first:
          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 4 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 4 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 4 + 3
          /* Y*/
        ] - y) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (blend == MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
    }
  }
}
const _SequenceTimeline = class extends Timeline {
  constructor(frameCount, slotIndex, attachment) {
    super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);
    this.slotIndex = slotIndex;
    this.attachment = attachment;
  }
  getFrameEntries() {
    return _SequenceTimeline.ENTRIES;
  }
  getSlotIndex() {
    return this.slotIndex;
  }
  getAttachment() {
    return this.attachment;
  }
  /** Sets the time, mode, index, and frame time for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time Seconds between frames. */
  setFrame(frame, time, mode, index, delay) {
    const frames = this.frames;
    frame *= _SequenceTimeline.ENTRIES;
    frames[frame] = time;
    frames[frame + _SequenceTimeline.MODE] = mode | index << 4;
    frames[frame + _SequenceTimeline.DELAY] = delay;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.attachment;
    const attachment = this.attachment;
    if (slotAttachment != attachment) {
      if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != attachment)
        return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        slot.sequenceIndex = -1;
      return;
    }
    const i = Timeline.search(frames, time, _SequenceTimeline.ENTRIES);
    const before = frames[i];
    const modeAndIndex = frames[i + _SequenceTimeline.MODE];
    const delay = frames[i + _SequenceTimeline.DELAY];
    if (!this.attachment.sequence)
      return;
    let index = modeAndIndex >> 4;
    const count = this.attachment.sequence.regions.length;
    const mode = SequenceModeValues[modeAndIndex & 15];
    if (mode != SequenceMode.hold) {
      index += (time - before) / delay + 1e-5 | 0;
      switch (mode) {
        case SequenceMode.once:
          index = Math.min(count - 1, index);
          break;
        case SequenceMode.loop:
          index %= count;
          break;
        case SequenceMode.pingpong: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : index % n;
          if (index >= count)
            index = n - index;
          break;
        }
        case SequenceMode.onceReverse:
          index = Math.max(count - 1 - index, 0);
          break;
        case SequenceMode.loopReverse:
          index = count - 1 - index % count;
          break;
        case SequenceMode.pingpongReverse: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : (index + count - 1) % n;
          if (index >= count)
            index = n - index;
        }
      }
    }
    slot.sequenceIndex = index;
  }
};
let SequenceTimeline = _SequenceTimeline;
SequenceTimeline.ENTRIES = 3;
SequenceTimeline.MODE = 1;
SequenceTimeline.DELAY = 2;


//# sourceMappingURL=Animation.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationState.mjs



const _AnimationState = class {
  constructor(data) {
    /** The list of tracks that currently have animations, which may contain null entries. */
    this.tracks = new Array();
    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
     * or faster. Defaults to 1.
     *
     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new StringSet();
    this.animationsChanged = false;
    this.trackEntryPool = new Utils_Pool(() => new TrackEntry());
    this.data = data;
  }
  static emptyAnimation() {
    return _AnimationState._emptyAnimation;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
        tracks[i] = null;
        this.queue.end(current);
        this.clearNext(current);
        continue;
      }
      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from)
          from.mixingTo = null;
        while (from) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (!from)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && !current.next)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      let applyTime = animationTime;
      let applyEvents = events;
      if (current.reverse) {
        applyTime = current.animation.duration - applyTime;
        applyEvents = null;
      }
      const timelines = current.animation.timelines;
      const timelineCount = timelines.length;
      if (i == 0 && mix == 1 || blend == MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          Utils_Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const shortestRotation = current.shortestRotation;
        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          current.timelinesRotation.length = timelineCount << 1;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;
          if (!shortestRotation && timeline instanceof RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof AttachmentTimeline) {
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          } else {
            Utils_Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == MixBlend.first)
        blend = MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != MixBlend.first)
        blend = from.mixBlend;
    }
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const timelines = from.animation.timelines;
    const timelineCount = timelines.length;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    let applyTime = animationTime;
    let events = null;
    if (from.reverse)
      applyTime = from.animation.duration - applyTime;
    else if (mix < from.eventThreshold)
      events = this.events;
    if (blend == MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const shortestRotation = from.shortestRotation;
      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;
      if (firstFrame)
        from.timelinesRotation.length = timelineCount << 1;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case SUBSEQUENT:
            if (!drawOrder && timeline instanceof DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaMix;
            break;
          case HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case HOLD_FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (!shortestRotation && timeline instanceof RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof AttachmentTimeline)
          this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);
        else {
          Utils_Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)
            direction = MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    if (time < timeline.frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else
      this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
      return;
    }
    const bone = skeleton.bones[timeline.boneIndex];
    if (!bone.active)
      return;
    const frames = timeline.frames;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
      r2 = bone.data.rotation + timeline.getCurveValue(time);
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    bone.rotation = r1 + total * alpha;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, event);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (!current)
      return;
    this.queue.end(current);
    this.clearNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (!from)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    current.previous = null;
    if (from) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * See {@link #setAnimationWith()}. */
  setAnimation(trackIndex, animationName, loop = false) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop = false) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.clearNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.clearNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop = false, delay = 0) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last) {
      while (last.next)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (!last) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      entry.previous = last;
      if (delay <= 0)
        delay += last.getTrackComplete() - entry.mixDuration;
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration = 0) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false, delay);
    if (delay <= 0)
      entry.delay += entry.mixDuration - mixDuration;
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration = 0) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    Utils_Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.reset();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.reverse = false;
    entry.shortestRotation = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);
    entry.interruptAlpha = 1;
    entry.totalAlpha = 0;
    entry.mixBlend = MixBlend.replace;
    return entry;
  }
  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */
  clearNext(entry) {
    let next = entry.next;
    while (next) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      let entry = tracks[i];
      if (!entry)
        continue;
      while (entry.mixingFrom)
        entry = entry.mixingFrom;
      do {
        if (!entry.mixingTo || entry.mixBlend != MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = entry.timelineMode;
    timelineMode.length = timelinesCount;
    const timelineHoldMix = entry.timelineHoldMix;
    timelineHoldMix.length = 0;
    const propertyIDs = this.propertyIDs;
    if (to && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++)
        timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const ids = timeline.getPropertyIds();
        if (!propertyIDs.addAll(ids))
          timelineMode[i] = SUBSEQUENT;
        else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(ids)) {
          timelineMode[i] = FIRST;
        } else {
          for (let next = to.mixingTo; next; next = next.mixingTo) {
            if (next.animation.hasTimeline(ids))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = HOLD_MIX;
              timelineHoldMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (!listener)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState._emptyAnimation = new Animation("<empty>", [], 0);
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    /** The animation to apply for this track entry. */
    this.animation = null;
    this.previous = null;
    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */
    this.next = null;
    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */
    this.mixingFrom = null;
    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */
    this.mixingTo = null;
    /** The listener for events generated by this track entry, or null.
     *
     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation
     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */
    this.listener = null;
    /** The index of the track where this track entry is either current or queued.
     *
     * See {@link AnimationState#getCurrent()}. */
    this.trackIndex = 0;
    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
     * duration. */
    this.loop = false;
    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
     * of being mixed out.
     *
     * When mixing between animations that key the same property, if a lower track also keys that property then the value will
     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation
     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
     * keys the property, only when a higher track also keys the property.
     *
     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the
     * previous animation. */
    this.holdPrevious = false;
    this.reverse = false;
    this.shortestRotation = false;
    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
     * timelines are not applied while this animation is being mixed out. */
    this.eventThreshold = 0;
    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the
     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to
     * 0, so attachment timelines are not applied while this animation is being mixed out. */
    this.attachmentThreshold = 0;
    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,
     * so draw order timelines are not applied while this animation is being mixed out. */
    this.drawOrderThreshold = 0;
    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.
     *
     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same
     * value to prevent timeline keys before the start time from triggering. */
    this.animationStart = 0;
    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */
    this.animationEnd = 0;
    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and
     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
     * is applied. */
    this.animationLast = 0;
    this.nextAnimationLast = 0;
    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`
     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from
     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous
     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).
     *
     * {@link #timeScale} affects the delay. */
    this.delay = 0;
    /** Current time in seconds this track entry has been the current track entry. The track time determines
     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting
     * looping. */
    this.trackTime = 0;
    this.trackLast = 0;
    this.nextTrackLast = 0;
    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
     * properties keyed by the animation are set to the setup pose and the track is cleared.
     *
     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation
     * abruptly cease being applied. */
    this.trackEnd = 0;
    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or
     * faster. Defaults to 1.
     *
     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to
     * match the animation speed.
     *
     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If
     * the time scale is not 1, the delay may need to be adjusted.
     *
     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */
    this.timeScale = 0;
    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults
     * to 1, which overwrites the skeleton's current pose with this animation.
     *
     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to
     * use alpha on track 0 if the skeleton pose is from the last frame render. */
    this.alpha = 0;
    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be
     * slightly more than `mixDuration` when the mix is complete. */
    this.mixTime = 0;
    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).
     *
     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the
     * properties it was animating.
     *
     * The `mixDuration` can be set manually rather than use the value from
     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new
     * track entry only before {@link AnimationState#update(float)} is first called.
     *
     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set
     * afterward. */
    this.mixDuration = 0;
    this.interruptAlpha = 0;
    this.totalAlpha = 0;
    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
     * the values from the lower tracks.
     *
     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
     * called. */
    this.mixBlend = MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.previous = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  getTrackComplete() {
    const duration = this.animationEnd - this.animationStart;
    if (duration != 0) {
      if (this.loop)
        return duration * (1 + (this.trackTime / duration | 0));
      if (this.trackTime < duration)
        return duration;
    }
    return this.trackTime;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
class EventQueue {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.start)
              listener.start(entry);
          }
          break;
        case EventType.interrupt:
          if (entry.listener && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.interrupt)
              listener.interrupt(entry);
          }
          break;
        case EventType.end:
          if (entry.listener && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.end)
              listener.end(entry);
          }
        case EventType.dispose:
          if (entry.listener && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.dispose)
              listener.dispose(entry);
          }
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.complete)
              listener.complete(entry);
          }
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.event)
              listener.event(entry, event);
          }
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
}
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}
const SUBSEQUENT = 0;
const FIRST = 1;
const HOLD_SUBSEQUENT = 2;
const HOLD_FIRST = 3;
const HOLD_MIX = 4;
const SETUP = 1;
const CURRENT = 2;


//# sourceMappingURL=AnimationState.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/AtlasAttachmentLoader.mjs









class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  loadSequence(name, basePath, sequence) {
    const regions = sequence.regions;
    for (let i = 0, n = regions.length; i < n; i++) {
      const path = sequence.getPath(basePath, i);
      const region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);
      regions[i] = region;
      regions[i].renderObject = regions[i];
    }
  }
  newRegionAttachment(skin, name, path, sequence) {
    const attachment = new RegionAttachment(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newMeshAttachment(skin, name, path, sequence) {
    const attachment = new MeshAttachment(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment(name);
  }
  newPathAttachment(skin, name) {
    return new PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment(name);
  }
}


//# sourceMappingURL=AtlasAttachmentLoader.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/Bone.mjs



class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new Matrix();
    /** The parent bone, or null if this is the root bone. */
    this.parent = null;
    /** The immediate children of this bone. */
    this.children = new Array();
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local rotation in degrees, counter clockwise. */
    this.rotation = 0;
    /** The local scaleX. */
    this.scaleX = 0;
    /** The local scaleY. */
    this.scaleY = 0;
    /** The local shearX. */
    this.shearX = 0;
    /** The local shearY. */
    this.shearY = 0;
    /** The applied local x translation. */
    this.ax = 0;
    /** The applied local y translation. */
    this.ay = 0;
    /** The applied local rotation in degrees, counter clockwise. */
    this.arotation = 0;
    /** The applied local scaleX. */
    this.ascaleX = 0;
    /** The applied local scaleY. */
    this.ascaleY = 0;
    /** The applied local shearX. */
    this.ashearX = 0;
    /** The applied local shearY. */
    this.ashearY = 0;
    this.sorted = false;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the
   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */
  isActive() {
    return this.active;
  }
  /** Computes the world transform using the parent bone and this bone's local applied transform. */
  update() {
    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform.
   *
   * See {@link #updateWorldTransformWith()}. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the
   * specified local transform. Child bones are not updated.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = settings_settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (!parent) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = MathUtils.cosDeg(rotationY) * scaleY;
        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = MathUtils.cosDeg(rotationY) * scaleY;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= sx;
          pc /= sy;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = MathUtils.cosDeg(rx) * scaleX;
        const lb = MathUtils.cosDeg(ry) * scaleY;
        const lc = MathUtils.sinDeg(rx) * scaleX;
        const ld = MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case TransformMode.NoScale:
      case TransformMode.NoScaleOrReflection: {
        const cos = MathUtils.cosDeg(rotation);
        const sin = MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = MathUtils.cosDeg(shearX) * scaleX;
        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = MathUtils.sinDeg(shearX) * scaleX;
        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  /** Sets this bone's local transform to the setup pose. */
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
  }
  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
  }
  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.b * m.b);
  }
  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.c * m.c + m.d * m.d);
  }
  /** Computes the applied transform values from the world transform.
   *
   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so
   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other
   * constraints).
   *
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after
   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */
  updateAppliedTransform() {
    const parent = this.parent;
    const m = this.matrix;
    if (!parent) {
      this.ax = m.tx - this.skeleton.x;
      this.ay = m.ty - this.skeleton.y;
      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
    }
  }
  /** Transforms a point from world coordinates to the bone's local coordinates. */
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  /** Transforms a point from the bone's local coordinates to world coordinates. */
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  /** Transforms a world rotation to a local rotation. */
  worldToLocalRotation(worldRotation) {
    const sin = MathUtils.sinDeg(worldRotation);
    const cos = MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
  }
  /** Transforms a local rotation to a world rotation. */
  localToWorldRotation(localRotation) {
    localRotation -= this.rotation - this.shearX;
    const sin = MathUtils.sinDeg(localRotation);
    const cos = MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
  }
  /** Rotates the world transform the specified amount.
   * <p>
   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will
   * need to be called on any child bones, recursively. */
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = MathUtils.cosDeg(degrees);
    const sin = MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
  }
}


//# sourceMappingURL=Bone.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs


class BoneData {
  constructor(index, name, parent) {
    /** The index of the bone in {@link Skeleton#getBones()}. */
    this.index = 0;
    /** @returns May be null. */
    this.parent = null;
    /** The bone's length. */
    this.length = 0;
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local rotation. */
    this.rotation = 0;
    /** The local scaleX. */
    this.scaleX = 1;
    /** The local scaleY. */
    this.scaleY = 1;
    /** The local shearX. */
    this.shearX = 0;
    /** The local shearX. */
    this.shearY = 0;
    /** The transform mode for how parent world transforms affect this bone. */
    this.transformMode = TransformMode.Normal;
    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this
     * bone.
     * @see Skin#bones */
    this.skinRequired = false;
    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually
     * rendered at runtime. */
    this.color = new core_Utils_Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}


//# sourceMappingURL=BoneData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraint.mjs


class IkConstraint {
  constructor(data, skeleton) {
    /** Controls the bend direction of the IK bones, either 1 or -1. */
    this.bendDirection = 0;
    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
    this.compress = false;
    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
     * and the parent bone has local nonuniform scale, stretch is not applied. */
    this.stretch = false;
    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
    this.mix = 1;
    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
    this.softness = 0;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find bone ${data.target.name}`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mix == 0)
      return;
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
        break;
    }
  }
  /** Applies 1 bone IK. The target is specified in the world coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    const p = bone.parent.matrix;
    if (!p)
      throw new Error("IK bone must have parent.");
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    const skelX = bone.skeleton.scaleX;
    const skelY = settings_settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;
    switch (bone.data.transformMode) {
      case TransformMode.OnlyTranslation:
        tx = (targetX - bone.worldX) * MathUtils.signum(skelX);
        ty = (targetY - bone.worldY) * MathUtils.signum(skelY);
        break;
      case TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / skelX;
        const sc = pc / skelY;
        pb = -sc * s * skelX;
        pd = sa * s * skelY;
        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Applies 2 bone IK. The target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let psy = parent.ascaleY;
    let sx = psx;
    let sy = psy;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u || stretch) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    if (!pp)
      throw new Error("IK parent must itself have a parent.");
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) * 0.5;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1) {
          cos = -1;
          a2 = Math.PI * bendDir;
        } else if (cos > 1) {
          cos = 1;
          a2 = 0;
          if (stretch) {
            a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
            sx *= a;
            if (uniform)
              sy *= a;
          }
        } else
          a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) * 0.5;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) * 0.5) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}


//# sourceMappingURL=IkConstraint.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs
class ConstraintData {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
}


//# sourceMappingURL=ConstraintData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs



class PathConstraintData extends ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that will be modified by this path constraint. */
    this.bones = new Array();
    /** The slot whose path attachment will be used to constrained the bones. */
    this._target = null;
    /** The mode for positioning the first bone on the path. */
    this.positionMode = PositionMode.Fixed;
    /** The mode for positioning the bones after the first bone on the path. */
    this.spacingMode = SpacingMode.Fixed;
    /** The mode for adjusting the rotation of the bones. */
    this.rotateMode = RotateMode.Chain;
    /** An offset added to the constrained bone rotation. */
    this.offsetRotation = 0;
    /** The position along the path. */
    this.position = 0;
    /** The spacing between bones. */
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
  }
  set target(slotData) {
    this._target = slotData;
  }
  get target() {
    if (!this._target)
      throw new Error("SlotData not set.");
    else
      return this._target;
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  SpacingMode2[SpacingMode2["Proportional"] = 3] = "Proportional";
  return SpacingMode2;
})(SpacingMode || {});


//# sourceMappingURL=PathConstraintData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraint.mjs







const _PathConstraint = class {
  constructor(data, skeleton) {
    /** The position along the path. */
    this.position = 0;
    /** The spacing between bones. */
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findSlot(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}`);
    this.target = target;
    this.position = data.position;
    this.spacing = data.spacing;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
  }
  isActive() {
    return this.active;
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment))
      return;
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    if (mixRotate == 0 && mixX == 0 && mixY == 0)
      return;
    const data = this.data;
    const tangents = data.rotateMode == RotateMode.Tangent;
    const scale = data.rotateMode == RotateMode.ChainScale;
    const bones = this.bones;
    const boneCount = bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const spaces = Utils_Utils.setArraySize(this.spaces, spacesCount);
    const lengths = scale ? this.lengths = Utils_Utils.setArraySize(this.lengths, boneCount) : [];
    const spacing = this.spacing;
    switch (data.spacingMode) {
      case SpacingMode.Percent:
        if (scale) {
          for (let i = 0, n = spacesCount - 1; i < n; i++) {
            const bone = bones[i];
            const setupLength = bone.data.length;
            if (setupLength < _PathConstraint.epsilon)
              lengths[i] = 0;
            else {
              const x = setupLength * bone.matrix.a;
              const y = setupLength * bone.matrix.b;
              lengths[i] = Math.sqrt(x * x + y * y);
            }
          }
        }
        Utils_Utils.arrayFill(spaces, 1, spacesCount, spacing);
        break;
      case SpacingMode.Proportional:
        let sum = 0;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = length;
            sum += length;
          }
        }
        if (sum > 0) {
          sum = spacesCount / sum * spacing;
          for (let i = 1; i < spacesCount; i++)
            spaces[i] *= sum;
        }
        break;
      default:
        const lengthSpacing = data.spacingMode == SpacingMode.Length;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
          }
        }
    }
    const positions = this.computeWorldPositions(attachment, spacesCount, tangents);
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = data.rotateMode == RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * mixX;
      mat.ty += (boneY - mat.ty) * mixY;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (mixRotate > 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          r = positions[p - 1];
        else if (spaces[i + 1] == 0)
          r = positions[p + 2];
        else
          r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;
          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;
        } else {
          r += offsetRotation;
        }
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= mixRotate;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.updateAppliedTransform();
    }
  }
  computeWorldPositions(path, spacesCount, tangents) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = Utils_Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = this.world;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (this.data.positionMode == PositionMode.Percent)
        position *= pathLength2;
      let multiplier2;
      switch (this.data.spacingMode) {
        case SpacingMode.Percent:
          multiplier2 = pathLength2;
          break;
        case SpacingMode.Proportional:
          multiplier2 = pathLength2 / spacesCount;
          break;
        default:
          multiplier2 = 1;
      }
      world = Utils_Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i] * multiplier2;
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = Utils_Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = Utils_Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = Utils_Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (this.data.positionMode == PositionMode.Percent)
      position *= pathLength;
    let multiplier;
    switch (this.data.spacingMode) {
      case SpacingMode.Percent:
        multiplier = pathLength;
        break;
      case SpacingMode.Proportional:
        multiplier = pathLength / spacesCount;
        break;
      default:
        multiplier = 1;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i] * multiplier;
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p)) {
      out[o] = x1;
      out[o + 1] = y1;
      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      return;
    }
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents) {
      if (p < 1e-3)
        out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      else
        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    }
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;


//# sourceMappingURL=PathConstraint.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/Slot.mjs



class Slot {
  constructor(data, bone) {
    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
     * color's alpha is not used. */
    this.darkColor = null;
    this.attachment = null;
    this.attachmentState = 0;
    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the
     * {@link Sequence#getSetupIndex()}. */
    this.sequenceIndex = -1;
    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
     *
     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */
    this.deform = new Array();
    if (!data)
      throw new Error("data cannot be null.");
    if (!bone)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new core_Utils_Color();
    this.darkColor = !data.darkColor ? null : new core_Utils_Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** The skeleton this slot belongs to. */
  getSkeleton() {
    return this.bone.skeleton;
  }
  /** The current attachment for the slot, or null if the slot has no attachment. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.
   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the
   * specified attachment. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    if (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
      this.deform.length = 0;
    }
    this.attachment = attachment;
    this.sequenceIndex = -1;
  }
  /** Sets this slot to the setup pose. */
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor)
      this.darkColor.setFromColor(this.data.darkColor);
    if (!this.data.attachmentName)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}


//# sourceMappingURL=Slot.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraint.mjs


class TransformConstraint {
  constructor(data, skeleton) {
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    this.temp = new Vector2();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
    this.mixScaleX = data.mixScaleX;
    this.mixScaleY = data.mixScaleY;
    this.mixShearY = data.mixShearY;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}.`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)
      return;
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * mixX;
        mat.ty += (temp.y - mat.ty) * mixY;
      }
      if (mixScaleX != 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        if (s != 0)
          s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        if (s != 0)
          s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r = by + (r + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyRelativeWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * mixX;
        mat.ty += temp.y * mixY;
      }
      if (mixScaleX != 0) {
        const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyAbsoluteLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let rotation = bone.arotation;
      if (mixRotate != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * mixRotate;
      }
      let x = bone.ax;
      let y = bone.ay;
      x += (target.ax - x + this.data.offsetX) * mixX;
      y += (target.ay - y + this.data.offsetY) * mixY;
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (mixScaleX != 0 && scaleX != 0)
        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
      if (mixScaleY != 0 && scaleY != 0)
        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
      let shearY = bone.ashearY;
      if (mixShearY != 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        shearY += r * mixShearY;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
      const x = bone.ax + (target.ax + this.data.offsetX) * mixX;
      const y = bone.ay + (target.ay + this.data.offsetY) * mixY;
      const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
      const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
      const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
}


//# sourceMappingURL=TransformConstraint.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/Skeleton.mjs












const _Skeleton = class {
  constructor(data) {
    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */
    this._updateCache = new Array();
    /** The skeleton's current skin. May be null. */
    this.skin = null;
    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale
     * inheritance. */
    this.scaleX = 1;
    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale
     * inheritance. */
    this.scaleY = 1;
    /** Sets the skeleton X position, which is added to the root bone worldX position. */
    this.x = 0;
    /** Sets the skeleton Y position, which is added to the root bone worldY position. */
    this.y = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (!boneData.parent)
        bone = new Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));
    }
    this.color = new core_Utils_Color(1, 1, 1, 1);
    this.updateCache();
  }
  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,
   * constraints, or weighted path attachments are added or removed. */
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils_Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length == 1) {
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
    } else {
      const child = constrained[constrained.length - 1];
      this.sortBone(child);
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      child.sorted = true;
    }
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils_Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils_Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        this.sortBone(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (!pathBones)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      for (let i = 0, n = pathBones.length; i < n; ) {
        let nn = pathBones[i++];
        nn += i;
        while (i < nn)
          this.sortBone(bones[pathBones[i++]]);
      }
    }
  }
  sortBone(bone) {
    if (!bone)
      return;
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies all constraints.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransform() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  updateWorldTransformWith(parent) {
    const rootBone = this.getRootBone();
    const pa = parent.matrix.a;
    const pb = parent.matrix.c;
    const pc = parent.matrix.b;
    const pd = parent.matrix.d;
    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;
    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;
    const rotationY = rootBone.rotation + 90 + rootBone.shearY;
    const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;
    const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;
    const sx = this.scaleX;
    const sy = settings_settings.yDown ? -this.scaleY : this.scaleY;
    rootBone.matrix.a = (pa * la + pb * lc) * sx;
    rootBone.matrix.c = (pa * lb + pb * ld) * sx;
    rootBone.matrix.b = (pc * la + pd * lc) * sy;
    rootBone.matrix.d = (pc * lb + pd * ld) * sy;
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++) {
      const updatable = updateCache[i];
      if (updatable != rootBone)
        updatable.update();
    }
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
      constraint.mixScaleX = data.mixScaleX;
      constraint.mixScaleY = data.mixScaleY;
      constraint.mixShearY = data.mixShearY;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
    }
  }
  /** Sets the slots and draw order to their setup pose values. */
  setSlotsToSetupPose() {
    const slots = this.slots;
    Utils_Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @returns May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * repeatedly.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   *
   * See {@link #setSkin()}. */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (!skin)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the
   * skin is changed, {@link #updateCache()} is called.
   *
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   *
   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the
   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin) {
      if (this.skin)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment
   * name.
   *
   * See {@link #getAttachment()}.
   * @returns May be null. */
  getAttachmentByName(slotName, attachmentName) {
    const slot = this.data.findSlot(slotName);
    if (!slot)
      throw new Error(`Can't find slot with name ${slotName}`);
    return this.getAttachment(slot.index, attachmentName);
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and
   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.
   *
   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.
   * @returns May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (!attachmentName)
      throw new Error("attachmentName cannot be null.");
    if (this.skin) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment)
        return attachment;
    }
    if (this.data.defaultSkin)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with
   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.
   * @param attachmentName May be null to clear the slot's attachment. */
  setAttachment(slotName, attachmentName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName) {
          attachment = this.getAttachment(i, attachmentName);
          if (!attachment)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it repeatedly.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.
   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */
  getBoundsRect() {
    const offset = new Vector2();
    const size = new Vector2();
    this.getBounds(offset, size);
    return { x: offset.x, y: offset.y, width: size.x, height: size.y };
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size An output value, the width and height of the AABB.
   * @param temp Working memory to temporarily store attachments' computed world vertices. */
  getBounds(offset, size, temp = new Array(2)) {
    if (!offset)
      throw new Error("offset cannot be null.");
    if (!size)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment) {
        verticesLength = 8;
        vertices = Utils_Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = Utils_Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;


//# sourceMappingURL=Skeleton.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs
class core_Event_Event {
  constructor(time, data) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.time = 0;
    this.volume = 0;
    this.balance = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}


//# sourceMappingURL=Event.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs
class SkeletonData {
  constructor() {
    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */
    this.name = null;
    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */
    this.bones = new Array();
    // Ordered parents first.
    /** The skeleton's slots. */
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.
     *
     * See {@link Skeleton#getAttachmentByName()}.
     * May be null. */
    this.defaultSkin = null;
    /** The skeleton's events. */
    this.events = new Array();
    /** The skeleton's animations. */
    this.animations = new Array();
    /** The skeleton's IK constraints. */
    this.ikConstraints = new Array();
    /** The skeleton's transform constraints. */
    this.transformConstraints = new Array();
    /** The skeleton's path constraints. */
    this.pathConstraints = new Array();
    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */
    this.x = 0;
    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */
    this.y = 0;
    /** The width of the skeleton's axis aligned bounding box in the setup pose. */
    this.width = 0;
    /** The height of the skeleton's axis aligned bounding box in the setup pose. */
    this.height = 0;
    /** The Spine version used to export the skeleton data, or null. */
    this.version = null;
    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */
    this.hash = null;
    // Nonessential
    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */
    this.fps = 0;
    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */
    this.imagesPath = null;
    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */
    this.audioPath = null;
  }
  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSkin(skinName) {
    if (!skinName)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findEvent(eventDataName) {
    if (!eventDataName)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to
   * call it multiple times.
   * @returns May be null. */
  findAnimation(animationName) {
    if (!animationName)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it multiple times.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}


//# sourceMappingURL=SkeletonData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs



class SlotData {
  constructor(index, name, boneData) {
    /** The index of the slot in {@link Skeleton#getSlots()}. */
    this.index = 0;
    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two
     * color tinting. */
    this.color = new core_Utils_Color(1, 1, 1, 1);
    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
     * color's alpha is not used. */
    this.darkColor = null;
    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */
    this.attachmentName = null;
    /** The blend mode for drawing the slot's attachment. */
    this.blendMode = lib_BLEND_MODES.NORMAL;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    if (!boneData)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}


//# sourceMappingURL=SlotData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs


class IkConstraintData extends ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that are constrained by this IK constraint. */
    this.bones = new Array();
    /** The bone that is the IK target. */
    this._target = null;
    /** Controls the bend direction of the IK bones, either 1 or -1. */
    this.bendDirection = 1;
    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
    this.compress = false;
    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
     * and the parent bone has local nonuniform scale, stretch is not applied. */
    this.stretch = false;
    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone
     * is scaled on both the X and Y axes. */
    this.uniform = false;
    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
    this.mix = 1;
    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
    this.softness = 0;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
}


//# sourceMappingURL=IkConstraintData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs


class TransformConstraintData extends ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that will be modified by this transform constraint. */
    this.bones = new Array();
    /** The target bone whose world transform will be copied to the constrained bones. */
    this._target = null;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    /** An offset added to the constrained bone rotation. */
    this.offsetRotation = 0;
    /** An offset added to the constrained bone X translation. */
    this.offsetX = 0;
    /** An offset added to the constrained bone Y translation. */
    this.offsetY = 0;
    /** An offset added to the constrained bone scaleX. */
    this.offsetScaleX = 0;
    /** An offset added to the constrained bone scaleY. */
    this.offsetScaleY = 0;
    /** An offset added to the constrained bone shearY. */
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
}


//# sourceMappingURL=TransformConstraintData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs






class SkinEntry {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
}
class Skin {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  /** Adds an attachment to the skin for the specified slot index and name. */
  setAttachment(slotIndex, name, attachment) {
    if (!attachment)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not
   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (!attachment.attachment)
        continue;
      if (attachment.attachment instanceof MeshAttachment) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** Returns the attachment for the specified slot index and name, or null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Removes the attachment in the skin for the specified slot index and name, if any. */
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      delete dictionary[name];
  }
  /** Returns all attachments in this skin. */
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry(i, name, attachment));
        }
      }
    }
    return entries;
  }
  /** Returns all attachments in this skin for the specified slot index. */
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry(slotIndex, name, attachment));
      }
    }
  }
  /** Clears all attachments, bones, and constraints. */
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}


//# sourceMappingURL=Skin.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs
class EventData {
  constructor(name) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.audioPath = null;
    this.volume = 0;
    this.balance = 0;
    this.name = name;
  }
}


//# sourceMappingURL=EventData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBinary.mjs
















class SkeletonBinary {
  constructor(attachmentLoader) {
    this.ver40 = false;
    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
     * runtime than were used in Spine.
     *
     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new SkeletonData();
    skeletonData.name = "";
    const input = new BinaryInput(binary);
    const lowHash = input.readInt32();
    const highHash = input.readInt32();
    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
    skeletonData.version = input.readString();
    const verShort = skeletonData.version.substr(0, 3);
    if (verShort !== "4.0" && verShort !== "4.1") {
      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;
      console.error(error);
    }
    this.ver40 = verShort === "4.0";
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const str = input.readString();
      if (!str)
        throw new Error("String in string table must not be null.");
      input.strings.push(str);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Bone name must not be null.");
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new BoneData(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = input.readInt(true);
      data.skinRequired = input.readBoolean();
      if (nonessential)
        core_Utils_Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      if (!slotName)
        throw new Error("Slot name must not be null.");
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new SlotData(i, slotName, boneData);
      core_Utils_Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        core_Utils_Color.rgb888ToColor(data.darkColor = new core_Utils_Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = input.readInt(true);
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("IK constraint data name must not be null.");
      const data = new IkConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Transform constraint data name must not be null.");
      const data = new TransformConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      data.mixScaleX = input.readFloat();
      data.mixScaleY = input.readFloat();
      data.mixShearY = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Path constraint data name must not be null.");
      const data = new PathConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = input.readInt(true);
      data.spacingMode = input.readInt(true);
      data.rotateMode = input.readInt(true);
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
        data.spacing *= scale;
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      Utils_Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++) {
        const skin = this.readSkin(input, skeletonData, false, nonessential);
        if (!skin)
          throw new Error("readSkin() should not have returned null.");
        skeletonData.skins[i] = skin;
      }
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error("Not skin found for linked mesh.");
      if (!linkedMesh.parent)
        throw new Error("Linked mesh parent must not be null");
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const eventName = input.readStringRef();
      if (!eventName)
        throw new Error();
      const data = new EventData(eventName);
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const animationName = input.readString();
      if (!animationName)
        throw new Error("Animatio name must not be null.");
      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
    }
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new Skin("default");
    } else {
      const skinName = input.readStringRef();
      if (!skinName)
        throw new Error("Skin name must not be null.");
      skin = new Skin(skinName);
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        if (!name)
          throw new Error("Attachment name must not be null");
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (!name)
      name = attachmentName;
    switch (input.readByte()) {
      case AttachmentType_AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        const sequence = this.readSequence(input);
        if (!path)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        core_Utils_Color.rgba8888ToColor(region.color, color);
        region.sequence = sequence;
        if (sequence == null)
          region.updateRegion();
        return region;
      }
      case AttachmentType_AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          core_Utils_Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case AttachmentType_AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        const sequence = this.readSequence(input);
        let edges = [];
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        core_Utils_Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case AttachmentType_AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritTimelines = input.readBoolean();
        const sequence = this.readSequence(input);
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        core_Utils_Color.rgba8888ToColor(mesh.color, color);
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));
        return mesh;
      }
      case AttachmentType_AttachmentType.Path: {
        const closed = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = Utils_Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = closed;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          core_Utils_Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case AttachmentType_AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          core_Utils_Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case AttachmentType_AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          core_Utils_Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readSequence(input) {
    if (this.ver40 || !input.readBoolean())
      return null;
    const sequence = new Sequence(input.readInt(true));
    sequence.start = input.readInt(true);
    sequence.digits = input.readInt(true);
    sequence.setupIndex = input.readInt(true);
    return sequence;
  }
  readDeformTimelineType(input) {
    if (this.ver40)
      return ATTACHMENT_DEFORM;
    return input.readByte();
  }
  readVertices(input, vertexCount) {
    const scale = this.scale;
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices();
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = Utils_Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    input.readInt(true);
    const timelines = new Array();
    const scale = this.scale;
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        const frameLast = frameCount - 1;
        switch (timelineType) {
          case SLOT_ATTACHMENT: {
            const timeline = new AttachmentTimeline(frameCount, slotIndex);
            for (let frame = 0; frame < frameCount; frame++)
              timeline.setFrame(frame, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA: {
            const bezierCount = input.readInt(true);
            const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
              a = a2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB: {
            const bezierCount = input.readInt(true);
            const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA2: {
            const bezierCount = input.readInt(true);
            const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const na = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              a = na;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB2: {
            const bezierCount = input.readInt(true);
            const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_ALPHA: {
            const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);
            let time = input.readFloat();
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);
              }
              time = time2;
              a = a2;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const type = input.readByte();
        const frameCount = input.readInt(true);
        const bezierCount = input.readInt(true);
        switch (type) {
          case BONE_ROTATE:
            timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_TRANSLATE:
            timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEX:
            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEY:
            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_SCALE:
            timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEX:
            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEY:
            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEAR:
            timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARX:
            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARY:
            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mix = input.readFloat();
      let softness = input.readFloat() * scale;
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mix2 = input.readFloat();
        const softness2 = input.readFloat() * scale;
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);
        }
        time = time2;
        mix = mix2;
        softness = softness2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mixRotate = input.readFloat();
      let mixX = input.readFloat();
      let mixY = input.readFloat();
      let mixScaleX = input.readFloat();
      let mixScaleY = input.readFloat();
      let mixShearY = input.readFloat();
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mixRotate2 = input.readFloat();
        const mixX2 = input.readFloat();
        const mixY2 = input.readFloat();
        const mixScaleX2 = input.readFloat();
        const mixScaleY2 = input.readFloat();
        const mixShearY2 = input.readFloat();
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);
        }
        time = time2;
        mixRotate = mixRotate2;
        mixX = mixX2;
        mixY = mixY2;
        mixScaleX = mixScaleX2;
        mixScaleY = mixScaleY2;
        mixShearY = mixShearY2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        switch (input.readByte()) {
          case PATH_POSITION:
            timelines.push(
              readTimeline1(
                input,
                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),
                data.positionMode == PositionMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_SPACING:
            timelines.push(
              readTimeline1(
                input,
                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),
                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_MIX:
            const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);
            let time = input.readFloat();
            let mixRotate = input.readFloat();
            let mixX = input.readFloat();
            let mixY = input.readFloat();
            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const mixRotate2 = input.readFloat();
              const mixX2 = input.readFloat();
              const mixY2 = input.readFloat();
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
            }
            timelines.push(timeline);
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachmentName = input.readStringRef();
          if (!attachmentName)
            throw new Error("attachmentName must not be null.");
          const attachment = skin.getAttachment(slotIndex, attachmentName);
          const timelineType = this.readDeformTimelineType(input);
          const frameCount = input.readInt(true);
          const frameLast = frameCount - 1;
          switch (timelineType) {
            case ATTACHMENT_DEFORM: {
              const vertexAttachment = attachment;
              const weighted = vertexAttachment.bones;
              const vertices = vertexAttachment.vertices;
              const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              const bezierCount = input.readInt(true);
              const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);
              let time = input.readFloat();
              for (let frame = 0, bezier = 0; ; frame++) {
                let deform;
                let end = input.readInt(true);
                if (end == 0)
                  deform = weighted ? Utils_Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = Utils_Utils.newFloatArray(deformLength);
                  const start = input.readInt(true);
                  end += start;
                  if (scale == 1) {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat();
                  } else {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat() * scale;
                  }
                  if (!weighted) {
                    for (let v = 0, vn = deform.length; v < vn; v++)
                      deform[v] += vertices[v];
                  }
                }
                timeline.setFrame(frame, time, deform);
                if (frame == frameLast)
                  break;
                const time2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);
                }
                time = time2;
              }
              timelines.push(timeline);
              break;
            }
            case ATTACHMENT_SEQUENCE: {
              const timeline = new SequenceTimeline(frameCount, slotIndex, attachment);
              for (let frame = 0; frame < frameCount; frame++) {
                const time = input.readFloat();
                const modeAndIndex = input.readInt32();
                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
              }
              timelines.push(timeline);
              break;
            }
          }
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new DrawOrderTimeline(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = Utils_Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = Utils_Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new EventTimeline(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new core_Event_Event(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    return new Animation(name, timelines, duration);
  }
}
SkeletonBinary.BlendModeValues = [lib_BLEND_MODES.NORMAL, lib_BLEND_MODES.ADD, lib_BLEND_MODES.MULTIPLY, lib_BLEND_MODES.SCREEN];
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
}
class Vertices {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
}
function readTimeline1(input, timeline, scale) {
  let time = input.readFloat();
  let value = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const value2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);
    }
    time = time2;
    value = value2;
  }
  return timeline;
}
function readTimeline2(input, timeline, scale) {
  let time = input.readFloat();
  let value1 = input.readFloat() * scale;
  let value2 = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const nvalue1 = input.readFloat() * scale;
    const nvalue2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);
        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
  }
  return timeline;
}
function setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
}
const BONE_ROTATE = 0;
const BONE_TRANSLATE = 1;
const BONE_TRANSLATEX = 2;
const BONE_TRANSLATEY = 3;
const BONE_SCALE = 4;
const BONE_SCALEX = 5;
const BONE_SCALEY = 6;
const BONE_SHEAR = 7;
const BONE_SHEARX = 8;
const BONE_SHEARY = 9;
const SLOT_ATTACHMENT = 0;
const SLOT_RGBA = 1;
const SLOT_RGB = 2;
const SLOT_RGBA2 = 3;
const SLOT_RGB2 = 4;
const SLOT_ALPHA = 5;
const ATTACHMENT_DEFORM = 0;
const ATTACHMENT_SEQUENCE = 1;
const PATH_POSITION = 0;
const PATH_SPACING = 1;
const PATH_MIX = 2;
const CURVE_STEPPED = 1;
const CURVE_BEZIER = 2;


//# sourceMappingURL=SkeletonBinary.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBounds.mjs


class SkeletonBounds extends (/* unused pure expression or super */ null && (SkeletonBoundsBase)) {
}


//# sourceMappingURL=SkeletonBounds.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonJson.mjs














class SkeletonJson {
  constructor(attachmentLoader) {
    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
     * runtime than were used in Spine.
     *
     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      const verShort = skeletonData.version.substr(0, 3);
      if (verShort !== "4.0" && verShort !== "4.1") {
        const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = getValue(boneMap, "length", 0) * scale;
        data.x = getValue(boneMap, "x", 0) * scale;
        data.y = getValue(boneMap, "y", 0) * scale;
        data.rotation = getValue(boneMap, "rotation", 0);
        data.scaleX = getValue(boneMap, "scaleX", 1);
        data.scaleY = getValue(boneMap, "scaleY", 1);
        data.shearX = getValue(boneMap, "shearX", 0);
        data.shearY = getValue(boneMap, "shearY", 0);
        data.transformMode = Utils_Utils.enumValue(TransformMode, getValue(boneMap, "transform", "Normal"));
        data.skinRequired = getValue(boneMap, "skin", false);
        const color = getValue(boneMap, "color", null);
        if (color)
          data.color.setFromString(color);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const boneData = skeletonData.findBone(slotMap.bone);
        if (!boneData)
          throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);
        const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);
        const color = getValue(slotMap, "color", null);
        if (color)
          data.color.setFromString(color);
        const dark = getValue(slotMap, "dark", null);
        if (dark)
          data.darkColor = core_Utils_Color.fromString(dark);
        data.attachmentName = getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        data.target = skeletonData.findBone(constraintMap.target);
        data.mix = getValue(constraintMap, "mix", 1);
        data.softness = getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = getValue(constraintMap, "compress", false);
        data.stretch = getValue(constraintMap, "stretch", false);
        data.uniform = getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findBone(targetName);
        if (!target)
          throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);
        data.target = target;
        data.local = getValue(constraintMap, "local", false);
        data.relative = getValue(constraintMap, "relative", false);
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.offsetX = getValue(constraintMap, "x", 0) * scale;
        data.offsetY = getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = getValue(constraintMap, "shearY", 0);
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        data.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
        data.mixScaleY = getValue(constraintMap, "mixScaleY", data.mixScaleX);
        data.mixShearY = getValue(constraintMap, "mixShearY", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findSlot(targetName);
        if (!target)
          throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);
        data.target = target;
        data.positionMode = Utils_Utils.enumValue(PositionMode, getValue(constraintMap, "positionMode", "Percent"));
        data.spacingMode = Utils_Utils.enumValue(SpacingMode, getValue(constraintMap, "spacingMode", "Length"));
        data.rotateMode = Utils_Utils.enumValue(RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.position = getValue(constraintMap, "position", 0);
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
          data.spacing *= scale;
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new Skin(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const boneName = skinMap.bones[ii];
            const bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraintName = skinMap.ik[ii];
            const constraint = skeletonData.findIkConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraintName = skinMap.transform[ii];
            const constraint = skeletonData.findTransformConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraintName = skinMap.path[ii];
            const constraint = skeletonData.findPathConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData(eventName);
        data.intValue = getValue(eventMap, "int", 0);
        data.floatValue = getValue(eventMap, "float", 0);
        data.stringValue = getValue(eventMap, "string", "");
        data.audioPath = getValue(eventMap, "audio", null);
        if (data.audioPath) {
          data.volume = getValue(eventMap, "volume", 1);
          data.balance = getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = getValue(map, "name", name);
    switch (getValue(map, "type", "region")) {
      case "region": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = getValue(map, "x", 0) * scale;
        region.y = getValue(map, "y", 0) * scale;
        region.scaleX = getValue(map, "scaleX", 1);
        region.scaleY = getValue(map, "scaleY", 1);
        region.rotation = getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        region.sequence = sequence;
        const color = getValue(map, "color", null);
        if (color)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        const color = getValue(map, "color", null);
        if (color)
          mesh.color.setFromString(color);
        mesh.width = getValue(map, "width", 0) * scale;
        mesh.height = getValue(map, "height", 0) * scale;
        mesh.sequence = sequence;
        const parent = getValue(map, "parent", null);
        if (parent) {
          this.linkedMeshes.push(new SkeletonJson_LinkedMesh(mesh, getValue(map, "skin", null), slotIndex, parent, getValue(map, "timelines", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = getValue(map, "edges", null);
        mesh.hullLength = getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = getValue(map, "closed", false);
        path.constantSpeed = getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = Utils_Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = getValue(map, "color", null);
        if (color)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = getValue(map, "x", 0) * scale;
        point.y = getValue(map, "y", 0) * scale;
        point.rotation = getValue(map, "rotation", 0);
        const color = getValue(map, "color", null);
        if (color)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        const end = getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readSequence(map) {
    if (map == null)
      return null;
    const sequence = new Sequence(getValue(map, "count", 0));
    sequence.start = getValue(map, "start", 1);
    sequence.digits = getValue(map, "digits", 0);
    sequence.setupIndex = getValue(map, "setup", 0);
    return sequence;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = Utils_Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = Utils_Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slot = skeletonData.findSlot(slotName);
        if (!slot)
          throw new Error(`Slot not found: ${slotName}`);
        const slotIndex = slot.index;
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (!timelineMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName == "attachment") {
            const timeline = new AttachmentTimeline(frames, slotIndex);
            for (let frame = 0; frame < frames; frame++) {
              const keyMap = timelineMap[frame];
              timeline.setFrame(frame, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
            }
            timelines.push(timeline);
          } else if (timelineName == "rgba") {
            const timeline = new RGBATimeline(frames, frames << 2, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = core_Utils_Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = core_Utils_Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb") {
            const timeline = new RGBTimeline(frames, frames * 3, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = core_Utils_Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = core_Utils_Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "alpha") {
            timelines.push(SkeletonJson_readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));
          } else if (timelineName == "rgba2") {
            const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = core_Utils_Color.fromString(keyMap.light);
            let color2 = core_Utils_Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = core_Utils_Color.fromString(nextMap.light);
              const newColor2 = core_Utils_Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb2") {
            const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = core_Utils_Color.fromString(keyMap.light);
            let color2 = core_Utils_Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = core_Utils_Color.fromString(nextMap.light);
              const newColor2 = core_Utils_Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const bone = skeletonData.findBone(boneName);
        if (!bone)
          throw new Error(`Bone not found: ${boneName}`);
        const boneIndex = bone.index;
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          const frames = timelineMap.length;
          if (frames == 0)
            continue;
          if (timelineName === "rotate") {
            timelines.push(SkeletonJson_readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));
          } else if (timelineName === "translate") {
            const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);
            timelines.push(SkeletonJson_readTimeline2(timelineMap, timeline, "x", "y", 0, scale));
          } else if (timelineName === "translatex") {
            const timeline = new TranslateXTimeline(frames, frames, boneIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 0, scale));
          } else if (timelineName === "translatey") {
            const timeline = new TranslateYTimeline(frames, frames, boneIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 0, scale));
          } else if (timelineName === "scale") {
            const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);
            timelines.push(SkeletonJson_readTimeline2(timelineMap, timeline, "x", "y", 1, 1));
          } else if (timelineName === "scalex") {
            const timeline = new ScaleXTimeline(frames, frames, boneIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 1, 1));
          } else if (timelineName === "scaley") {
            const timeline = new ScaleYTimeline(frames, frames, boneIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 1, 1));
          } else if (timelineName === "shear") {
            const timeline = new ShearTimeline(frames, frames << 1, boneIndex);
            timelines.push(SkeletonJson_readTimeline2(timelineMap, timeline, "x", "y", 0, 1));
          } else if (timelineName === "shearx") {
            const timeline = new ShearXTimeline(frames, frames, boneIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 0, 1));
          } else if (timelineName === "sheary") {
            const timeline = new ShearYTimeline(frames, frames, boneIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 0, 1));
          }
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        let keyMap = constraintMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findIkConstraint(constraintName);
        if (!constraint)
          throw new Error(`IK Constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mix = getValue(keyMap, "mix", 1);
        let softness = getValue(keyMap, "softness", 0) * scale;
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(
            frame,
            time,
            mix,
            softness,
            getValue(keyMap, "bendPositive", true) ? 1 : -1,
            getValue(keyMap, "compress", false),
            getValue(keyMap, "stretch", false)
          );
          const nextMap = constraintMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mix2 = getValue(nextMap, "mix", 1);
          const softness2 = getValue(nextMap, "softness", 0) * scale;
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix = mix2;
          softness = softness2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const timelineMap = map.transform[constraintName];
        let keyMap = timelineMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findTransformConstraint(constraintName);
        if (!constraint)
          throw new Error(`Transform constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mixRotate = getValue(keyMap, "mixRotate", 1);
        let mixX = getValue(keyMap, "mixX", 1);
        let mixY = getValue(keyMap, "mixY", mixX);
        let mixScaleX = getValue(keyMap, "mixScaleX", 1);
        let mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
        const mixShearY = getValue(keyMap, "mixShearY", 1);
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          const nextMap = timelineMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mixRotate2 = getValue(nextMap, "mixRotate", 1);
          const mixX2 = getValue(nextMap, "mixX", 1);
          const mixY2 = getValue(nextMap, "mixY", mixX2);
          const mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
          const mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
          const mixShearY2 = getValue(nextMap, "mixShearY", 1);
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixScaleX = mixScaleX2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const constraint = skeletonData.findPathConstraint(constraintName);
        if (!constraint)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          let keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName === "position") {
            const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);
            timelines.push(SkeletonJson_readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));
          } else if (timelineName === "spacing") {
            const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);
            timelines.push(
              SkeletonJson_readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)
            );
          } else if (timelineName === "mix") {
            const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);
            let time = getValue(keyMap, "time", 0);
            let mixRotate = getValue(keyMap, "mixRotate", 1);
            let mixX = getValue(keyMap, "mixX", 1);
            let mixY = getValue(keyMap, "mixY", mixX);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const mixRotate2 = getValue(nextMap, "mixRotate", 1);
              const mixX2 = getValue(nextMap, "mixX", 1);
              const mixY2 = getValue(nextMap, "mixY", mixX2);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.deform) {
      map.attachments = {};
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const outMap = map.attachments[deformName] = {};
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const outMap2 = outMap[slotName] = {};
          for (const innerMapName in slotMap) {
            outMap2[innerMapName] = {
              deform: slotMap[innerMapName]
            };
          }
        }
      }
    }
    if (map.attachments) {
      for (const attachmentsName in map.attachments) {
        const attachmentsMap = map.attachments[attachmentsName];
        const skin = skeletonData.findSkin(attachmentsName);
        if (skin == null) {
          if (settings_settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${attachmentsName}`);
          } else {
            continue;
          }
        }
        for (const slotMapName in attachmentsMap) {
          const slotMap = attachmentsMap[slotMapName];
          const slot = skeletonData.findSlot(slotMapName);
          if (!slot)
            throw new Error(`Slot not found: ${slotMapName}`);
          const slotIndex = slot.index;
          for (const attachmentMapName in slotMap) {
            const attachmentMap = slotMap[attachmentMapName];
            const attachment = skin.getAttachment(slotIndex, attachmentMapName);
            for (const timelineMapName in attachmentMap) {
              const timelineMap = attachmentMap[timelineMapName];
              let keyMap = timelineMap[0];
              if (!keyMap)
                continue;
              if (timelineMapName == "deform") {
                const weighted = attachment.bones;
                const vertices = attachment.vertices;
                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);
                let time = getValue(keyMap, "time", 0);
                for (let frame = 0, bezier = 0; ; frame++) {
                  let deform;
                  const verticesValue = getValue(keyMap, "vertices", null);
                  if (!verticesValue)
                    deform = weighted ? Utils_Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = Utils_Utils.newFloatArray(deformLength);
                    const start = getValue(keyMap, "offset", 0);
                    Utils_Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                    if (scale != 1) {
                      for (let i = start, n = i + verticesValue.length; i < n; i++)
                        deform[i] *= scale;
                    }
                    if (!weighted) {
                      for (let i = 0; i < deformLength; i++)
                        deform[i] += vertices[i];
                    }
                  }
                  timeline.setFrame(frame, time, deform);
                  const nextMap = timelineMap[frame + 1];
                  if (!nextMap) {
                    timeline.shrink(bezier);
                    break;
                  }
                  const time2 = getValue(nextMap, "time", 0);
                  const curve = keyMap.curve;
                  if (curve)
                    bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);
                  time = time2;
                  keyMap = nextMap;
                }
                timelines.push(timeline);
              } else if (timelineMapName == "sequence") {
                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment);
                let lastDelay = 0;
                for (let frame = 0; frame < timelineMap.length; frame++) {
                  const delay = getValue(keyMap, "delay", lastDelay);
                  const time = getValue(keyMap, "time", 0);
                  const mode = SequenceMode[getValue(keyMap, "mode", "hold")];
                  const index = getValue(keyMap, "index", 0);
                  timeline.setFrame(frame, time, mode, index, delay);
                  lastDelay = delay;
                  keyMap = timelineMap[frame + 1];
                }
                timelines.push(timeline);
              }
            }
          }
        }
      }
    }
    if (map.drawOrder) {
      const timeline = new DrawOrderTimeline(map.drawOrder.length);
      const slotCount = skeletonData.slots.length;
      let frame = 0;
      for (let i = 0; i < map.drawOrder.length; i++, frame++) {
        const drawOrderMap = map.drawOrder[i];
        let drawOrder = null;
        const offsets = getValue(drawOrderMap, "offsets", null);
        if (offsets) {
          drawOrder = Utils_Utils.newArray(slotCount, -1);
          const unchanged = Utils_Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let ii = 0; ii < offsets.length; ii++) {
            const offsetMap = offsets[ii];
            const slot = skeletonData.findSlot(offsetMap.slot);
            if (!slot)
              throw new Error(`Slot not found: ${slot}`);
            const slotIndex = slot.index;
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frame, getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
    }
    if (map.events) {
      const timeline = new EventTimeline(map.events.length);
      let frame = 0;
      for (let i = 0; i < map.events.length; i++, frame++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (!eventData)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new core_Event_Event(Utils_Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
        event.intValue = getValue(eventMap, "int", eventData.intValue);
        event.floatValue = getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath) {
          event.volume = getValue(eventMap, "volume", 1);
          event.balance = getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frame, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation(name, timelines, duration));
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return lib_BLEND_MODES.NORMAL;
    if (str == "additive")
      return lib_BLEND_MODES.ADD;
    if (str == "multiply")
      return lib_BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return lib_BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
}
class SkeletonJson_LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
}
function SkeletonJson_readTimeline1(keys, timeline, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value = getValue(keyMap, "value", defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const value2 = getValue(nextMap, "value", defaultValue) * scale;
    if (keyMap.curve)
      bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
    time = time2;
    value = value2;
    keyMap = nextMap;
  }
}
function SkeletonJson_readTimeline2(keys, timeline, name1, name2, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value1 = getValue(keyMap, name1, defaultValue) * scale;
  let value2 = getValue(keyMap, name2, defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;
    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;
    const curve = keyMap.curve;
    if (curve) {
      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
    keyMap = nextMap;
  }
}
function readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  if (curve == "stepped") {
    timeline.setStepped(frame);
    return bezier;
  }
  const i = value << 2;
  const cx1 = curve[i];
  const cy1 = curve[i + 1] * scale;
  const cx2 = curve[i + 2];
  const cy2 = curve[i + 3] * scale;
  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
  return bezier + 1;
}
function getValue(map, property, defaultValue) {
  return map[property] !== void 0 ? map[property] : defaultValue;
}


//# sourceMappingURL=SkeletonJson.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationStateData.mjs
class AnimationStateData {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    /** The mix duration to use when no mix duration has been defined between two animations. */
    this.defaultMix = 0;
    if (!skeletonData)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  /** Sets a mix duration by animation name.
   *
   * See {@link #setMixWith()}. */
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (!from)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (!to)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  /** Sets the mix duration when changing from the specified animation to the other.
   *
   * See {@link TrackEntry#mixDuration}. */
  setMixWith(from, to, duration) {
    if (!from)
      throw new Error("from cannot be null.");
    if (!to)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if
   * no mix duration has been set. */
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
}


//# sourceMappingURL=AnimationStateData.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/Spine.mjs





class Spine extends SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData(spineData);
    this.state = new AnimationState(this.stateData);
  }
}


//# sourceMappingURL=Spine.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs
































//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/loader-4.1/lib/index.mjs



class SpineParser extends SpineLoaderAbstract {
  createBinaryParser() {
    return new SkeletonBinary(null);
  }
  createJsonParser() {
    return new SkeletonJson(null);
  }
  parseData(parser, atlas, dataToParse) {
    const parserCast = parser;
    parserCast.attachmentLoader = new AtlasAttachmentLoader(atlas);
    return {
      spineData: parserCast.readSkeletonData(dataToParse),
      spineAtlas: atlas
    };
  }
}
new SpineParser().installLoader();
//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi-spine/all-4.1/lib/index.mjs



//# sourceMappingURL=index.mjs.map

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/utils/GraphicUtils.ts



class GraphicUtils {
    static init(renderer) {
        this.renderer = renderer;
    }
    static processSymbolsData(symbolsData) {
        if (!this.renderer) {
            throw new Error('Please call init function first!');
        }
        let frameCount = 0;
        const processNextSymbol = (resolve) => {
            if (frameCount >= symbolsData.length) {
                return resolve();
            }
            else {
                const sd = symbolsData[frameCount];
                GraphicUtils.generateIconTexture(sd.staticIcon);
                sd.spinIcon = sd.staticIcon;
                if (sd.spineAnimations) {
                    sd.spineAnimations.skeletonData = assets_AssetsManager.spine.get(sd.spineAnimations.spineAssetName);
                }
                frameCount++;
                requestAnimationFrame(() => {
                    processNextSymbol(resolve);
                });
            }
        };
        return new Promise((resolve) => {
            requestAnimationFrame(() => {
                processNextSymbol(resolve);
            });
        });
    }
    static generateTextureFromSpine(spineAnimation, filters = []) {
        // caculate texture size
        const localBounds = spineAnimation.getLocalBounds();
        let symbolWidth = 0;
        let symbolHeight = 0;
        if (localBounds.x < 0) {
            symbolWidth = Math.round(Math.max(-localBounds.x, localBounds.width / 2)) * 2 + 10;
        }
        else {
            symbolWidth = Math.round(localBounds.x + localBounds.width) + 10;
        }
        if (localBounds.y < 0) {
            symbolHeight = Math.round(Math.max(-localBounds.y, localBounds.height / 2)) * 2 + 10;
        }
        else {
            symbolHeight = Math.round(localBounds.y + localBounds.height) + 10;
        }
        // place spine in the container center
        const oldX = spineAnimation.position.x;
        const oldY = spineAnimation.position.y;
        const oldVisibility = spineAnimation.visible;
        spineAnimation.visible = true;
        spineAnimation.position.set(symbolWidth / 2, symbolHeight / 2);
        const symbolContainer = new Container_Container();
        symbolContainer.addChild(spineAnimation);
        // apply filters if any
        symbolContainer.filters = filters;
        // create render texture and render
        const renderTexture = RenderTexture.create({
            width: symbolWidth,
            height: symbolHeight,
        });
        GraphicUtils.renderer.render(symbolContainer, {
            renderTexture: renderTexture
        });
        // cleanup
        spineAnimation.position.set(oldX, oldY);
        spineAnimation.visible = oldVisibility;
        symbolContainer.removeChild(spineAnimation);
        symbolContainer.destroy({
            children: true
        });
        return renderTexture;
    }
    static generateIconTexture(iconData) {
        var _a, _b, _c, _d;
        if (!iconData) {
            return;
        }
        switch (iconData.sourceType) {
            case 'texture':
                iconData.texture = assets_AssetsManager.textures.get(iconData.assetName);
                // apply blur filter
                if (iconData.blurY || iconData.blurX) {
                    const originalTexture = iconData.texture;
                    const blurTexture = RenderTexture.create({
                        width: originalTexture.width,
                        height: originalTexture.height,
                    });
                    const icon = new Sprite(originalTexture);
                    const blurFilter = new BlurFilter();
                    blurFilter.blurY = (_a = iconData.blurY) !== null && _a !== void 0 ? _a : blurFilter.blurY;
                    blurFilter.blurX = (_b = iconData.blurX) !== null && _b !== void 0 ? _b : blurFilter.blurX;
                    blurFilter.quality = 10;
                    blurFilter.autoFit = false;
                    blurFilter.blendMode = lib_BLEND_MODES.SCREEN;
                    icon.filters = [blurFilter];
                    GraphicUtils.renderer.render(icon, {
                        renderTexture: blurTexture
                    });
                    iconData.texture = blurTexture;
                    // cleanup
                    icon.destroy({
                        children: true
                    });
                }
                break;
            case 'spine':
                // create actual symbol
                const spineSymbol = new Spine(assets_AssetsManager.spine.get(iconData.assetName));
                if (iconData.animationName) {
                    spineSymbol.state.setAnimation(0, iconData.animationName, false);
                }
                // set skin for symbol
                if (iconData.skinName) {
                    spineSymbol.skeleton.setSkinByName(iconData.skinName);
                }
                spineSymbol.autoUpdate = false;
                spineSymbol.update(0);
                // apply blur filter
                const filters = [];
                if (iconData.blurY || iconData.blurX) {
                    const blurFilter = new BlurFilter();
                    blurFilter.blurY = (_c = iconData.blurY) !== null && _c !== void 0 ? _c : blurFilter.blurY;
                    blurFilter.blurX = (_d = iconData.blurX) !== null && _d !== void 0 ? _d : blurFilter.blurX;
                    blurFilter.quality = 10;
                    blurFilter.autoFit = false;
                    blurFilter.blendMode = lib_BLEND_MODES.SCREEN;
                    filters.push(blurFilter);
                }
                iconData.texture = GraphicUtils.generateTextureFromSpine(spineSymbol, filters);
                break;
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/popup/PopupAnimationConfig.ts
function getMaxAnimationTime(popupAnimationConfig) {
    const times = getNestedProperty('time', popupAnimationConfig);
    return Math.max(...times);
}
function getNestedProperty(keyToFind, object) {
    let times = [];
    for (const key in object) {
        if (key == keyToFind) {
            times.unshift(object[key]);
        }
        const nested = object[key];
        if (typeof nested == 'object') {
            times = [...times, ...getNestedProperty(keyToFind, nested)];
        }
    }
    return times;
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/utils/GraphicUtils.ts

class GraphicUtils_GraphicUtils {
    static createRectGraphics(graphicSettings) {
        graphicSettings.alpha = typeof graphicSettings.alpha == 'undefined' ? 1 : graphicSettings.alpha;
        graphicSettings.anchor = typeof graphicSettings.anchor == 'undefined' ? { x: 0, y: 0 } : graphicSettings.anchor;
        graphicSettings.color = typeof graphicSettings.color == 'undefined' ? 0x000000 : graphicSettings.color;
        graphicSettings.baseAlpha = typeof graphicSettings.baseAlpha == 'undefined' ? 1 : graphicSettings.baseAlpha;
        graphicSettings.position = typeof graphicSettings.position == 'undefined' ? new Point(0, 0) : graphicSettings.position;
        graphicSettings.size = typeof graphicSettings.size == 'undefined' ? new Point(100, 100) : graphicSettings.size;
        graphicSettings.eventMode = typeof graphicSettings.eventMode == 'undefined' ? 'none' : graphicSettings.eventMode;
        graphicSettings.cursor = typeof graphicSettings.cursor == 'undefined' ? 'auto' : graphicSettings.cursor;
        const graphics = new Graphics_Graphics();
        graphics.beginFill(graphicSettings.color, graphicSettings.baseAlpha);
        graphics.drawRect(graphicSettings.position.x, graphicSettings.position.y, graphicSettings.size.x, graphicSettings.size.y);
        graphics.endFill();
        graphics.alpha = graphicSettings.alpha;
        graphics.pivot.set(graphics.width * graphicSettings.anchor.x, graphics.height * graphicSettings.anchor.y);
        graphics.eventMode = graphicSettings.eventMode;
        graphics.cursor = graphicSettings.cursor;
        return graphics;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/utils/PopupUtils.ts

class PopupUtils {
    static DoScale(dp, params, startScale, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        dp.scale.set(startScale);
        ignitionTween.Tweener.addTween(dp.scale, {
            x: params.value,
            y: params.value,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
    static DoAlphaFade(dp, params, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        ignitionTween.Tweener.addTween(dp, {
            alpha: params.value,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
    static DoChangeY(dp, params, startY, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        dp.y = startY;
        ignitionTween.Tweener.addTween(dp, {
            y: params.value,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
    static DoChangePivotY(dp, params, startY, endY, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        console.log(dp);
        console.log('is changing');
        dp.pivot.y = startY;
        ignitionTween.Tweener.addTween(dp.pivot, {
            y: endY,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/popup/PopupManager.ts








class PopupManager extends AdjustableLayoutContainer {
    constructor() {
        super(null);
        this.activeAnimationConfigResolver = null;
        this.activeSoundConfig = null;
        this.callbacks = null;
        this.closeOnClick = true;
        this.pivotMap = new Map();
        this.scaleMap = new Map();
        this.overlay = new Container_Container();
        const blackRect = GraphicUtils_GraphicUtils.createRectGraphics({
            color: 0x000000,
            alpha: 1,
            size: new Point(100, 100),
        });
        blackRect.eventMode = 'auto';
        this.overlay.addChild(blackRect);
        this.overlay.pivot.set(50, 50);
        this.overlay.eventMode = 'static';
        this.eventMode = 'dynamic';
        this.cursor = 'pointer';
        this.on('pointerup', this.onClick, this);
    }
    updateLayout(desc) {
        var _a, _b, _c, _d;
        this.overlay.width = desc.currentWidth;
        this.overlay.height = desc.currentHeight;
        this.overlay.position.set(0, 0);
        (_b = (_a = this.horizontalPopup) === null || _a === void 0 ? void 0 : _a['updateLayout']) === null || _b === void 0 ? void 0 : _b.call(_a, desc);
        (_d = (_c = this.verticalPopup) === null || _c === void 0 ? void 0 : _c['updateLayout']) === null || _d === void 0 ? void 0 : _d.call(_c, desc);
        super.updateLayout(desc);
        this.currentOrientation = desc.orientation;
        this.updateView();
    }
    updateView() {
        if (this.horizontalPopup)
            this.horizontalPopup.visible = this.currentOrientation == ScreenOrientation.HORIZONTAL;
        if (this.verticalPopup)
            this.verticalPopup.visible = this.currentOrientation == ScreenOrientation.VERTICAL;
    }
    // PUBLIC API
    show(horizontalPopup, verticalPopup, duration = -1, closeOnClick = false, callbacks = null, animationConfigResolver = () => PopupManager.defaultAnimationConfiguration, soundConfig = PopupManager.defaultSoundConfiguration) {
        // To prevent displaying multiple popups at the same time
        // [this.horizontalPopup, this.verticalPopup].forEach((popup: DisplayObject): void => {
        //     if (popup != null) {
        //         popup.destroy({ children: true });
        //     }
        // });
        //Tweener.removeTweens(this);
        var _a, _b, _c, _d;
        // Clean previous tweens
        ignitionTween.Tweener.removeTweens(this);
        ignitionTween.Tweener.removeTweens(this.overlay);
        if (this.horizontalPopup) {
            ignitionTween.Tweener.removeTweens(this.horizontalPopup);
        }
        if (this.verticalPopup) {
            ignitionTween.Tweener.removeTweens(this.verticalPopup);
        }
        // Cache initial state for each new popup
        const animationConfig = animationConfigResolver === null || animationConfigResolver === void 0 ? void 0 : animationConfigResolver();
        if (!this.pivotMap.has(horizontalPopup)) {
            this.pivotMap.set(horizontalPopup, horizontalPopup.pivot.y);
            this.scaleMap.set(horizontalPopup, horizontalPopup.scale.x);
        }
        if (!this.pivotMap.has(verticalPopup)) {
            this.pivotMap.set(verticalPopup, verticalPopup.pivot.y);
            this.scaleMap.set(verticalPopup, verticalPopup.scale.x);
        }
        // Force animation resets
        [this.horizontalPopup, this.verticalPopup].forEach((popup) => {
            if (popup) {
                popup.alpha = 1;
                popup.scale.set(this.scaleMap.get(popup));
                popup.pivot.y = this.pivotMap.get(popup);
                this.removeChild(popup);
            }
        });
        // Cache other data
        this.callbacks = callbacks;
        this.closeOnClick = closeOnClick;
        this.cursor = closeOnClick ? 'pointer' : 'auto';
        if (animationConfigResolver) {
            this.activeAnimationConfigResolver = animationConfigResolver;
        }
        else {
            this.activeAnimationConfigResolver = null;
        }
        this.activeSoundConfig = soundConfig ? soundConfig : null;
        // Show sound
        if (soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.showSound) {
            this.showSound = sound_SoundManager.play(soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.showSound);
        }
        // Show overlay
        if (animationConfig.showOverlay) {
            this.removeChild(this.overlay);
            PopupUtils.DoAlphaFade(this.overlay, (_b = (_a = animationConfig.showOverlay) === null || _a === void 0 ? void 0 : _a.alpha) !== null && _b !== void 0 ? _b : null);
            PopupUtils.DoScale(this.overlay, (_d = (_c = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.showOverlay) === null || _c === void 0 ? void 0 : _c.scale) !== null && _d !== void 0 ? _d : null, 0);
            if (!this.overlay.parent) {
                this.addChild(this.overlay);
            }
        }
        if (horizontalPopup) {
            this.horizontalPopup = horizontalPopup;
            this.addChild(horizontalPopup);
            horizontalPopup.pivot.y = this.pivotMap.get(horizontalPopup);
            horizontalPopup.scale.set(this.scaleMap.get(horizontalPopup));
        }
        if (verticalPopup) {
            this.verticalPopup = verticalPopup;
            this.addChild(verticalPopup);
            verticalPopup.pivot.y = this.pivotMap.get(verticalPopup);
            verticalPopup.scale.set(this.scaleMap.get(verticalPopup));
        }
        if (!animationConfig) {
            this.updateView();
            return;
        }
        if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.showPopup) {
            this.updateView();
            let hideCalled = false;
            [horizontalPopup, verticalPopup].forEach((popup) => {
                PopupUtils.DoAlphaFade(popup, animationConfig.showPopup.alpha, null, () => {
                    popup.filters = [];
                });
                PopupUtils.DoScale(popup, animationConfig.showPopup.scale, 0, null, () => {
                    if (callbacks && callbacks.onPopupShown && this.visible) {
                        callbacks.onPopupShown();
                    }
                    if (duration != -1 && this.visible && !hideCalled) {
                        hideCalled = true;
                        ignitionTween.Tweener.addCaller(this, {
                            count: 1,
                            time: duration,
                            onComplete: () => {
                                this.hide(false);
                            },
                        });
                    }
                });
                PopupUtils.DoChangePivotY(popup, animationConfig.showPopup.pivotY, 0, this.pivotMap.get(popup), null, () => {
                    if (callbacks && callbacks.onPopupShown && this.visible) {
                        callbacks.onPopupShown();
                    }
                    if (duration != -1 && this.visible && !hideCalled) {
                        ignitionTween.Tweener.addCaller(this, {
                            count: 1,
                            time: duration,
                            onComplete: () => {
                                this.hide(false);
                            },
                        });
                    }
                });
            });
        }
    }
    hide(destroy = false) {
        var _a, _b, _c, _d, _e;
        // Clean previous state
        const animationConfig = (_a = this.activeAnimationConfigResolver) === null || _a === void 0 ? void 0 : _a.call(this);
        const soundConfig = this.activeSoundConfig;
        const callbacks = this.callbacks;
        const horizontalPopup = this.horizontalPopup;
        const verticalPopup = this.verticalPopup;
        this.cursor = 'auto';
        this.activeAnimationConfigResolver = null;
        this.activeSoundConfig = null;
        this.callbacks = null;
        if (this.showSound) {
            this.showSound.stop();
        }
        if (soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.hideSound) {
            sound_SoundManager.play(soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.hideSound);
        }
        if (!animationConfig) {
            this.removeChild(this.horizontalPopup);
            this.removeChild(this.verticalPopup);
            return;
        }
        if (callbacks && callbacks.onPopupBeforeHide) {
            callbacks.onPopupBeforeHide();
        }
        const animationsMaxTime = getMaxAnimationTime(animationConfig);
        if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.hidePopup) {
            [horizontalPopup, verticalPopup].forEach((popup) => {
                PopupUtils.DoAlphaFade(popup, animationConfig.hidePopup.alpha, null, () => {
                    popup.filters = [];
                });
                PopupUtils.DoScale(popup, animationConfig.hidePopup.scale, popup.scale.x, null, null);
                PopupUtils.DoChangePivotY(popup, animationConfig.hidePopup.pivotY, this.pivotMap.get(popup), 0, null, null);
            });
            ignitionTween.Tweener.addCaller(this, {
                count: 1,
                time: animationsMaxTime,
                onComplete: () => {
                    [horizontalPopup, verticalPopup].forEach((popup) => {
                        if (popup) {
                            this.removeChild(popup);
                            popup.alpha = 1;
                            popup.scale.set(this.scaleMap.get(popup));
                            popup.pivot.y = this.pivotMap.get(popup);
                            if (destroy) {
                                popup.destroy();
                            }
                        }
                    });
                },
            });
        }
        if (animationConfig.hideOverlay) {
            PopupUtils.DoScale(this.overlay, (_c = (_b = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.hideOverlay) === null || _b === void 0 ? void 0 : _b.scale) !== null && _c !== void 0 ? _c : null, this.overlay.scale.x);
            PopupUtils.DoAlphaFade(this.overlay, (_e = (_d = animationConfig.hideOverlay) === null || _d === void 0 ? void 0 : _d.alpha) !== null && _e !== void 0 ? _e : null, () => {
                if (callbacks && callbacks.onPopupHidden) {
                    callbacks.onPopupHidden();
                }
                // Destroy popups after all animations complete (otherwise popups are destroyed with the animations)
                ignitionTween.Tweener.addCaller(this, {
                    count: 1,
                    time: animationsMaxTime,
                    onComplete: () => {
                        this.removeChild(this.overlay);
                    },
                });
            });
        }
    }
    // USER INTERACTION
    onClick() {
        if (this.verticalPopup && this.horizontalPopup && this.closeOnClick) {
            this.hide(false);
        }
    }
}
PopupManager.defaultAnimationConfiguration = {
    showPopup: {
        scale: {
            value: 1,
            time: 0.3,
            transition: 'easeOutBack',
        },
        alpha: {
            value: 1,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        alpha: {
            value: 0,
            time: 0.3,
            transition: 'easeInQuad',
        },
        scale: {
            value: 0,
            time: 0.3,
            transition: 'easeInBack',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.8,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
    },
};
PopupManager.jumpAnimationConfiguration = {
    showPopup: {
        scale: {
            value: 1,
            time: 0.35,
            transition: 'easeOutBack',
        },
        alpha: {
            value: 1,
            time: 0,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
        scale: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.8,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.15,
            transition: 'easeInQuad',
        },
    },
};
PopupManager.slideAnimationConfiguration = {
    showPopup: {
        pivotY: {
            time: 0.7,
            transition: 'easeOutSine',
        },
        alpha: {
            value: 1,
            time: 0,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        pivotY: {
            time: 0.7,
            transition: 'easeOutSine',
        },
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.8,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.15,
            transition: 'easeInQuad',
        },
    },
};
PopupManager.defaultSoundConfiguration = {};
/* harmony default export */ const popup_PopupManager = (PopupManager);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/event/UIEventExtension.ts
var UIEventExtension;
(function (UIEventExtension) {
    UIEventExtension["BET_QUANTITY_UP"] = "onBetQuantityUp";
    UIEventExtension["BET_QUANTITY_DOWN"] = "onBetQuantityDown";
    UIEventExtension["BET_QUANTITY_MAX"] = "onBetQuantityMax";
    UIEventExtension["TOTAL_BET_UP"] = "onTotalBetUp";
    UIEventExtension["TOTAL_BET_DOWN"] = "onTotalBetDown";
    UIEventExtension["GAME_SPEED_LEVEL_SELECT"] = "gameSpeedLevelSelect";
})(UIEventExtension || (UIEventExtension = {}));

;// CONCATENATED MODULE: ./src/the-miner/control/command/AdjustBetQuantityCommand.ts




class AdjustBetQuantityCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        switch (event.type) {
            case UIEventExtension.BET_QUANTITY_UP:
                sm.betQuantity++;
                break;
            case UIEventExtension.BET_QUANTITY_DOWN:
                sm.betQuantity--;
                break;
            case UIEventExtension.BET_QUANTITY_MAX:
                sm.betQuantity = sm.description.betMaxQuantity;
                break;
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/control/command/AdjustTotalBetCommand.ts





class AdjustTotalBetCommand extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const currentQuantity = sm.betQuantity;
        const currentCoinValue = wallet.coinValue;
        const currentTotalBet = parseFloat((currentQuantity * currentCoinValue * this.numBets()).toFixed(2));
        let coinValueIndex;
        let totalBetChangedCoinValue;
        let totalBetCurrentCoinValue;
        const coinValueLimits = wallet.coinValueLimits;
        switch (event.type) {
            case UIEventExtension.TOTAL_BET_UP:
                coinValueIndex = (coinValueLimits.indexOf(wallet.coinValue) + 1 < coinValueLimits.length) ? coinValueLimits.indexOf(wallet.coinValue) + 1 : coinValueLimits.length - 1;
                if (sm.betQuantity == sm.description.betMaxQuantity) {
                    wallet.coinValue = coinValueLimits[coinValueIndex];
                    sm.betQuantity = this.findBiggestQuantity(currentTotalBet, coinValueLimits[coinValueIndex]);
                }
                else {
                    sm.betQuantity++;
                }
                break;
            case UIEventExtension.TOTAL_BET_DOWN:
                coinValueIndex = coinValueLimits.indexOf(wallet.coinValue);
                const lowerCoinValue = coinValueLimits[coinValueIndex - 1 > 0 ? coinValueIndex - 1 : 0];
                const lowestQuantity = this.findLowestQuantity(currentTotalBet, lowerCoinValue);
                const lowerBetQuantity = sm.betQuantity - 1 > 0 ? (sm.betQuantity - 1) : 0;
                totalBetChangedCoinValue = lowerCoinValue * lowestQuantity * this.numBets();
                totalBetCurrentCoinValue = lowerBetQuantity * wallet.coinValue * this.numBets();
                if (totalBetCurrentCoinValue.toFixed(2) > totalBetChangedCoinValue.toFixed(2) || coinValueIndex == 0) {
                    sm.betQuantity--;
                }
                else {
                    sm.betQuantity = lowestQuantity;
                    wallet.coinValue = lowerCoinValue;
                }
                break;
        }
    }
    findBiggestQuantity(currentTotalBet, coinValue) {
        let quantity = 1;
        let newTotalBet = parseFloat((quantity * coinValue * this.numBets()).toFixed(2));
        while (newTotalBet <= currentTotalBet) {
            quantity++;
            newTotalBet = parseFloat((quantity * coinValue * this.numBets()).toFixed(2));
        }
        return quantity;
    }
    findLowestQuantity(currentTotalBet, coinValue) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        let quantity = sm.description.betMaxQuantity;
        let newTotalBet = quantity * coinValue * this.numBets();
        while (newTotalBet >= currentTotalBet) {
            quantity--;
            newTotalBet = quantity * coinValue * this.numBets();
        }
        return quantity;
    }
    numBets() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        return sm.numLines == 0 ? sm.combinations : sm.numLines;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/event/SlotGameEventExtension.ts
var SlotGameEventExtension;
(function (SlotGameEventExtension) {
    SlotGameEventExtension["BUY_FREESPINS"] = "onBuyFreespins";
    SlotGameEventExtension["BUY_HOLD_AND_SPINNER"] = "onBuyHoldAndSpinner";
    SlotGameEventExtension["HOLD_AND_SPINNER_START"] = "onSlotGameHoldAndSpinnerStart";
    SlotGameEventExtension["HOLD_AND_SPINNER_ROUND_COMPLETE"] = "onSlotGameHoldAndSpinnerRoundComplete";
})(SlotGameEventExtension || (SlotGameEventExtension = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/FeatureTypes.ts
var FeatureTypes;
(function (FeatureTypes) {
    FeatureTypes[FeatureTypes["FREESPIN"] = 2] = "FREESPIN";
    FeatureTypes[FeatureTypes["HOLD_AND_SPINNER"] = 3] = "HOLD_AND_SPINNER";
})(FeatureTypes || (FeatureTypes = {}));

;// CONCATENATED MODULE: ./src/the-miner/control/command/BuyFeatureCommandOverride.ts












class BuyFeatureCommandOverride extends ControlCommand {
    execute(event) {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const sm = dependency_container_instance.resolve(SlotMachine);
        const gs = dependency_container_instance.resolve(services_GameService);
        let featureRate;
        if (event.type == SlotGameEventExtension.BUY_FREESPINS) {
            featureRate = gs.featureBuyConfig.config.find(feature => feature.RoundType == FeatureTypes.FREESPIN);
        }
        else {
            featureRate = gs.featureBuyConfig.config.find(feature => feature.RoundType == FeatureTypes.HOLD_AND_SPINNER);
        }
        const totalBet = featureRate.Multiplier * sm.totalBet * wallet.coinValue;
        if (wallet.balance < totalBet) {
            if (sm.autoplay.enabled) {
                sm.autoplay.spinsLeft = 0;
                sm.autoplay.enabled = false;
            }
            sm.currentState = SlotMachineState.IDLE;
            wallet.emit(WalletEvent.NOT_ENOUGH_BALANCE);
            return;
        }
        wallet.balance -= totalBet;
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult.totalWinValue = 0;
        sm.roundResult = null;
        sm.currentState = SlotMachineState.SPINNING;
        gs.buyFeature()
            .then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
        })
            .catch((e) => {
            utils_Logger.error(e);
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            wallet.balance += totalBet;
            sm.currentState = SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}

;// CONCATENATED MODULE: ./src/the-miner/control/command/CompleteRoundCommandOverride.ts







class CompleteRoundCommandOverride extends ControlCommand {
    execute() {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.roundResult.complete = true;
        const winValue = sm.currentSpinResult.currentTotalWinValue;
        wallet.balance += winValue;
        if (sm.autoplay.enabled && sm.autoplay.canAutoSpin(sm.roundResult, wallet.credits)) {
            if (sm.autoplay.spinsLeft > 0)
                sm.autoplay.spinsLeft -= 1;
            setTimeout(() => {
                new ControlEvent(SlotGameEvent.SPIN_START).dispatch();
            }, 0);
        }
        else {
            sm.autoplay.spinsLeft = 0;
            sm.autoplay.enabled = false;
            sm.currentState = SlotMachineState.IDLE;
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/control/command/SpinStartCommandOverride.ts










class SpinStartCommandOverride extends ControlCommand {
    execute() {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const sm = dependency_container_instance.resolve(SlotMachine);
        const totalBet = sm.totalBet * wallet.coinValue;
        if (wallet.balance < totalBet) {
            if (sm.autoplay.enabled) {
                sm.autoplay.spinsLeft = 0;
                sm.autoplay.enabled = false;
            }
            sm.currentState = SlotMachineState.IDLE;
            wallet.emit(WalletEvent.NOT_ENOUGH_BALANCE);
            return;
        }
        wallet.balance -= totalBet;
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        //sm.roundResult.totalWinValue = 0;
        sm.roundResult = null;
        sm.currentState = SlotMachineState.SPINNING;
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.spin()
            .then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
        })
            .catch((e) => {
            console.log(e);
            utils_Logger.error(e);
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            wallet.balance += totalBet;
            sm.currentState = SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/event/AdjustBetSettingsStateEvent.ts
var AdjustBetSettingsStateEvent;
(function (AdjustBetSettingsStateEvent) {
    AdjustBetSettingsStateEvent["CURRENT_BET_ID_UPDATE"] = "onCurrentBetIdUpdate";
    AdjustBetSettingsStateEvent["CURRENT_BET_VALUE_UPDATE"] = "onCurrentBetValueUpdate";
})(AdjustBetSettingsStateEvent || (AdjustBetSettingsStateEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/AdjustBetSettingsState.ts




class AdjustBetSettingsState extends (eventemitter3_default()) {
    constructor() {
        super(...arguments);
        this._currentBetId = 0;
    }
    updateCurrentBetId(value) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        const betLimits = sm.description.betLimits;
        this._currentBetId = Math.min(Math.max(0, value), betLimits.length - 1);
        this._currentBetValue = betLimits[this._currentBetId];
        this.emit(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, this._currentBetId);
        this.emit(AdjustBetSettingsStateEvent.CURRENT_BET_VALUE_UPDATE, this._currentBetValue);
    }
    get currentBetId() {
        return this._currentBetId;
    }
    get curretnBetValue() {
        return this._currentBetValue;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/AdjustBetSettingsCommand.ts



;
class AdjustBetSettingsCommand extends ControlCommand {
    execute(event) {
        const settingsState = dependency_container_instance.resolve(AdjustBetSettingsState);
        const id = event.data;
        settingsState.updateCurrentBetId(id);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/AdjustGameSpeedCommandOverride.ts



class AdjustGameSpeedCommandOverride extends ControlCommand {
    execute(event) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentGameSpeedLevel = event === null || event === void 0 ? void 0 : event.data;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/event/SpeedSettingsStateEvent.ts
var SpeedSettingsStateEvent;
(function (SpeedSettingsStateEvent) {
    SpeedSettingsStateEvent["CURRENT_SPEED_LEVEL_SET"] = "onCurrentSpeedLevelSet";
})(SpeedSettingsStateEvent || (SpeedSettingsStateEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/SpeedSettingsState.ts




class SpeedSettingsState extends (eventemitter3_default()) {
    constructor() {
        super();
        this._currentSpeedLevel = 0;
        const sm = dependency_container_instance.resolve(SlotMachine);
        this._currentSpeedLevel = sm.currentGameSpeedLevel;
    }
    updateGameSpeedLevel(value) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        this._currentSpeedLevel = Math.max(Math.min(sm.options.gameSpeedLevels.length, value), 0);
        this.emit(SpeedSettingsStateEvent.CURRENT_SPEED_LEVEL_SET, this._currentSpeedLevel);
    }
    get currentSpeedLevel() {
        return this._currentSpeedLevel;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/control/command/AdjustSpeedSettingsCommand.ts



class AdjustSpeedSettingsCommand extends ControlCommand {
    execute(event) {
        const settings = dependency_container_instance.resolve(SpeedSettingsState);
        settings.updateGameSpeedLevel(event.data);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/ExaGamingCommonEngine4.ts
const ExaGamingCommonEngine4_VERSION = '0.2.0';

;// CONCATENATED MODULE: ./src/ignition-interactive/core/utils/LayoutBuilder.ts








class LayoutBuilder {
    static create(layout, container, customClassResolver = null) {
        // check if layout element supports layouts and if it does build ALL elements
        // based on the uniqueness of their names
        //console.log("layout", layout)
        let children;
        if (layout.layouts.size) {
            children = new Map;
            layout.layouts.forEach((le) => {
                le.children.forEach((le, leName) => {
                    if (!children.has(leName)) {
                        children.set(leName, le);
                    }
                });
            });
        }
        else {
            children = layout.children;
        }
        children.forEach((le, key) => {
            const instance = LayoutBuilder.buildLayoutElement(le, customClassResolver);
            if (instance !== undefined && instance !== null) {
                LayoutBuilder.matchPositionAndRotation(le, instance);
                container[le.name] = instance;
                instance.name = le.name;
                container.addChild(instance);
                if (le.mask != null) {
                    container[le.mask.name] = LayoutBuilder.buildLayoutElement(le.mask);
                    LayoutBuilder.matchPositionAndRotation(le.mask, container[le.mask.name]);
                    container.addChild(container[le.mask.name]);
                    instance.mask = container[le.mask.name];
                }
                if (le.hitArea) {
                    instance.hitArea = new Polygon(le.hitArea);
                }
                le.effects.forEach((effect) => {
                    effect.apply(instance);
                });
            }
        });
        if (layout.pivotX) {
            container.pivot.x = layout.pivotX;
        }
        if (layout.pivotY) {
            container.pivot.y = layout.pivotY;
        }
    }
    static buildLayoutElement(le, customClassResolver = null) {
        let instance = undefined;
        if (!le.render) {
            return instance;
        }
        if (le instanceof LayoutElementQuad) {
            if (!le.customClass || le.customClass == 'round') {
                instance = new Graphics_Graphics();
                instance.lineStyle(0);
                instance.beginFill(le.color, le.alpha);
                if (le.customClass == 'round') {
                    instance.drawRoundedRect(0, 0, le.width, le.height, 15);
                }
                else {
                    instance.drawRect(0, 0, le.width, le.height);
                }
                instance.endFill();
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.pivotX) {
                    instance.pivot.x = le.pivotX;
                }
                if (le.pivotY) {
                    instance.pivot.y = le.pivotY;
                }
            }
        }
        else if (le instanceof LayoutElementImage) {
            let texture = null;
            if (!le.customClass) {
                texture = Texture.from(le.texture);
                if (texture) {
                    if (le.scale9Grid) {
                        instance = new NineSlicePlane(texture, le.scale9Grid.x, le.scale9Grid.y, texture.width - (le.scale9Grid.x + le.scale9Grid.width), texture.height - (le.scale9Grid.y + le.scale9Grid.height));
                        instance.tint = le.color;
                    }
                    else if (le.tileGrid) {
                        instance = new TilingSprite(texture, le.tileGrid.width, le.tileGrid.height);
                        instance.tint = le.color;
                    }
                    else {
                        instance = new Sprite(texture);
                        instance.tint = le.color;
                    }
                }
                else {
                    utils_Logger.warning('No texture with name: ' + le.texture);
                }
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    if (texture && instance instanceof NineSlicePlane) {
                        instance.width = le.scaleX * texture.width;
                    }
                    else {
                        instance.scale.x = le.scaleX;
                    }
                }
                if (le.scaleY) {
                    if (texture && instance instanceof NineSlicePlane) {
                        instance.height = le.scaleY * texture.height;
                    }
                    else {
                        instance.scale.y = le.scaleY;
                    }
                }
                if (le.pivotX) {
                    if (texture && instance instanceof NineSlicePlane) {
                        instance.pivot.x = instance.width * le.pivotX / texture.width;
                    }
                    else {
                        instance.pivot.x = le.pivotX;
                    }
                }
                if (le.pivotY) {
                    if (texture && instance instanceof NineSlicePlane) {
                        instance.pivot.y = instance.height * le.pivotY / texture.height;
                    }
                    else {
                        instance.pivot.y = le.pivotY;
                    }
                }
                if (le.anchorX) {
                    instance.anchor.x = le.anchorX;
                }
                if (le.anchorY) {
                    instance.anchor.y = le.anchorY;
                }
                instance.alpha = le.alpha;
            }
        }
        else if (le instanceof LayoutElementAnimation) {
            if (le.customClass == 'Video') {
                utils_Logger.warning('No video support at this time, please consider reinstating the VideoSprite class.');
            }
            else if (!le.customClass) {
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    instance.scale.x = le.scaleX;
                }
                if (le.scaleY) {
                    instance.scale.y = le.scaleY;
                }
                if (le.pivotX) {
                    instance.pivot.x = le.pivotX;
                }
                if (le.pivotY) {
                    instance.pivot.y = le.pivotY;
                }
            }
        }
        else if (le instanceof LayoutElementTextField) {
            const format = le.textFormat;
            if (assets_AssetsManager.bitmapFonts.get(format.font)) {
                instance = new BitmapText(le.text, {
                    fontName: format.font,
                    fontSize: format.size,
                    tint: format.color,
                    align: format.horizontalAlign == undefined ? 'center' : format.horizontalAlign,
                });
            }
            else {
                let fontFamily = format.font;
                if (assets_AssetsManager.webFonts.has(format.font)) {
                    fontFamily = assets_AssetsManager.webFonts.get(format.font).family;
                }
                const textStyle = new TextStyle({
                    fontFamily: fontFamily,
                    fontSize: format.size,
                    fill: format.color,
                    fontWeight: format.bold == undefined ? 'normal' : '900',
                    align: format.horizontalAlign == undefined ? 'center' : format.horizontalAlign,
                });
                instance = new Text(le.text, textStyle);
            }
            if (le.pivotX) {
                instance.anchor.x = le.pivotX / le.width;
            }
            if (le.pivotY) {
                instance.anchor.y = le.pivotY / le.height;
            }
        }
        else if (le instanceof LayoutElement) {
            if (!le.customClass) {
                instance = new Container_Container();
                LayoutBuilder.create(le, instance, customClassResolver);
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    instance.scale.x = le.scaleX;
                }
                if (le.scaleY) {
                    instance.scale.y = le.scaleY;
                }
                if (le.pivotX) {
                    instance.pivot.x = le.pivotX;
                }
                if (le.pivotY) {
                    instance.pivot.y = le.pivotY;
                }
            }
        }
        if (!instance && le.customClass) {
            utils_Logger.warning('Unknown layout element custom class: ' + le.customClass);
        }
        return instance;
    }
    static matchPositionAndRotation(le, dObj) {
        dObj.x = le.x;
        dObj.y = le.y;
        dObj.rotation = le.rotation ? le.rotation : 0;
    }
    static centerFitInRectangle(sprite, rect, padding = 0) {
        const rectX = rect.x + padding;
        const rectY = rect.y + padding;
        const rectW = rect.width - 2 * padding;
        const rectH = rect.height - 2 * padding;
        if (sprite.width < rectW) {
            sprite.width = rectW;
            sprite.scale.y = sprite.scale.x;
        }
        if (sprite.height > rectH) {
            sprite.height = rectH;
            sprite.scale.x = sprite.scale.y;
        }
        sprite.x = rectX + (rectW - sprite.width) / 2;
        sprite.y = rectY + (rectH - sprite.height) / 2;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/ui/Button.ts



class Button extends Container_Container {
    constructor(le, customClassResolver = null, hitArea = null) {
        super();
        this.currentState = ButtonState.DISABLED;
        this.pointerOver = false;
        this.pointerDown = false;
        this._enabled = true;
        LayoutBuilder.create(le, this, (le) => {
            let instance = null;
            if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (!instance) {
                instance = this.customClassElementCreate(le);
            }
            return instance;
        });
        this.enabled = true;
        if (hitArea) {
            this.hitArea = hitArea;
        }
        else if (this.hitObject) {
            this.hitArea = new Rectangle(this.hitObject.x, this.hitObject.y, this.hitObject.width, this.hitObject.height);
            this.removeChild(this.hitObject);
            this.hitObject.destroy();
        }
        this.setState(ButtonState.NORMAL);
        this
            .on('added', this.onAdded, this)
            .on('removed', this.onRemoved, this);
    }
    // PUBLIC API
    setState(state) {
        if (this.currentState == state) {
            return;
        }
        this.currentState = state;
        this.updateView();
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        this._enabled = value;
        if (value) {
            this.cursor = 'pointer';
            this.eventMode = 'dynamic';
            this.setState(ButtonState.NORMAL);
        }
        else {
            this.eventMode = 'auto';
            this.cursor = 'auto';
            this.pointerDown = false;
            this.pointerOver = false;
            this.setState(ButtonState.DISABLED);
        }
    }
    // PRIVATE API
    onAdded() {
        this.startScale = this.scale.x;
        this.on('pointerdown', this.onButtonDown, this)
            .on('pointerup', this.onButtonUp, this)
            .on('pointerupoutside', this.onButtonUpOutside, this)
            .on('pointerover', this.onButtonOver, this)
            .on('pointerout', this.onButtonOut, this);
    }
    onRemoved() {
        this.off('pointerdown', this.onButtonDown, this)
            .off('pointerup', this.onButtonUp, this)
            .off('pointerupoutside', this.onButtonUpOutside, this)
            .off('pointerover', this.onButtonOver, this)
            .off('pointerout', this.onButtonOut, this);
    }
    onButtonDown(e) {
        if (this._enabled) {
            this.pointerDown = true;
            this.setState(ButtonState.DOWN);
        }
    }
    onButtonUp(e) {
        if (this._enabled) {
            this.pointerDown = false;
            if (this.pointerOver) {
                this.setState(ButtonState.HOVER);
            }
            else {
                this.setState(ButtonState.NORMAL);
            }
        }
    }
    onButtonUpOutside(e) {
        if (this._enabled) {
            this.pointerDown = false;
            if (this.pointerOver) {
                this.setState(ButtonState.HOVER);
            }
            else {
                this.setState(ButtonState.NORMAL);
            }
        }
    }
    onButtonOver(e) {
        if (this._enabled) {
            this.pointerOver = true;
            this.setState(ButtonState.HOVER);
        }
    }
    onButtonOut(e) {
        if (this._enabled) {
            this.pointerOver = false;
            this.setState(ButtonState.NORMAL);
        }
    }
    updateView() {
        const itemsToRemove = [this.normal, this.hover, this.down, this.disabled];
        let itemToAdd = null;
        switch (this.currentState) {
            case ButtonState.NORMAL:
                removeArrayElement(itemsToRemove, this.normal);
                itemToAdd = this.normal;
                break;
            case ButtonState.HOVER:
                removeArrayElement(itemsToRemove, this.hover);
                itemToAdd = this.hover;
                break;
            case ButtonState.DOWN:
                removeArrayElement(itemsToRemove, this.down);
                itemToAdd = this.down;
                break;
            case ButtonState.DISABLED:
                removeArrayElement(itemsToRemove, this.disabled);
                itemToAdd = this.disabled;
                break;
        }
        for (const item of itemsToRemove) {
            if (item && item.parent == this) {
                this.removeChild(item);
            }
        }
        if (!itemToAdd) {
            itemToAdd = this.normal;
        }
        if (itemToAdd) {
            this.addChild(itemToAdd);
        }
    }
    customClassElementCreate(le) {
        return null;
    }
}
var ButtonState;
(function (ButtonState) {
    ButtonState[ButtonState["NORMAL"] = 0] = "NORMAL";
    ButtonState[ButtonState["HOVER"] = 1] = "HOVER";
    ButtonState[ButtonState["DOWN"] = 2] = "DOWN";
    ButtonState[ButtonState["DISABLED"] = 3] = "DISABLED";
})(ButtonState || (ButtonState = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/text/TextSpriteCombined.ts


class TextSpriteCombined extends Container_Container {
    constructor(le, spacing = 20) {
        super();
        LayoutBuilder.create(le, this);
        if (this.area)
            this.area.alpha = 0;
        this.repositionChildren(spacing);
    }
    repositionChildren(spacing) {
        const objects = this.content.children;
        for (let i = 0; i < objects.length; i++) {
            if (i == 0) {
                objects[0].x = 0;
            }
            else {
                objects[i].x = objects[i - 1].x + objects[i - 1].width + spacing;
            }
            if (this.tfUnder) {
                if (this.tfUnder instanceof Text) {
                    this.tfUnder.style.align = 'center';
                }
                this.tfUnder.y = this.content.y + this.content.height;
                this.tfUnder.pivot.y = 0;
            }
            if (this.tfAbove) {
                if (this.tfAbove instanceof Text) {
                    this.tfAbove.style.align = 'center';
                }
                this.tfAbove.y = this.content.y - this.tfAbove.height;
                this.pivot.y = this.tfAbove.y;
            }
        }
        this.content.pivot.x = this.content.width / 2;
        if (this.area)
            this.content.x = this.area.width / 2;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/TurboSelectChoice.ts










class TurboSelectChoice extends Container_Container {
    constructor(le) {
        super();
        this.selectButtons = [];
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.settingsState = dependency_container_instance.resolve(SpeedSettingsState);
        this.settingsState.on(SpeedSettingsStateEvent.CURRENT_SPEED_LEVEL_SET, (level) => this.updateView(level));
        this.selectButtons = [this.btnNormal, this.btnTurbo, this.btnSuperTurbo];
        this.selectButtons.forEach((btn, index) => btn.on('pointerup', () => this.onTurboSelect(index)));
    }
    get currentSelectedSpeed() {
        return this._currentSelectedSpeed;
    }
    onAdded() {
        this._currentSelectedSpeed = dependency_container_instance.resolve(SlotMachine).currentGameSpeedLevel;
        this.updateView(this._currentSelectedSpeed);
    }
    onTurboSelect(level) {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(SpeedSettingsStateEvent.CURRENT_SPEED_LEVEL_SET, level).dispatch();
        this._currentSelectedSpeed = level;
        this.updateView(level);
    }
    updateView(level) {
        this.selectButtons.forEach(btn => btn.scale.set(1));
        this.selectButtons[level].scale.set(1.45);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
        }
        return instance;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/view/text/ValueText.ts




class ValueText extends Container_Container {
    constructor(le, renderValueFunction = null) {
        super();
        this._value = 0;
        this.countUpSound = null;
        this.renderValueFunction = renderValueFunction;
        LayoutBuilder.create(le, this);
    }
    // PUBLIC API
    get value() {
        return this._value;
    }
    set value(v) {
        this._value = v;
        if (this.renderValueFunction) {
            this.renderValueFunction(this.tfValue, this._value);
        }
        else {
            this.defaultRender();
        }
    }
    reset() {
        ignitionTween.Tweener.removeTweens(this);
        this.value = 0;
    }
    setValue(value, animParams = null) {
        ignitionTween.Tweener.removeTweens(this);
        if (animParams) {
            if (!this.countUpSound && animParams.countUpLoopSoundId) {
                this.countUpSound = sound_SoundManager.loop(animParams.countUpLoopSoundId);
            }
            ignitionTween.Tweener.addTween(this, {
                value: value,
                time: animParams.countUpDuration,
                transition: 'easeOutSine',
                onComplete: () => {
                    if (this.countUpSound) {
                        this.countUpSound.stop();
                        this.countUpSound = null;
                    }
                    if (animParams.countUpEndSoundId) {
                        sound_SoundManager.play(animParams.countUpEndSoundId);
                    }
                    if (animParams.onComplete) {
                        animParams.onComplete();
                    }
                },
            });
        }
        else {
            ignitionTween.Tweener.removeTweens(this);
            if (this.countUpSound) {
                this.countUpSound.stop();
                this.countUpSound = null;
            }
            this.value = value;
        }
    }
    // PRIVATE API
    defaultRender() {
        this.tfValue.text = this.value.toString();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/services/GameServiceEvent.ts
var GameServiceEvent_GameServiceEvent;
(function (GameServiceEvent) {
    GameServiceEvent["ERROR"] = "on_error_received";
    GameServiceEvent["DOUBLE_CHANCE_CHANGED"] = "onDoubleChanceChanged";
    GameServiceEvent["SETTINGS_CHANGED"] = "onSettingsChanged";
    GameServiceEvent["AUTOSPIN_SETTINGS_CHANGED"] = "onAutospinSettingsChanged";
})(GameServiceEvent_GameServiceEvent || (GameServiceEvent_GameServiceEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/AdjustTotalBet.ts



















class AdjustTotalBet extends Container_Container {
    constructor(le) {
        super();
        this.updateBet = false;
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        if (this.area) {
            this.area.interactive = true;
            this.area.eventMode = 'static';
            this.area.cursor = 'pointer';
            this.area.alpha = 0;
            this.area.on('pointerup', this.onClick, this);
        }
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.settingsState = dependency_container_instance.resolve(AdjustBetSettingsState);
        this.gameService = dependency_container_instance.resolve(services_GameService);
        this.settingsState.on(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, (value) => {
            this._currentBetID = value;
            this._currentBetValue = this.slotMachine.description.betLimits[this._currentBetID];
        });
        this.slotMachine.on(SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.gameService.on(GameServiceEvent_GameServiceEvent.DOUBLE_CHANCE_CHANGED, this.onDoubleChanceChanged, this);
        this.onBetValueChanged();
        this.btnBetDown.on('pointerup', this.onTotalBetDown, this);
        this.btnBetUp.on('pointerup', this.onTotalBetUp, this);
        this.setupButtonOnClickSound();
    }
    get currentBetValue() {
        return this._currentBetValue;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
        }
        return instance;
    }
    onDoubleChanceChanged() {
        this.updateValues();
    }
    onBetValueChanged() {
        new ControlEvent(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, this.slotMachine.description.betLimits.indexOf(this.slotMachine.currentBetValue)).dispatch();
        this.updateView();
    }
    onAdded() {
        new ControlEvent(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, this.slotMachine.description.betLimits.indexOf(this.slotMachine.currentBetValue)).dispatch();
        this.updateView();
    }
    onTotalBetUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.updateBet) {
            new ControlEvent(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, this._currentBetID + 1).dispatch();
            this.updateView();
        }
    }
    onTotalBetDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.updateBet) {
            new ControlEvent(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, this._currentBetID - 1).dispatch();
            this.updateView();
        }
    }
    updateView() {
        const totalBetUpActive = this._currentBetValue < this.slotMachine.description.betLimits[this.slotMachine.description.betLimits.length - 1] * model_Wallet.denomination;
        const totalBetDownActive = this._currentBetValue > this.slotMachine.description.betLimits[0] * model_Wallet.denomination;
        const view = new Map([
            [this.btnBetUp, totalBetUpActive],
            [this.btnBetDown, totalBetDownActive],
        ]);
        view.forEach((active, btn) => {
            btn.setState(active ? ButtonState.NORMAL : ButtonState.DISABLED);
            btn.enabled = active;
        });
        this.updateValues();
    }
    updateValues() {
        const coinRate = (this.gameService["_doubleChanceEnabled"] ? dependency_container_instance.resolve(CommonTokenConstants.DOUBLE_CHANCE_BUTTON_COST_RATE) : 1);
        this.tfTotalBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this._currentBetValue * this.slotMachine.numLines * this.wallet.coinValue * coinRate)}`;
    }
    setupButtonOnClickSound() {
        for (const key in this) {
            const button = this[key];
            if (button instanceof Button) {
                button.on('pointerup', () => sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK), this);
            }
        }
    }
    onClick() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.BET_SETTINGS).dispatch();
    }
    lock() {
        this.btnBetDown.enabled = false;
        this.btnBetUp.enabled = false;
        this.area.eventMode = 'auto';
        this.area.cursor = 'auto';
    }
    unlock() {
        this.btnBetDown.enabled = true;
        this.btnBetUp.enabled = true;
        this.area.eventMode = 'dynamic';
        this.area.cursor = 'pointer';
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/MetricsView.ts





class MetricsView extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this);
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.balance['text'].text = `${wallet.getCurrencyValue(wallet.balance)}`;
        this.bet['text'].text = `${wallet.getCurrencyValue(slotMachine.totalBet)}`;
        this.win['text'].text = `${wallet.getCurrencyValue((slotMachine.roundResult ? slotMachine.roundResult.totalWinValue : 0))}`;
    }
    updateText(container, value) {
        container['text'].text = value;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/SwitchState.ts
var SwitchState;
(function (SwitchState) {
    SwitchState["OFF"] = "Off";
    SwitchState["ON"] = "On";
})(SwitchState || (SwitchState = {}));
var SwitchEvent;
(function (SwitchEvent) {
    SwitchEvent["STATE_CHANGED"] = "onStateChanged";
})(SwitchEvent || (SwitchEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/SwitchView.ts



class SwitchView extends Container_Container {
    constructor(l) {
        super();
        this._state = SwitchState.ON;
        LayoutBuilder.create(l, this);
        this.state = SwitchState.OFF;
        this.clickArea.alpha = 0;
        this.clickArea.interactive = true;
        this.clickArea.eventMode = 'static';
        this.clickArea.cursor = 'pointer';
        this.clickArea.on('pointerup', this.onClick, this);
    }
    setInitialState(state) {
        this._state = state;
        this.updateView();
    }
    set state(state) {
        if (this._state == state)
            return;
        this._state = state;
        this.updateView();
        this.emit(SwitchEvent.STATE_CHANGED, this._state);
    }
    get state() {
        return this._state;
    }
    updateView() {
        switch (this._state) {
            case SwitchState.ON:
                this.onView.visible = true;
                this.offView.visible = false;
                break;
            case SwitchState.OFF:
                this.offView.visible = true;
                this.onView.visible = false;
                break;
        }
    }
    onClick() {
        this.state = this._state == SwitchState.ON ? SwitchState.OFF : SwitchState.ON;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/Panel.ts












class Panel extends Container_Container {
    constructor(layout) {
        super();
        LayoutBuilder.create(layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.layout = layout;
        this.btnClose.on('pointerup', this.onBtnClose, this);
    }
    // PUBLIC API
    updateLayout(desc) {
        this.layoutDesc = desc;
    }
    // PRIVATE API
    updateLayoutElements(width, x) {
        this.background.width = width;
        this.background.x = x;
    }
    updateItemsGrid(items, maxWidth, spacingX, spacingY, maxItems = 0, reducedSpacingX = 0, standardSize = null, maxInRow) {
        let itemX = 0;
        let itemY = 0;
        let itemsInRow = [];
        items.forEach((item, index) => {
            const itemWidth = standardSize ? standardSize : item.width;
            item.position.set(itemX, itemY);
            itemX += (itemWidth + spacingX);
            itemsInRow.push(item);
            if ((item.position.x + itemWidth * 2) > maxWidth || index == items.length - 1 || (maxItems > 0 && !((index + 1) % maxItems))) {
                const rowWidth = itemsInRow.reduce((rowWidth, item) => {
                    return rowWidth + itemWidth + spacingX;
                }, 0) - spacingX;
                itemsInRow.forEach(item => {
                    item.x += (maxWidth - rowWidth) / 2;
                });
                itemsInRow = [];
                itemX = 0;
                itemY += (item.height + spacingY);
            }
            if (maxInRow) {
                if (itemsInRow.length == maxInRow - 1) {
                    spacingX -= reducedSpacingX;
                }
            }
        });
    }
    updateItemsVertically(items, spacingY) {
        let y = 0;
        items.forEach((item) => {
            item.y = y;
            y += (item.height + spacingY);
        });
    }
    // USER INTERACTION
    onBtnClose() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.CLOSE_PANEL).dispatch();
    }
    findStandardTexture(arr) {
        return arr.reduce((smallest, current) => {
            return current.staticIcon.texture.width < smallest.staticIcon.texture.width ? current : smallest;
        }).staticIcon.texture.width;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'MetricsView':
                instance = new MetricsView(le);
                break;
            case 'SwitchView':
                instance = new SwitchView(le);
                break;
            case 'TextSpriteCombined':
                instance = new TextSpriteCombined(le, 10);
                break;
            case 'AdjustTotalBet':
                instance = new AdjustTotalBet(le);
                break;
            case 'TurboSelectChoice':
                instance = new TurboSelectChoice(le);
                break;
        }
        return instance;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupConnectionLost.ts




class PopupConnectionLost extends Panel {
    constructor() {
        super(assets_AssetsManager.layouts.get('PopupLostConnection'));
        this.interactive = true;
        this.on('pointerdown', this.onIconClick, this);
        this.tfMessage.text = 'LOST CONNECTION';
    }
    onIconClick() {
        console.log('reload');
        location.reload();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
        }
        return instance;
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        this.children.forEach((child) => { var _a; return (_a = child['updateLayout']) === null || _a === void 0 ? void 0 : _a.call(child, desc); });
        if (desc.orientation === ScreenOrientation.HORIZONTAL) {
            this.scale.set(1);
        }
        else {
            this.scale.set(2);
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/core/utils/TextUtils.ts

const setTextStroke = function (tf, color = '#FFFFFF', thickness = 2, lineJoin) {
    const ts = tf.style;
    ts.stroke = color;
    ts.strokeThickness = thickness;
    ts.lineJoin = lineJoin;
    tf.style = ts;
};
const setTextDropShadow = function (tf, color = '#000000', alpha = 1, angle = 0, blur = 0, distance = 1) {
    const ts = tf.style;
    ts.dropShadow = true;
    ts.dropShadowAlpha = alpha;
    ts.dropShadowAngle = angle;
    ts.dropShadowBlur = blur;
    ts.dropShadowColor = color;
    ts.dropShadowDistance = distance;
    tf.style = ts;
};
const setTextLetterSpacing = function (tf, letterSpacing = 0) {
    const ts = tf.style;
    ts.letterSpacing = letterSpacing;
    tf.style = ts;
};
function autoscaleText(tf, maxFontSize, maxWidth, maxHeight) {
    if (tf.text.length === 0)
        return;
    if (tf instanceof Text) {
        const ts = tf.style;
        let currentFontSize;
        if (typeof ts.fontSize === 'number') {
            currentFontSize = ts.fontSize;
        }
        else if (typeof ts.fontSize === 'string') {
            currentFontSize = parseFloat(ts.fontSize);
        }
        else {
            currentFontSize = maxFontSize; // fallback default
        }
        if (currentFontSize <= 0)
            return;
        const widthScale = maxWidth / tf.width;
        const heightScale = maxHeight / tf.height;
        const scale = Math.min(widthScale, heightScale);
        const adjustedFontSize = Math.max(1, Math.min(maxFontSize, Math.floor(currentFontSize * scale)));
        ts.fontSize = adjustedFontSize;
        tf.style = ts;
    }
    else if (tf instanceof BitmapText) {
        let currentFontSize = tf.fontSize;
        let widthScale = maxWidth / tf.width;
        let heightScale = maxHeight / tf.height;
        let scale = Math.min(widthScale, heightScale);
        let adjustedFontSize = Math.max(1, Math.min(maxFontSize, Math.floor(currentFontSize * scale)));
        tf.fontSize = adjustedFontSize - 1;
        //tf.maxWidth = maxWidth;
    }
}
// TODO: add use case explanation
const measureFontSize = function (tf, width, height) {
    const text = tf.text;
    const style = tf.style;
    style.fontSize = 1;
    let metrics = TextMetrics.measureText(text, style);
    while (metrics.width < width && metrics.height < height) {
        style.fontSize++;
        metrics = TextMetrics.measureText(text, style);
    }
    return style.fontSize;
};

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/text/MultiShadowText.ts



class MultiShadowText extends Container_Container {
    constructor(le, shadowDistance = 3, shadowAngle = 2.5) {
        super();
        this.tfArray = [];
        LayoutBuilder.create(le, this);
        for (let i = 0; this['tf' + i]; i++) {
            this.tfArray.push(this['tf' + i]);
        }
        this._textStyle = this['tf0'].style;
        this.tfArray.forEach((tf, index) => {
            tf.position.x = tf.position.x + Math.cos(shadowAngle) * shadowDistance * index;
            tf.position.y = tf.position.y + Math.sin(shadowAngle) * shadowDistance * index;
        });
    }
    get text() {
        return this.tfArray[0];
    }
    set text(text) {
        this.tfArray.forEach(tf => {
            tf.text = text;
        });
    }
    get style() {
        return this._textStyle;
    }
    set style(style) {
        this._textStyle = style;
        this.tfArray.forEach(tf => {
            console.log(tf);
            tf.style = style;
        });
    }
    autoScale(fontSize, width, height) {
        this.tfArray.forEach((tf) => autoscaleText(tf, fontSize, width, height));
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupFeatureBuy.ts















class PopupFeatureBuy extends Container_Container {
    constructor(type) {
        super();
        LayoutBuilder.create(assets_AssetsManager.layouts.get('PopupFeatureBuy'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.type = type;
        if (this['tfMainText']) {
            this['tfMainText'].style.align = 'center';
        }
        this.tfTitle.style.align = 'center';
        autoscaleText(this.tfTitle, this.tfTitle.style.fontSize, 537, 244.5);
        this.gs = dependency_container_instance.resolve(services_GameService);
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.sm = dependency_container_instance.resolve(SlotMachine);
        const feature = this.gs.featureBuyConfig.config.find(feature => feature.RoundType == this._type);
        this.tfAmount.text = this.wallet.getCurrencyValue(feature.Multiplier * this.sm.totalBet * this.wallet.coinValue, true);
        if (this.tfAmount instanceof Text)
            autoscaleText(this.tfAmount, this.tfAmount.style.fontSize, 537, 120);
        else
            this.tfAmount.autoScale(this.tfAmount.style.fontSize, 537, 120);
        this.btnStart.on('pointerup', this.onBtnStart, this);
        this.btnCancel.on('pointerup', this.onBtnCancel, false);
        this.on('added', this.onAdded, this);
    }
    set type(type) {
        if (this._type === type)
            return;
        this._type = type;
        this.tfTitle.text = type == FeatureTypes.HOLD_AND_SPINNER ? translations_Translation.t('holdSpinner.popupTitle') : translations_Translation.t('freeSpins.buy');
    }
    onAdded() {
    }
    updateLayout(desc) {
        const feature = this.gs.featureBuyConfig.config.find(feature => feature.RoundType == this._type);
        this.tfAmount.text = this.wallet.getCurrencyValue(feature.Multiplier * this.sm.totalBet * this.wallet.coinValue, true);
        if (this.tfAmount instanceof Text)
            autoscaleText(this.tfAmount, this.tfAmount.style.fontSize, 537, 120);
        else
            this.tfAmount.autoScale(this.tfAmount.style.fontSize, 537, 120);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'MultiShadowText':
                instance = new MultiShadowText(le);
                break;
        }
        return instance;
    }
    onBtnStart() {
        new ControlEvent(UIPanelEvent.HIDE_POPUP).dispatch();
        if (this._type == FeatureTypes.FREESPIN) {
            this.gs.featureBuyConfig.currentRoundType = FeatureTypes.FREESPIN;
            new ControlEvent(SlotGameEventExtension.BUY_FREESPINS).dispatch();
        }
        else {
            this.gs.featureBuyConfig.currentRoundType = FeatureTypes.HOLD_AND_SPINNER;
            new ControlEvent(SlotGameEventExtension.BUY_HOLD_AND_SPINNER).dispatch();
        }
    }
    onBtnCancel() {
        new ControlEvent(UIPanelEvent.HIDE_POPUP).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupNotEnoughBalance.ts









class PopupNotEnoughBalance extends Container_Container {
    constructor() {
        super();
        LayoutBuilder.create(assets_AssetsManager.layouts.get('PopupNotEnoughBalance'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.interactive = true;
        // Add event listener for click interaction
        this.on('pointerdown', this.onPopupClick, this);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
        }
        return instance;
    }
    onPopupClick() {
        // Dispatch the HIDE_POPUP event when clicked
        new ControlEvent(UIPanelEvent.HIDE_POPUP).dispatch();
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentState = SlotMachineState.IDLE;
    }
    destroy() {
        // Cleanup: Remove the event listener
        this.off('pointerdown', this.onPopupClick);
        super.destroy();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/BetSettings.ts















class BetSettings extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.on(SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.betLimits = this.slotMachine.description.betLimits;
        this.btnTotalBetUp.on('pointerup', this.onTotalBetUp, this);
        this.btnTotalBetDown.on('pointerup', this.onTotalBetDown, this);
        this.btnCoinDown.on('pointerup', this.onCoinDown, this);
        this.btnCoinUp.on('pointerup', this.onCoinUp, this);
        this.btnBetUp.on('pointerup', this.onBetUp, this);
        this.btnBetDown.on('pointerup', this.onBetDown, this);
        //this.fetchTranslationFile();
    }
    updateLayout(desc) {
        this.updateView();
    }
    onAdded() {
        this.currentBetValue = dependency_container_instance.resolve(SlotMachine).currentBetValue;
        this.updateView();
        this.onBetValueChanged();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
        }
        return instance;
    }
    onTotalBetUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.betLimits.indexOf(this.currentBetValue) < this.betLimits.length - 1) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) + 1];
        }
        this.onBetValueChanged();
        this.updateView();
        new ControlEvent(UIEventExtension.TOTAL_BET_UP).dispatch();
    }
    onTotalBetDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.betLimits.indexOf(this.currentBetValue) != 0) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) - 1];
        }
        this.onBetValueChanged();
        this.updateView();
        new ControlEvent(UIEventExtension.TOTAL_BET_DOWN).dispatch();
    }
    onCoinUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) < this.wallet.coinValueLimits.length - 1) {
            this.wallet.coinValue = this.wallet.coinValueLimits[this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) + 1];
        }
        this.onBetValueChanged();
        this.updateView();
        new ControlEvent(UIEvent.COIN_VALUE_UP).dispatch();
    }
    onCoinDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) != 0) {
            this.wallet.coinValue = this.wallet.coinValueLimits[this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) - 1];
        }
        this.onBetValueChanged();
        this.updateView();
        new ControlEvent(UIEvent.COIN_VALUE_DOWN).dispatch();
    }
    onBetUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.betLimits.indexOf(this.currentBetValue) < this.betLimits.length - 1) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) + 1];
        }
        this.onBetValueChanged();
        this.updateView();
        new ControlEvent(UIEvent.BET_QUANTITY_UP).dispatch();
    }
    onBetDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.betLimits.indexOf(this.currentBetValue) != 0) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) - 1];
        }
        this.onBetValueChanged();
        this.updateView();
        new ControlEvent(UIEvent.BET_QUANTITY_DOWN).dispatch();
    }
    updateView() {
        const btnBetUpActive = this.currentBetValue < this.betLimits[this.betLimits.length - 1];
        const btnBetDownActive = this.currentBetValue > this.betLimits[0];
        const coinValueIndex = this.wallet.coinValueLimits.indexOf(this.wallet.coinValue);
        const btnCoinDownActive = coinValueIndex > 0;
        const btnCoinUpActive = coinValueIndex < this.wallet.coinValueLimits.length - 1;
        const view = new Map([
            [this.btnBetUp, btnBetUpActive],
            [this.btnBetDown, btnBetDownActive],
            [this.btnCoinDown, btnCoinDownActive],
            [this.btnCoinUp, btnCoinUpActive],
            [this.btnTotalBetUp, !(!btnBetUpActive && !btnCoinUpActive)],
            [this.btnTotalBetDown, !(!btnBetDownActive && !btnCoinDownActive)],
        ]);
        view.forEach((active, btn) => {
            btn.setState(active ? ButtonState.NORMAL : ButtonState.DISABLED);
            btn.enabled = active;
        });
    }
    onBetValueChanged() {
        const gs = dependency_container_instance.resolve(services_GameService);
        this.tfTotalBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this.currentBetValue * ((this.slotMachine.numLines == 0) ? this.slotMachine.combinations : this.slotMachine.numLines) * (gs.doubleUpChance ? 1.25 : 1) * this.wallet.coinValue * model_Wallet.denomination)}`;
        this.tfBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this.currentBetValue)}`;
        this.tfCoinValue.tfValue.text = `${this.wallet.coinValue}`;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/StatusBar.ts



class StatusBar extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ValueText':
                instance = new ValueText(le);
                break;
        }
        return instance;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/StatusComponent.ts









class StatusComponent extends Container_Container {
    constructor(le) {
        super();
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.statusBalance.text.renderValueFunction = ((tf, value) => {
            tf.text = `${this.wallet.getCurrencyValue(value, true)}`;
        });
        this.statusBet.text.renderValueFunction = ((tf, value) => {
            tf.text = `${this.wallet.getCurrencyValue(value, true)}`;
        });
        this.wallet.on(WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent.BALANCE_CHANGED, this.onWalletBalanceChanged, this);
        this.slotMachine.on(SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.onWalletBalanceChanged();
        this.onBetValueChanged();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'StatusBar':
                instance = new StatusBar(le);
                break;
        }
        return instance;
    }
    set winValue(value) {
        //this.statusWin.text.tfValue.text = `${this.wallet.getCurrencyValue(value,false)}`
        //autoscaleText(this.statusWin.text.tfValue,26,186,52)
    }
    onWalletBalanceChanged() {
        if (ignitionTween.Tweener.isTweening(this.statusBalance.text)) {
            ignitionTween.Tweener.removeTweens(this.statusBalance.text);
            this.statusBalance.text.tfValue.text = `${this.wallet.getCurrencyValue(this.wallet.balance, true)}`;
            return;
        }
        const balance = this.wallet.balance;
        const doAnimation = (balance > this.statusBalance.text.value);
        if (doAnimation) {
            this.statusBalance.text.setValue(balance, {
                countUpDuration: 1
            });
        }
        else {
            this.statusBalance.text.value = balance;
        }
        //autoscaleText(this.statusBalance.text.tfValue,26,180,52)
    }
    onBetValueChanged() {
        this.statusBet.text.tfValue.text = `${this.wallet.getCurrencyValue(this.slotMachine.totalBet * this.wallet.coinValue * model_Wallet.denomination, true)}`;
        //autoscaleText(this.statusBet.text.tfValue,26,180,52)
        this.animateText(this.statusBet.text);
    }
    animateText(tf) {
        ignitionTween.Tweener.removeTweens(tf.scale);
        ignitionTween.Tweener.addTween(tf.scale, {
            x: 1.25,
            y: 1.3,
            transition: 'easeInSine',
            time: 0.1,
            onComplete: () => {
                ignitionTween.Tweener.addTween(tf.scale, {
                    x: 1,
                    y: 1,
                    time: 0.12,
                    transition: 'easeOutSine',
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/AdjustBetPanel.ts










class AdjustBetPanel extends Panel {
    constructor(layout) {
        super(layout);
        this.btnMaxBet.on('pointerup', this.onBtnMaxBet, this);
        this.backgroundWidthDefault = this['background'].width;
        this.once('added', this.betSettings.onAdded, this.betSettings);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'BetSettings':
                instance = new BetSettings(le);
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
            case 'StatusComponent':
                instance = new StatusComponent(le);
                break;
            default:
                instance = super.customClassElementCreate(le);
        }
        return instance;
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        if (desc.orientation == ScreenOrientation.HORIZONTAL) {
            this.background.width = this.backgroundWidthDefault;
        }
        this.children.forEach((child) => { var _a; return (_a = child['updateLayout']) === null || _a === void 0 ? void 0 : _a.call(child, desc); });
        if (desc.orientation === ScreenOrientation.HORIZONTAL) {
            this.scale.set(1);
        }
        else {
            this.scale.set(2);
        }
    }
    // PRIVATE API
    // USER INTERACTION
    onBtnMaxBet() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        this.isMaxBet = !this.isMaxBet;
        this.betSettings.currentBetValue = this.betSettings.betLimits[this.isMaxBet ? this.betSettings.betLimits.length - 1 : 0];
        this.betSettings.onBetValueChanged();
        this.betSettings.updateView();
        this.btnMaxBet.normal['textBit'].text = !this.isMaxBet ? translations_Translation.t("adjustBet.btnMax") : translations_Translation.t("adjustBet.btnMin");
        // new ControlEvent(UIEvent.COIN_VALUE_MAX).dispatch();
        // new ControlEvent(UIEvent.BET_QUANTITY_MAX).dispatch();
    }
    onBtnClose() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentBetValue = this.betSettings.currentBetValue;
        super.onBtnClose();
    }
}

// EXTERNAL MODULE: ./node_modules/typed-signals/dist/index.js
var dist = __webpack_require__(4242);
;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/utils/helpers/view.mjs


function getView(view) {
  if (typeof view === "string") {
    return Sprite.from(view);
  }
  return view;
}


//# sourceMappingURL=view.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/Switcher.mjs




class Switcher extends Container_Container {
  /**
   * @param {Array<Container | string>} views - Array of views or textures that will be switching.
   * @param triggerEvents - Button events, to switch views (can be one event or an array of events).
   * @param activeViewID - The id of the view, visible by default.
   */
  constructor(views, triggerEvents, activeViewID) {
    super();
    this._triggerEvents = /* @__PURE__ */ new Set(["onPress"]);
    this.innerView = new Container_Container();
    this.addChild(this.innerView);
    this.onChange = new dist/* Signal */.MZ();
    if (views)
      this.views = views;
    if (triggerEvents)
      this.triggerEvents = triggerEvents;
    if (activeViewID && this.views.length > 0)
      this.active = activeViewID;
    this.setInteractionEvents();
  }
  setInteractionEvents() {
    this.innerView.eventMode = "static";
    this.innerView.on("pointerdown", () => this.handleEvents("onDown"));
    this.innerView.on("pointerup", () => this.handleEvents("onUp"));
    this.innerView.on("pointerupoutside", () => this.handleEvents("onUpOut"));
    this.innerView.on("pointerout", () => this.handleEvents("onOut"));
    this.innerView.on("pointertap", () => this.handleEvents("onPress"));
    this.innerView.on("pointerover", () => this.handleEvents("onHover"));
  }
  handleEvents(event) {
    if (this._triggerEvents.has(event)) {
      this.switch();
    }
  }
  /** Returns the active view. */
  get activeView() {
    if (this.views && this.views[this.active]) {
      return this.views[this.active];
    }
    return void 0;
  }
  /** Sets the list of instances for switching. */
  set views(views) {
    this.innerView.removeChildren();
    views.forEach((stateView) => this.add(stateView));
  }
  /** Returns all the switchable views */
  get views() {
    return this.innerView.children;
  }
  /**
   * Adds view instance to a switching list.
   * @param view
   */
  add(view) {
    const viewInstance = getView(view);
    this.innerView.addChild(viewInstance);
    viewInstance.visible = false;
    if (this.views.length === 1) {
      this.active = 0;
    }
  }
  /**
   * Removes view instance from a switching list by id.
   * @param id - id of the view to remove.
   */
  remove(id) {
    if (this.views[id]) {
      this.innerView.removeChild(this.views[id]);
    }
  }
  /**
   * Sets a list of events that will make a switcher switch to the next view.
   * @param {ButtonEvent | ButtonEvent[]} triggerEvents - Button events,
   * to switch views (can be one event or an array of events).
   */
  set triggerEvents(triggerEvents) {
    this._triggerEvents = new Set(Array.isArray(triggerEvents) ? triggerEvents : [triggerEvents]);
  }
  /** Returns a list of events that will make a switcher switch to the next view. */
  get triggerEvents() {
    return Array.from(this._triggerEvents);
  }
  /**
   * Show a view by id, or to next one by order, if no ID provided.
   * @param {number} id - optional id of the view to show. If not set, will switch to the next view.
   */
  switch(id) {
    if (id !== void 0 && id === this.active)
      return;
    const exID = this.active;
    this.forceSwitch(id);
    if (exID !== this.active) {
      const res = this.views.length > 2 ? this.active : this.active === 1;
      this.onChange.emit(res);
    }
  }
  /**
   * Switches a view to a given one without triggering the onChange event.
   * @param {number} id - optional id of the view to show. If not set, will switch to the next view.
   */
  forceSwitch(id) {
    if (id !== void 0 && id === this.active)
      return;
    if (this.activeView) {
      this.activeView.visible = false;
    }
    if (id !== void 0 && !this.views[id]) {
      throw new Error(`View with id ${id} does not exist.`);
    }
    this._active = id !== void 0 ? id : this.nextActive;
    if (this._active === void 0) {
      return;
    }
    this.views[this.active].visible = true;
  }
  /** Returns the id of the next view in order. Or undefined, if order is empty. */
  get nextActive() {
    if (this.views.length === 0)
      return void 0;
    return this.active < this.views.length - 1 ? this.active + 1 : 0;
  }
  /** Sets the id of the visible(active) view and shows to it. */
  set active(id) {
    this.switch(id);
  }
  /** Gets the id of the visible(active) view. */
  get active() {
    return this._active;
  }
}


//# sourceMappingURL=Switcher.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/utils/helpers/cleanup.mjs
function cleanup(element) {
  if (!element)
    return;
  if (element.parent) {
    element.parent.removeChild(element);
  }
  element.destroy();
  element = null;
}


//# sourceMappingURL=cleanup.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/CheckBox.mjs





class CheckBox extends Switcher {
  constructor(options) {
    super();
    this.text = options.text;
    this.style = options.style;
    this.checked = options.checked;
    this.triggerEvents = ["onPress"];
    this.innerView.cursor = "pointer";
    this.onCheck = new dist/* Signal */.MZ();
    this.onChange.connect(() => this.onCheck.emit(this.checked));
  }
  addLabel(text, style) {
    if (!text)
      return;
    this.label = new Text(text ?? "", style ?? this._style?.text);
    this.addChild(this.label);
    this.label.cursor = "pointer";
    this.label.eventMode = "static";
    this.label.on("pointertap", () => this.checked = !this.checked);
  }
  /** Setter, which sets a checkbox text. */
  set text(text) {
    if (!text) {
      cleanup(this.label);
      return;
    }
    this.label ? this.label.text = text : this.addLabel(text);
  }
  /** Getter, which returns a checkbox text. */
  get text() {
    return this.label?.text ?? "";
  }
  /** Setter, which sets a checkbox style settings. */
  set style(style) {
    this._style = style;
    const { unchecked, checked } = style;
    this.views = [unchecked, checked];
    const uncheckedView = this.views[0];
    if (this.label) {
      if (style.text)
        this.label.style = style.text;
      this.label.x = uncheckedView.width + 10 + (style.textOffset?.x ?? 0);
      this.label.y = (uncheckedView.height - this.label.height) / 2 + (style.textOffset?.y ?? 0);
    }
  }
  /** Getter, which returns a checkbox style settings. */
  get style() {
    return this._style;
  }
  /** Getter, which returns a checkbox state. */
  get checked() {
    return this.active === 1;
  }
  /** Setter, which sets a checkbox state. */
  set checked(checked) {
    this.switch(checked ? 1 : 0);
  }
  /**
   * Setter, that sets a checkbox state without emitting a signal.
   * @param checked
   */
  forceCheck(checked) {
    this.forceSwitch(checked ? 1 : 0);
  }
}


//# sourceMappingURL=CheckBox.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/ProgressBar.mjs





class ProgressBar extends Container_Container {
  constructor(params) {
    super();
    this.progressStart = 0;
    this._progress = 0;
    this.innerView = new Container_Container();
    this.addChild(this.innerView);
    if (params?.bg && params?.fill) {
      this.init(params);
    }
  }
  /**
   * Initialize ProgressBar.
   * @param root0
   * @param root0.bg - Background texture.
   * @param root0.fill - Fill texture.
   * @param root0.fillOffset - Fill offset.
   * @param root0.progress - Initial progress value.
   */
  init({ bg, fill, fillOffset, progress }) {
    this.setBackground(bg);
    this.setFill(fill, fillOffset);
    this.progress = progress;
  }
  /**
   * Set bg.
   * @param bg
   */
  setBackground(bg) {
    if (this.bg) {
      this.innerView.removeChild(this.bg);
    }
    this.bg = getView(bg);
    this.innerView.addChildAt(this.bg, 0);
  }
  /**
   * Set fill.
   * @param fill
   * @param fillOffset
   */
  setFill(fill, fillOffset) {
    if (this.fill) {
      this.innerView.removeChild(this.fill);
      this.fill.destroy();
    }
    if (this.bg instanceof Sprite && fill === this.bg) {
      fill = Sprite.from(this.bg.texture);
    }
    this.fill = getView(fill);
    this.innerView.addChildAt(this.fill, 1);
    const offsetX = fillOffset?.x ?? 0;
    const offsetY = fillOffset?.y ?? 0;
    this.fill.x = (this.bg.width - this.fill.width) / 2 + offsetX;
    this.fill.y = (this.bg.height - this.fill.height) / 2 + offsetY;
    if (!this.fillMask) {
      this.fillMask = new Graphics_Graphics();
    }
    this.fill.addChild(this.fillMask);
    this.fill.mask = this.fillMask;
  }
  validate(progress) {
    progress = Math.round(progress);
    if (progress < 0) {
      return 0;
    }
    if (progress > 100) {
      return 100;
    }
    return progress;
  }
  /** Set current progress percentage value. */
  set progress(progress) {
    this._progress = this.validate(progress);
    if (!this.fill)
      return;
    const startPoint = this.fill.width / 100 * this.progressStart;
    const endPoint = this.fill.width / 100 * this._progress - startPoint;
    if (this.fillMask) {
      this.fillMask.clear().lineStyle(0).beginFill(16777215).drawRect(startPoint, 0, endPoint, this.fill.height);
    }
  }
  /** Return current progress percentage value. */
  get progress() {
    return this._progress;
  }
}


//# sourceMappingURL=ProgressBar.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/SliderBase.mjs






class SliderBase extends ProgressBar {
  constructor(options) {
    super();
    this.dragging = 0;
    /** Minimal value. */
    this.min = 0;
    /** Maximal value. */
    this.max = 100;
    this.setBackground(options.bg);
    if (options.fill) {
      this.setFill(options.fill, options.fillOffset);
    }
    this.settings = options;
    this.slider1 = options.slider1;
    this.slider2 = options.slider2;
    this.min = options.min ?? 0;
    this.max = options.max ?? 100;
    this.activate();
  }
  /**
   * Sets Slider1 instance.
   * @param value - Container or string with texture name.
   */
  set slider1(value) {
    if (!value)
      return;
    if (this._slider1) {
      this.slider1.removeAllListeners();
      this.removeChild(this._slider1);
      this.slider1.destroy();
    }
    this._slider1 = this.createSlider(value);
    this._slider1.eventMode = "static";
    this._slider1.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
    if (this.settings.showValue && !this.value1Text) {
      this.value1Text = new Text("", this.settings.valueTextStyle || { fill: 16777215 });
      this.value1Text.anchor.set(0.5);
      this.addChild(this.value1Text);
    }
  }
  /** Get Slider1 instance. */
  get slider1() {
    return this._slider1;
  }
  /**
   * Sets Slider2 instance.
   * @param value - Container or string with texture name.
   */
  set slider2(value) {
    if (!value)
      return;
    if (this._slider2) {
      this.slider2.removeAllListeners();
      this.removeChild(this._slider2);
      this.slider2.destroy();
    }
    this._slider2 = this.createSlider(value);
    this._slider2.eventMode = "static";
    this._slider2.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
    if (this.settings.showValue && !this.value2Text) {
      this.value2Text = new Text("", this.settings.valueTextStyle || { fill: 16777215 });
      this.value2Text.anchor.set(0.5);
      this.addChild(this.value2Text);
    }
  }
  /** Get Slider2 instance. */
  get slider2() {
    return this._slider2;
  }
  /**
   * Set bg.
   * @param bg
   */
  setBackground(bg) {
    if (this.bg) {
      this.bg.removeAllListeners();
    }
    super.setBackground(bg);
    this.activate();
  }
  activate() {
    this.bg.eventMode = "static";
    this.bg.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
    if (this.fill) {
      this.fill.eventMode = "none";
    }
    if (this.value1Text) {
      this.value1Text.eventMode = "none";
    }
    if (this.value2Text) {
      this.value2Text.eventMode = "none";
    }
  }
  createSlider(sliderData) {
    const slider = getView(sliderData);
    slider.x = slider.width / 2;
    const container = new Container_Container();
    container.addChild(slider);
    if (slider instanceof Sprite) {
      slider.anchor.set(0.5);
    }
    container.y = this.bg.height / 2;
    this.addChild(container);
    return container;
  }
  startUpdate(event) {
    this.dragging = 1;
    this.startUpdateValue1 = this._value1;
    this.startUpdateValue2 = this._value2;
    this.update(event);
  }
  endUpdate() {
    if (!this.dragging)
      return;
    this.dragging = 0;
    if (this.startUpdateValue1 !== this._value1 || this.startUpdateValue2 !== this._value2) {
      this.change();
    }
    this.startUpdateValue1 = null;
    this.startUpdateValue2 = null;
  }
  /* Called when dragging started and on every move. */
  update(_event) {
  }
  /** Called when dragging stopped. */
  change() {
  }
}


//# sourceMappingURL=SliderBase.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/Slider.mjs



class Slider extends SliderBase {
  constructor(options) {
    super({
      bg: options.bg,
      slider1: options.slider,
      fill: options.fill ?? "",
      min: options.min,
      max: options.max,
      value1: options.value,
      valueTextStyle: options.valueTextStyle,
      showValue: options.showValue,
      valueTextOffset: options.valueTextOffset,
      fillOffset: options.fillOffset
    });
    /** Fires when value is changing, on every move of slider. */
    this.onUpdate = new dist/* Signal */.MZ();
    /** Fires when value changed, only when slider is released. */
    this.onChange = new dist/* Signal */.MZ();
    this.options = options;
    this.progress = ((options.value ?? this.min) - this.min) / (this.max - this.min) * 100;
    this.value = options.value ?? this.min;
  }
  /** Return selected value. */
  get value() {
    return this._value1;
  }
  /** Set selected value. */
  set value(value) {
    if (value === this._value1)
      return;
    if (value < this.min)
      value = this.min;
    if (value > this.max)
      value = this.max;
    this._value1 = value;
    this.updateSlider();
    this.onUpdate?.emit(this.value);
  }
  /** Set slider instance ot texture. */
  // eslint-disable-next-line accessor-pairs
  set slider(value) {
    this.slider1 = value;
    this.updateSlider();
  }
  update(event) {
    if (!this.dragging)
      return;
    const obj = event.currentTarget;
    const { x } = obj.parent.worldTransform.applyInverse(event.global);
    this.progress = this.validate(x / this.bg.width * 100);
    this.value = this.min + (this.max - this.min) / 100 * this.progress;
  }
  change() {
    this.onChange?.emit(this.value);
  }
  updateSlider() {
    this._slider1.x = (this.bg.width - this._slider1.width) / 100 * this.progress;
    if (this.options.showValue) {
      this.value1Text.text = `${Math.round(this.value)}`;
      const sliderPosX = this._slider1.x + this._slider1.width / 2;
      const sliderPosY = this._slider1.y;
      this.value1Text.x = sliderPosX + (this.options.valueTextOffset?.x ?? 0);
      this.value1Text.y = sliderPosY + (this.options.valueTextOffset?.y ?? 0);
    }
  }
}


//# sourceMappingURL=Slider.mjs.map

;// CONCATENATED MODULE: ./src/the-miner/view/Extra/SliderMinMaxText.ts



class SliderMinMaxText extends Slider {
    constructor(options) {
        super(options);
        // Create min and max text labels
        this.minText = new BitmapText(translations_Translation.t("autoSpin.tfMin"), {
            fontName: 'Alexandria',
            fontSize: 16,
            align: 'center'
        });
        this.minText.anchor.set(0.5, 0.5);
        this.maxText = new BitmapText(translations_Translation.t("autoSpin.tfMax"), {
            fontName: 'Alexandria',
            fontSize: 16,
            align: 'center'
        });
        this.maxText.anchor.set(0.5, 0.5);
        // Position min text on the left
        this.minText.position.set(-24, 12);
        // Position max text on the right
        this.maxText.position.set(this.width + 24, 12);
        // Add texts to the slider
        this.addChild(this.minText);
        this.addChild(this.maxText);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/AutospinPanel.ts

















class AutospinPanel extends Panel {
    constructor(le) {
        super(le);
        this.spinsNumber = 500;
        this.btnConfirm.on('pointerup', this.onBtnConfirm, this);
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.on(SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.betLimits = this.slotMachine.description.betLimits;
        this.currentBetValue = this.slotMachine.currentBetValue;
        if (this.btnTotalBetUp) {
            this.btnTotalBetUp.on('pointerup', this.onTotalBetUp, this);
        }
        if (this.btnTotalBetDown) {
            this.btnTotalBetDown.on('pointerup', this.onTotalBetDown, this);
        }
        this.slider.onUpdate.connect((value) => {
            this.spinsNumber = value;
            this.updateSpinNumbers();
            this.slotMachine.emit("AUTO_PLAY_SLIDER_CHANGE", value);
        });
        // this.infinteAutoplayBtn.onChange.connect((checked) => {
        //     this.slotMachine.emit("INFINITE_AUTOPLAY_BTN_STATE_CHANGE", checked);
        //     SoundManager.play(SoundList.UI_BUTTON_CLICK);
        // })
        this.slotMachine.on("AUTO_PLAY_SLIDER_CHANGE", this.onAutoPlaySliderChange, this);
        this.slotMachine.on("SKIP_BTN_STATE_CHANGE", this.onSkipBtnStateChange, this);
        //this.slotMachine.on("INFINITE_AUTOPLAY_BTN_STATE_CHANGE", this.onInfineBtnStateChange, this);
        this.slotMachine.on(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.updateTuroBtn, this);
        this.updateSpinNumbers();
        this.onBetValueChanged();
        this.btnNormalTurbo.on('pointerup', () => {
            this.onTurboBtnSelected(0);
        }, this);
        this.btnTurbo.on('pointerup', () => {
            this.onTurboBtnSelected(1);
        }, this);
        this.btnSuperTurbo.on('pointerup', () => {
            this.onTurboBtnSelected(2);
        }, this);
        this.updateTuroBtn(this.slotMachine.currentGameSpeedLevel);
    }
    updateTuroBtn(value) {
        if (value == 1) {
            this.btnTurbo.enabled = false;
            this.btnNormalTurbo.enabled = true;
            this.btnSuperTurbo.enabled = true;
        }
        else if (value == 0) {
            this.btnTurbo.enabled = true;
            this.btnNormalTurbo.enabled = false;
            this.btnSuperTurbo.enabled = true;
        }
        else if (value == 2) {
            value = 1;
            this.btnTurbo.enabled = true;
            this.btnNormalTurbo.enabled = true;
            this.btnSuperTurbo.enabled = false;
        }
    }
    onAutoPlaySliderChange(value) {
        this.spinsNumber = value;
        this.slider.value = value;
        this.slider.children[1].x = ((this.slider.children[0].width - this.slider.children[1].width + 1) / 1000) * value;
        this.updateSpinNumbers();
    }
    onSkipBtnStateChange() {
    }
    onTotalBetUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        // new ControlEvent(UIEventExtension.TOTAL_BET_UP).dispatch();
        if (this.betLimits.indexOf(this.currentBetValue) < this.betLimits.length - 1) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) + 1];
        }
        this.onBetValueChanged();
    }
    onTotalBetDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK); // new ControlEvent(UIEventExtension.TOTAL_BET_DOWN).dispatch();
        if (this.betLimits.indexOf(this.currentBetValue) != 0) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) - 1];
        }
        this.onBetValueChanged();
    }
    onBetValueChanged() {
        const gs = dependency_container_instance.resolve(services_GameService);
        if (this.tfTotalBetValue) {
            this.tfTotalBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this.currentBetValue * ((this.slotMachine.numLines == 0) ? this.slotMachine.combinations : this.slotMachine.numLines) * (gs.doubleUpChance ? 1.25 : 1) * this.wallet.coinValue * model_Wallet.denomination)}`;
            // this.tfTotalBetValue.tfValue.text = `${this.wallet.getCurrencyValue(
            //     this.slotMachine.totalBet * this.wallet.coinValue * Wallet.denomination
            // )}`;
        }
        this.updateView();
    }
    updateView() {
        const btnBetUpActive = this.currentBetValue < this.slotMachine.description.betLimits[this.slotMachine.description.betLimits.length - 1];
        const btnBetDownActive = this.currentBetValue > this.slotMachine.description.betLimits[0];
        if (this.btnTotalBetUp) {
            this.btnTotalBetUp.setState(btnBetUpActive ? ButtonState.NORMAL : ButtonState.DISABLED);
            this.btnTotalBetUp.enabled = btnBetUpActive;
        }
        if (this.btnTotalBetDown) {
            this.btnTotalBetDown.setState(btnBetDownActive ? ButtonState.NORMAL : ButtonState.DISABLED);
            this.btnTotalBetDown.enabled = btnBetDownActive;
        }
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        if (desc.orientation === ScreenOrientation.HORIZONTAL) {
            this.scale.set(1);
        }
        else {
            this.scale.set(2);
        }
    }
    // PRIVATE API
    get settings() {
        const data = {
            spinsLeft: this.spinsNumber,
            //spinsLeft: this.infinteAutoplayBtn.checked ? 100 : this.spinsNumber,
        };
        return data;
    }
    // PRIVATE API
    updateLayoutElements(width, x) {
        super.updateLayoutElements(width, x);
    }
    onTurboBtnSelected(level) {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        this.turboLevel = level;
        this.updateTuroBtn(level);
        const gs = dependency_container_instance.resolve(services_GameService);
        this.slotMachine.currentGameSpeedLevel = level;
        // gs.settings.quickSpin = level;
        gs.saveSettings();
    }
    // USER INTERACTION
    onBtnConfirm() {
        super.onBtnClose();
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentBetValue = this.currentBetValue;
        if (this.turboLevel || this.turboLevel == 0) {
            this.slotMachine.currentGameSpeedLevel = this.turboLevel;
        }
        //this.slotMachine.autoplay.infinite = false;
        //this.slotMachine.autoplay.infinite = this.infinteAutoplayBtn.checked;
        new ControlEvent(UIEvent.AUTO_SPIN, this.settings).dispatch();
    }
    updateSpinNumbers() {
        this.tfTotalAutoSpinValue.text = `${this.spinsNumber}`;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'MetricsView':
                instance = new MetricsView(le);
                break;
            case 'SwitchView':
                instance = new SwitchView(le);
                break;
            case 'Slider':
                instance = new SliderMinMaxText({
                    bg: 'BarMin',
                    fill: 'BarMiniFill',
                    slider: 'barCenter',
                    min: 0,
                    max: 1000,
                    value: 500
                });
                break;
            case 'SliderBig':
                instance = new SliderMinMaxText({
                    bg: 'barBig-1',
                    fill: 'barBig-fill',
                    slider: 'barCenter',
                    min: 0,
                    max: 1000,
                    value: 500
                });
                break;
            case 'CheckBox':
                instance = new CheckBox({
                    style: {
                        checked: 'Skip Screen on',
                        unchecked: "Skip Screen off"
                    },
                    checked: localStorage.getItem("skipScreen") == "true" ? true : false
                });
                break;
            case 'CheckBoxInfinite':
                this.slotMachine = dependency_container_instance.resolve(SlotMachine);
                instance = new CheckBox({
                    style: {
                        checked: "LimitlesSpinon",
                        unchecked: "LimitlesSpinOff"
                    },
                    //checked: this.slotMachine.autoplay.infinite
                });
                break;
        }
        return instance;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/PaytableSymbolCell.ts









class PaytableSymbolCell extends Container_Container {
    constructor(le, orientation, symbolData, config = null, symbolDoubleData = null, standardSize = 0, iconsSpacing = 0) {
        super();
        this.tfPaysArr = [];
        this.config = {
            maxFontSize: 20,
            maxHeight: 60,
            maxWidth: 120,
            setMultipliers: true,
            multiplierList: [5, 4, 3, 2]
        };
        LayoutBuilder.create(le, this);
        if (config)
            this.config = config;
        this.symbolId = symbolData.id;
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        if (this.config.setMultipliers) {
            this.slotMachine.on(SlotMachineEvent.BET_VALUE_CHANGED, () => {
                this.setMultipliers(this.symbolId);
            }, this);
            this.wallet.on(WalletEvent.COIN_VALUE_CHANGED, () => {
                this.setMultipliers(this.symbolId);
            }, this);
        }
        this.multiplierDescriptionSpacingY = orientation == ScreenOrientation.HORIZONTAL ?
            dependency_container_instance.resolve(CommonTokenConstants.PAYTABLE_PANEL_SYMBOL_DESCRIPTION_SPACING).desktop :
            dependency_container_instance.resolve(CommonTokenConstants.PAYTABLE_PANEL_SYMBOL_DESCRIPTION_SPACING).mobile;
        this.addIcon(symbolData, symbolDoubleData, standardSize, iconsSpacing);
        if (this.config.setMultipliers) {
            this.config.multiplierList.forEach(item => {
                this.tfPaysArr.push({
                    tfPays: this['multiplierDescription'][`tfPays${item}`],
                    count: item
                });
            });
            this.setMultipliers(symbolData.id);
        }
        else
            this.multiplierDescription.visible = false;
    }
    addIcon(symbolData, symbolDoubleData, standardSize, iconSpacing = 0) {
        const staticIcon = new Sprite(symbolData.staticIcon.texture);
        let staticDoubleIcon;
        // Sprite can take null for parameter so -> new Sprite(symbol?.static.texture) <- will not work
        if (symbolDoubleData)
            staticDoubleIcon = new Sprite(symbolDoubleData.staticIcon.texture);
        staticIcon.pivot.set(staticIcon.width / 2, staticIcon.height / 2);
        this.staticIcon.addChild(staticIcon);
        if (staticDoubleIcon) {
            staticDoubleIcon.pivot.set(staticDoubleIcon.width / 2, staticDoubleIcon.height / 2);
            this.staticIcon2.addChild(staticDoubleIcon);
        }
        if (!standardSize)
            standardSize = staticIcon.width;
        // change the standardized size if the starling scale is changed
        standardSize = standardSize * this.staticIcon.scale.x;
        // !!! all symbols have different texture sizes
        this.staticIcon2.x += iconSpacing + standardSize;
        this.pivot.x -= standardSize / 2 - iconSpacing / 2;
        this.pivot.y -= standardSize / 2 - iconSpacing / 2;
        this.standardSize = symbolDoubleData ? standardSize * 2 + iconSpacing : standardSize + iconSpacing;
    }
    get width() {
        return this.standardSize;
    }
    get height() {
        return this.standardSize + this.multiplierDescription.height;
    }
    setMultipliers(symbolId) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (symbolId > 100 && symbolId < 1000) {
            this.tfPaysArr.forEach((tfPays) => {
                tfPays.tfPays.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, tfPays.count).reward.line.multiplier * dependency_container_instance.resolve(SlotMachine).totalBet * dependency_container_instance.resolve(model_Wallet).coinValue)}`;
            });
        }
        this.repositionMultipliers();
    }
    repositionMultipliers() {
        const spacingX = 36;
        const md = this['multiplierDescription'];
        this.config.multiplierList.forEach((item, index) => {
            const height = md[`${item}x`].height;
            md[`${item}x`].x = 0;
            md[`${item}x`].y = height * index;
            md[`separator${item}`].x = spacingX;
            md[`separator${item}`].y = height * index;
            md[`tfPays${item}`].x = md[`separator${item}`].x + md[`separator${item}`].width + spacingX / 2;
            md[`tfPays${item}`].y = height * index;
        });
        this.centerMultiplierContainer();
    }
    centerMultiplierContainer() {
        this.multiplierDescription.pivot.set(this.multiplierDescription.width / 2, 0);
        this.multiplierDescription.x = 0;
        this.multiplierDescription.y = this.standardSize / 2 + this.multiplierDescriptionSpacingY;
    }
    scatterMultiplier(symbolId, parent) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        // this.tfPays6 = parent['multiplierDescription']['tfPays6'];
        // this.tfPays5 = parent['multiplierDescription']['tfPays5'];
        // this.tfPays4 = parent['multiplierDescription']['tfPays4'];
        //
        // if (symbolId == 25) {
        //     this.tfPays6.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 6).reward.line.multiplier * container.resolve(SlotMachine).totalBet * container.resolve(Wallet).coinValue)}`;
        //     this.tfPays5.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 5).reward.line.multiplier * container.resolve(SlotMachine).totalBet * container.resolve(Wallet).coinValue)}`;
        //     this.tfPays4.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 4).reward.line.multiplier * container.resolve(SlotMachine).totalBet * container.resolve(Wallet).coinValue)}`;
        //this.updateView(250, parent['multiplierDescription'].children as Text[]);
    }
}
var LayoutOrientation;
(function (LayoutOrientation) {
    LayoutOrientation["HORIZONTAL"] = "horizontal";
    LayoutOrientation["VERTICAL"] = "vertical";
})(LayoutOrientation || (LayoutOrientation = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/PaytablePanelDesktop.ts







class PaytablePanelDesktop extends Panel {
    constructor(config) {
        super(assets_AssetsManager.layouts.get('PaytablePanelDesktop'));
        this.config = config;
        this.symbolCells = [];
        this.pages = [];
        this.currentPage = null;
        this._currentPageIndex = -1;
        this.symbolsContainers = [];
        this.cellsSpacing = dependency_container_instance.resolve(CommonTokenConstants.PAYTABEL_PANEL_SYMBOL_CELL_SPACING).desktop;
        for (let i = 0; this['page_' + i]; i++) {
            const p = this['page_' + i];
            this.removeChild(p);
            this.pages.push(p);
        }
        this.currentPageIndex = 0;
        const minMaxTf = this.pages[4]['tf6'];
        minMaxTf.text = minMaxTf.text
            .replace("<DYN_1>", config.minBet)
            .replace("<DYN_2>", config.maxBet);
        this.symbolsContainers = this.pages
            .map(page => page['item_1'])
            .filter(container => container);
        // wait for reposition of all symbols to center container
        this.symbolsContainers.forEach((container) => {
            container.pivot.x = (container.width / 2);
            container.x = this.background.width / 2;
        });
        this.createSymbols();
        this.onChangePageIndex();
        this.btnPreviousPage.on('pointerup', this.onButtonPrev, this);
        this.btnNextPage.on('pointerup', this.onButtonNext, this);
    }
    // PRIVATE API
    createSymbols() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        // Filter out excluded symbols
        const symbolsCopy = [...this.config.symbolsList];
        const excludedSymbols = this.config.excludedSymbols;
        const symbolsToCreate = symbolsCopy.filter(symbol => !excludedSymbols.includes(symbol.id));
        const symbolsSorted = symbolsToCreate.sort((a, b) => {
            var _a, _b, _c, _d, _e, _f;
            return ((((_c = (_b = (_a = sm === null || sm === void 0 ? void 0 : sm.findRule(a.id, 5)) === null || _a === void 0 ? void 0 : _a.reward) === null || _b === void 0 ? void 0 : _b.line) === null || _c === void 0 ? void 0 : _c.multiplier) > ((_f = (_e = (_d = sm === null || sm === void 0 ? void 0 : sm.findRule(b.id, 5)) === null || _d === void 0 ? void 0 : _d.reward) === null || _e === void 0 ? void 0 : _e.line) === null || _f === void 0 ? void 0 : _f.multiplier)) && a.id) ? -1 : 1;
        });
        const symbolsDouble = this.config.symbolsDoubles ? [...this.config.symbolsDoubles] : [];
        let symbolsDoubleSorted;
        if (symbolsDouble.length) {
            const indexMap = new Map();
            sm.description.rules.forEach(rule => {
                symbolsSorted.forEach((value, index) => {
                    if (rule.pattern.symbolId == value.id)
                        indexMap.set(rule.symbolDoubled, index);
                });
            });
            symbolsDoubleSorted = sm.findDoubledSymbol(symbolsDouble, indexMap);
        }
        this.standardTextureSymbolSize = this.findStandardTexture(symbolsSorted);
        const symbolsPerPage = this.config.symbolsPerPage.map(desc => desc.rows.reduce((p, c) => p + c, 0));
        const cummulativeSymbolsPerPage = symbolsPerPage.map((_, index, arr) => arr.slice(0, index).reduce((p, c) => p + c, arr[0]));
        const symbolCellLayout = assets_AssetsManager.layouts.get('PaytableSymbolCellDesktop');
        symbolsPerPage.forEach(_ => this.symbolCells.push([]));
        for (let i = 0, insertedSymbols = 0; i < symbolsSorted.length; i++) {
            const symbolCell = new PaytableSymbolCell(symbolCellLayout, ScreenOrientation.HORIZONTAL, symbolsSorted[i], {
                setMultipliers: true,
                maxFontSize: 15,
                maxHeight: 60,
                maxWidth: 80,
                multiplierList: this.config.multiplierList
            }, symbolsDoubleSorted ? symbolsDoubleSorted[i] : null, this.standardTextureSymbolSize, 10);
            const symbolsPerPageIndex = cummulativeSymbolsPerPage.findIndex(count => count > insertedSymbols);
            if (symbolsPerPageIndex >= 0) {
                this.symbolCells[symbolsPerPageIndex].push(symbolCell);
                this.symbolsContainers[symbolsPerPageIndex].addChild(symbolCell);
                insertedSymbols++;
            }
        }
        this.createSymbolsWithDescription();
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        const offsetBorder = 100;
        const defaultDesktopBackgroundWidth = 1260;
        if (desc.orientation == ScreenOrientation.VERTICAL) {
            this.background.width = desc.currentWidth + offsetBorder;
            this.y = desc.baseHeight / 2 + (desc.currentHeight - desc.baseHeight) / 2;
        }
        else {
            this.background.width = defaultDesktopBackgroundWidth;
            this.y = 0;
        }
        this.symbolCells.forEach((cells, index) => {
            this.updateSymbolsView(cells, this.symbolsContainers[index]['area'], this.config.symbolsPerPage[index].rows);
            this.symbolsContainers[index]['area'].alpha = 0;
        });
        this.symbolsContainers.forEach((container) => {
            container.pivot.x = (container.width / 2);
            container.x = this.background.width / 2;
        });
    }
    updateSymbolsView(symbols, container, elementsInRow) {
        let currentId = 0;
        elementsInRow.forEach((elInRow, index) => {
            const offset = (container.width - (symbols[currentId].width * elInRow + this.cellsSpacing.x * (elInRow - 1))) / 2;
            for (let i = 0; i < elInRow; i++) {
                const currentSymbolCell = symbols[currentId];
                currentSymbolCell.x = offset + (currentSymbolCell.width + this.cellsSpacing.x) * i;
                currentSymbolCell.y = this.cellsSpacing.y * index;
                currentId++;
            }
        });
    }
    get currentPageIndex() {
        return this._currentPageIndex;
    }
    set currentPageIndex(value) {
        if (this._currentPageIndex == value) {
            return;
        }
        this._currentPageIndex = value;
        if (this.currentPage) {
            this.removeChild(this.currentPage);
        }
        this.currentPage = this.pages[this._currentPageIndex];
        this.addChild(this.currentPage);
    }
    createSymbolsWithDescription() {
        if (!this.config.symbolsWithDescription)
            return;
        this.config.symbolsWithDescription.forEach((desc) => {
            this.createSymbolInProperItem(desc.itemId, this.config.symbolsList.find((symbol) => symbol.id === desc.symbolId), desc.symbolDouble ? this.config.symbolsDoubles.find((symbol) => symbol.id === desc.symbolDouble) : null);
        });
    }
    createSymbolInProperItem(itemId, symbolData, symbolDoubleData) {
        if (!symbolData)
            return;
        const parent = this.pages[0][`item_${itemId}`];
        const symbolIcon = new PaytableSymbolCell(assets_AssetsManager.layouts.get('PaytableSymbolCellDesktop'), ScreenOrientation.HORIZONTAL, symbolData, {
            setMultipliers: false,
            maxFontSize: 15,
            maxHeight: 60,
            maxWidth: 120,
        }, symbolDoubleData ? symbolDoubleData : null, this.standardTextureSymbolSize);
        if (parent['area']) {
            parent['area'].visible = false;
        }
        if (parent['multiplierDescription']) {
            symbolIcon.scatterMultiplier(symbolData.id, parent);
        }
        parent['iconSlot'].addChild(symbolIcon);
        symbolIcon.eventMode = 'none';
    }
    // USER INTERACTION
    onButtonPrev() {
        // Signed 0 needs special case with negatives -> ((n % m) + m) % m negates the side effect
        this.currentPageIndex = (((this.currentPageIndex - 1) % this.pages.length) + this.pages.length) % this.pages.length;
        this.onChangePageIndex();
    }
    onButtonNext() {
        this.currentPageIndex = (this.currentPageIndex + 1) % this.pages.length;
        this.onChangePageIndex();
    }
    onChangePageIndex() {
        this.tfPageNumber.text = `${this.currentPageIndex + 1}/${this.pages.length}`;
    }
}

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/List.mjs


class List extends Container_Container {
  constructor(options) {
    super();
    /** Returns all arranged elements. */
    this.children = [];
    if (options) {
      this.init(options);
    }
    options?.items?.forEach((item) => this.addChild(item));
    this.on("added", () => this.arrangeChildren());
    this.on("childAdded", () => this.arrangeChildren());
  }
  /**
   * Initiates list component.
   * @param options
   */
  init(options) {
    this.options = options;
    if (options?.type) {
      this.type = options.type;
    }
    if (options?.children) {
      options.children.forEach((child) => this.addChild(child));
    }
  }
  /**
   * Set items arrange direction.
   * @param type - Arrange direction.
   */
  set type(type) {
    this._type = type;
    this.arrangeChildren();
  }
  /**
   * Get items arrange direction.
   * @returns Arrange direction.
   */
  get type() {
    return this._type;
  }
  /**
   * Set element margin.
   * @param margin - Margin between elements.
   */
  set elementsMargin(margin) {
    this.options.elementsMargin = margin;
    this.arrangeChildren();
  }
  /**
   * Get element margin.
   * @returns Margin between elements.
   */
  get elementsMargin() {
    return this.options.elementsMargin;
  }
  /**
   * Set vertical padding.
   * @param padding - Vertical padding between list border and its elements.
   */
  set vertPadding(padding) {
    this.options.vertPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get vertical padding.
   * @returns Vertical padding between list border and its elements.
   */
  get vertPadding() {
    return this.options.vertPadding;
  }
  /**
   * Set horizontal padding.
   * @param padding - Horizontal padding between list border and its elements.
   */
  set horPadding(padding) {
    this.options.horPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get horizontal padding.
   * @returns Horizontal padding between list border and its elements.
   */
  get horPadding() {
    return this.options.horPadding;
  }
  /**
   * Arrange all elements basing in their sizes and component options.
   * Can be arranged vertically, horizontally or bidirectional.
   */
  arrangeChildren() {
    let x = this.options?.horPadding ?? 0;
    let y = this.options?.vertPadding ?? 0;
    const elementsMargin = this.options?.elementsMargin ?? 0;
    let maxWidth = this.parent?.width;
    if (this.options?.horPadding) {
      maxWidth -= this.options.horPadding;
    }
    this.children.forEach((child, id) => {
      switch (this.type) {
        case "vertical":
          child.y = y;
          child.x = x;
          y += elementsMargin + child.height;
          break;
        case "horizontal":
          child.x = x;
          child.y = y;
          x += elementsMargin + child.width;
          break;
        default:
          child.x = x;
          child.y = y;
          if (child.x + child.width >= maxWidth && id > 0) {
            y += elementsMargin + child.height;
            x = this.options?.horPadding ?? 0;
            child.x = x;
            child.y = y;
          }
          x += elementsMargin + child.width;
          break;
      }
    });
  }
}


//# sourceMappingURL=List.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/utils/trackpad/Spring.mjs
class Spring {
  constructor(options = {}) {
    this.x = 0;
    this.ax = 0;
    this.dx = 0;
    this.tx = 0;
    this._options = options;
    this._options.max = options.max || 160;
    this._options.damp = options.damp || 0.8;
    this._options.springiness = options.springiness || 0.1;
  }
  update() {
    this.ax = (this.tx - this.x) * this._options.springiness;
    this.dx += this.ax;
    this.dx *= this._options.damp;
    if (this.dx < -this._options.max)
      this.dx = -this._options.max;
    else if (this.dx > this._options.max)
      this.dx = this._options.max;
    this.x += this.dx;
  }
  reset() {
    this.x = 0;
    this.ax = 0;
    this.dx = 0;
    this.tx = 0;
  }
  get max() {
    return this._options.max;
  }
  set max(value) {
    this._options.max = value;
  }
  get damp() {
    return this._options.damp;
  }
  set damp(value) {
    this._options.damp = value;
  }
  get springiness() {
    return this._options.springiness;
  }
  set springiness(value) {
    this._options.springiness = value;
  }
}


//# sourceMappingURL=Spring.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/utils/trackpad/ScrollSpring.mjs


class ScrollSpring {
  constructor() {
    this._spring = new Spring();
    this._pos = 0;
    this.to = 0;
  }
  start(speed, pos, to) {
    this._speed = speed;
    this._pos = pos;
    this.to = to;
    this.done = false;
    this._spring.x = this._pos;
    this._spring.tx = this.to;
    const diff = this.to - this._pos;
    const toDirection = Math.abs(diff) / diff;
    const currentDirection = Math.abs(this._speed) / this._speed;
    if (toDirection !== currentDirection) {
      this._correctSpeed = true;
    } else {
      this._correctSpeed = false;
    }
  }
  update() {
    if (this._correctSpeed) {
      this._speed *= 0.6;
      if (Math.abs(this._speed) < 2) {
        this._correctSpeed = false;
      }
      this._pos += this._speed;
      this._spring.x = this._pos;
    } else {
      const diff = this.to - this._pos;
      if (Math.abs(diff) < 0.05) {
        this._pos = this.to;
        this.done = true;
      } else {
        this._spring.tx = this.to;
        this._spring.update();
        this._pos = this._spring.x;
      }
    }
    return this._pos;
  }
  cancel() {
  }
}


//# sourceMappingURL=ScrollSpring.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/utils/trackpad/SlidingNumber.mjs


class SlidingNumber {
  constructor(options = {}) {
    this.position = 0;
    this.constrain = true;
    this.min = 0;
    // the window width of the drag
    this.max = 0;
    // the window width of the drag
    this.maxSpeed = 400;
    this._offset = 0;
    this._prev = 0;
    this._speed = 0;
    this._targetSpeed = 0;
    this._speedChecker = 0;
    this._grab = 0;
    this.constrain = options.constrain ?? true;
    this.maxSpeed = options.maxSpeed ?? 400;
    this._ease = options.ease ?? new ScrollSpring();
  }
  set value(n) {
    this._speed = 0;
    this.position = n;
  }
  get value() {
    return this.position;
  }
  grab(offset) {
    this._grab = offset;
    this._offset = this.position - offset;
    this._speedChecker = 0;
    this._targetSpeed = this._speed = 0;
    this._hasStopped = false;
  }
  hold(newPosition) {
    this._speedChecker++;
    this.position = newPosition + this._offset;
    if (this._speedChecker > 1) {
      this._targetSpeed = this.position - this._prev;
    }
    this._speed += (this._targetSpeed - this._speed) / 2;
    if (this._speed > this.maxSpeed)
      this._speed = this.maxSpeed;
    else if (this._speed < -this.maxSpeed)
      this._speed = -this.maxSpeed;
    this._prev = this.position;
    if (this.constrain) {
      this._activeEase = null;
      if (this.position > this.min) {
        this.position -= (this.position - this.min) / 1.5;
      } else if (this.position < this.max) {
        this.position += (this.max - this.position) / 1.5;
      }
    }
  }
  slide(instant = false) {
    if (this._hasStopped)
      return;
    if (this.constrain) {
      this._updateConstrain(instant);
    } else {
      this._updateDefault();
    }
  }
  get moveAmount() {
    return -(this.position - this._offset - this._grab);
  }
  _updateDefault() {
    this._speed *= 0.9;
    this.position += this._speed;
    if ((this._speed < 0 ? this._speed * -1 : this._speed) < 0.01) {
      this._hasStopped = true;
    }
  }
  _updateConstrain(instant = false) {
    const max = this.max;
    if (instant) {
      if (this.value > 0) {
        this.value = 0;
      }
      if (this.value > 0) {
        this.value = 0;
      }
      if (this.value < this.max) {
        this.value = this.max;
      }
      if (this.value < this.max) {
        this.value = this.max;
      }
    } else if (this.position > this.min || this.position < max || this._activeEase) {
      if (!this._activeEase) {
        this._activeEase = this._ease;
        if (this.position > this.min) {
          this._activeEase.start(this._speed, this.position, this.min);
        } else {
          this._activeEase.start(this._speed, this.position, max);
        }
      }
      this.position = this._activeEase.update();
      if (this._activeEase.done) {
        this.position = this._activeEase.to;
        this._speed = 0;
        this._activeEase = null;
      }
    } else {
      this._updateDefault();
    }
  }
}


//# sourceMappingURL=SlidingNumber.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/utils/trackpad/Trackpad.mjs



class Trackpad {
  constructor(options) {
    this.disableEasing = false;
    this.xAxis = new SlidingNumber({
      ease: options.xEase,
      maxSpeed: options.maxSpeed,
      constrain: options.constrain
    });
    this.yAxis = new SlidingNumber({
      ease: options.yEase,
      maxSpeed: options.maxSpeed,
      constrain: options.constrain
    });
    this.disableEasing = options.disableEasing ?? false;
    this._frame = new Rectangle();
    this._bounds = new Rectangle();
    this._globalPosition = new Point();
  }
  pointerDown(pos) {
    this._globalPosition = pos;
    this.xAxis.grab(pos.x);
    this.yAxis.grab(pos.y);
    this._isDown = true;
  }
  pointerUp() {
    this._isDown = false;
  }
  pointerMove(pos) {
    this._globalPosition = pos;
  }
  update() {
    if (this._dirty) {
      this._dirty = false;
      this.xAxis.min = this._bounds.left;
      this.xAxis.min = this._bounds.right - this._frame.width;
      this.xAxis.min = this._bounds.top;
      this.xAxis.min = this._bounds.bottom - this._frame.height;
    }
    if (this._isDown) {
      this.xAxis.hold(this._globalPosition.x);
      this.yAxis.hold(this._globalPosition.y);
    } else {
      this.xAxis.slide(this.disableEasing);
      this.yAxis.slide(this.disableEasing);
    }
  }
  resize(w, h) {
    this._frame.x = 0;
    this._frame.width = w;
    this._frame.y = 0;
    this._frame.height = h;
    this._dirty = true;
  }
  setBounds(minX, maxX, minY, maxY) {
    this._bounds.x = minX;
    this._bounds.width = maxX - minX;
    this._bounds.y = minY;
    this._bounds.height = maxY - minY;
    this._dirty = true;
  }
  get x() {
    return this.xAxis.value;
  }
  get y() {
    return this.yAxis.value;
  }
}


//# sourceMappingURL=Trackpad.mjs.map

;// CONCATENATED MODULE: ./node_modules/@pixi/ui/lib/ScrollBox.mjs







class ScrollBox extends Container_Container {
  /**
   * @param options
   * @param {number} options.background - background color of the ScrollBox.
   * @param {number} options.width - width of the ScrollBox.
   * @param {number} options.height - height of the ScrollBox.
   * @param {number} options.radius - radius of the ScrollBox and its masks corners.
   * @param {number} options.elementsMargin - margin between elements.
   * @param {number} options.vertPadding - vertical padding of the ScrollBox.
   * @param {number} options.horPadding - horizontal padding of the ScrollBox.
   * @param {number} options.padding - padding of the ScrollBox (same horizontal and vertical).
   * @param {boolean} options.disableDynamicRendering - disables dynamic rendering of the ScrollBox,
   * so even elements the are not visible will be rendered. Be careful with this options as it can impact performance.
   */
  constructor(options) {
    super();
    this.__width = 0;
    this.__height = 0;
    this.isDragging = 0;
    this.interactiveStorage = [];
    this.visibleItems = [];
    this.ticker = Ticker.shared;
    if (options) {
      this.init(options);
    }
    this.ticker.add(this.update, this);
    this.onMouseScrollBinded = this.onMouseScroll.bind(this);
  }
  /**
   * Initiates ScrollBox.
   * @param options
   * @param {number} options.background - background color of the ScrollBox.
   * @param {number} options.width - width of the ScrollBox.
   * @param {number} options.height - height of the ScrollBox.
   * @param {number} options.radius - radius of the ScrollBox and its masks corners.
   * @param {number} options.elementsMargin - margin between elements.
   * @param {number} options.vertPadding - vertical padding of the ScrollBox.
   * @param {number} options.horPadding - horizontal padding of the ScrollBox.
   * @param {number} options.padding - padding of the ScrollBox (same horizontal and vertical).
   * @param {boolean} options.disableDynamicRendering - disables dynamic rendering of the ScrollBox,
   * so even elements the are not visible will be rendered. Be careful with this options as it can impact performance.
   */
  init(options) {
    this.options = options;
    this.setBackground(options.background);
    this.__width = options.width | this.background.width;
    this.__height = options.height | this.background.height;
    options.vertPadding = options.vertPadding ?? options.padding ?? 0;
    options.horPadding = options.horPadding ?? options.padding ?? 0;
    if (!this.list) {
      this.list = new List();
      super.addChild(this.list);
    }
    this.list.init({
      type: options.type,
      elementsMargin: options.elementsMargin,
      vertPadding: options.vertPadding,
      horPadding: options.horPadding
    });
    this.addItems(options.items);
    if (this.hasBounds) {
      this.addMask();
      this.makeScrollable();
    }
    this._trackpad.xAxis.value = 0;
    this._trackpad.yAxis.value = 0;
    this.resize();
  }
  get hasBounds() {
    return !!this.__width || !!this.__height;
  }
  onChildrenChange() {
  }
  /**
   *  Adds array of items to a scrollable list.
   * @param {Container[]} items - items to add.
   */
  addItems(items) {
    if (!items?.length)
      return;
    items.forEach((item) => this.addItem(item));
  }
  /** Remove all items from a scrollable list. */
  removeItems() {
    this.list.removeChildren();
  }
  /**
   * Adds one or more items to a scrollable list.
   * @param {Container} items - one or more items to add.
   */
  addItem(...items) {
    if (items.length > 1) {
      items.forEach((item) => this.addItem(item));
    } else {
      const child = items[0];
      if (!child.width || !child.height) {
        console.error("ScrollBox item should have size");
      }
      child.eventMode = "static";
      this.list.addChild(child);
      if (!this.options.disableDynamicRendering) {
        child.renderable = this.isItemVisible(child);
      }
    }
    this.resize();
    return items[0];
  }
  /**
   * Removes an item from a scrollable list.
   * @param {number} itemID - id of the item to remove.
   */
  removeItem(itemID) {
    const child = this.list.children[itemID];
    if (!child) {
      return;
    }
    this.list.removeChild(child);
    this.resize();
  }
  /**
   * Checks if the item is visible or scrolled out of the visible part of the view.* Adds an item to a scrollable list.
   * @param {Container} item - item to check.
   */
  isItemVisible(item) {
    const isVertical = this.options.type === "vertical" || !this.options.type;
    let isVisible = false;
    const list = this.list;
    if (isVertical) {
      const posY = item.y + list.y;
      if (posY + item.height + this.options.vertPadding >= 0 && posY - this.options.vertPadding - this.options.elementsMargin <= this.options.height) {
        isVisible = true;
      }
    } else {
      const posX = item.x + list.x;
      if (posX + item.width >= 0 && posX <= this.options.width) {
        isVisible = true;
      }
    }
    return isVisible;
  }
  /**
   * Returns all inner items in a list.
   * @returns {Array<Container> | Array} - list of items.
   */
  get items() {
    return this.list?.children ?? [];
  }
  /**
   * Set ScrollBox background.
   * @param {number | string} background - background color or texture.
   */
  setBackground(background) {
    if (this.background) {
      this.removeChild(this.background);
      if (this.background instanceof Sprite) {
        this.background.destroy();
      }
    }
    this.options.background = background;
    this.background = background !== void 0 && typeof background === "string" ? Sprite.from(background) : new Graphics_Graphics();
    this.addChildAt(this.background, 0);
    this.resize();
  }
  addMask() {
    if (!this.borderMask) {
      this.borderMask = new Graphics_Graphics();
      super.addChild(this.borderMask);
      this.mask = this.borderMask;
    }
    this.resize();
  }
  makeScrollable() {
    if (!this._trackpad) {
      this._trackpad = new Trackpad({
        disableEasing: this.options.disableEasing
      });
    }
    this.on("pointerdown", (e) => {
      this.isDragging = 1;
      const touchPoint = this.worldTransform.applyInverse(e.global);
      this._trackpad.pointerDown(touchPoint);
      const listTouchPoint = this.list.worldTransform.applyInverse(e.global);
      this.visibleItems.forEach((item) => {
        if (item.x < listTouchPoint.x && item.x + item.width > listTouchPoint.x && item.y < listTouchPoint.y && item.y + item.height > listTouchPoint.y) {
          this.pressedChild = item;
        }
      });
    });
    this.on("pointerup", () => {
      this.isDragging = 0;
      this._trackpad.pointerUp();
      this.restoreItemsInteractivity();
      this.pressedChild = null;
    });
    this.on("pointerupoutside", () => {
      this.isDragging = 0;
      this._trackpad.pointerUp();
      this.restoreItemsInteractivity();
      this.pressedChild = null;
    });
    this.on("globalpointermove", (e) => {
      const touchPoint = this.worldTransform.applyInverse(e.global);
      this._trackpad.pointerMove(touchPoint);
      if (!this.isDragging)
        return;
      if (this.pressedChild) {
        this.revertClick(this.pressedChild);
        this.pressedChild = null;
      }
    });
    const { onMouseHover, onMouseOut } = this;
    this.on("mouseover", onMouseHover, this).on("mouseout", onMouseOut, this);
  }
  setInteractive(interactive) {
    this.eventMode = interactive ? "static" : "auto";
  }
  get listHeight() {
    return this.list.height + this.options.vertPadding * 2;
  }
  get listWidth() {
    return this.list.width + this.options.horPadding * 2;
  }
  /** Controls item positions and visibility. */
  resize() {
    if (!this.hasBounds)
      return;
    this.renderAllItems();
    if (this.borderMask && (this.lastWidth !== this.listWidth || this.lastHeight !== this.listHeight)) {
      const verPadding = this.options.vertPadding;
      const horPadding = this.options.horPadding;
      if (!this.options.width) {
        this.__width += this.listWidth;
      }
      if (!this.options.height) {
        this.__height += this.listHeight;
      }
      this.borderMask.clear().lineStyle(0).beginFill(16777215).drawRoundedRect(
        0,
        0,
        this.__width,
        this.__height,
        this.options.radius | 0
      );
      this.borderMask.eventMode = "none";
      if (this.background instanceof Graphics_Graphics) {
        this.background.clear().lineStyle(0);
        const color = this.options.background;
        this.background.beginFill(
          color ?? 0,
          color ? 1 : 1e-7
          // if color is not set, set alpha to 0 to be able to drag by click on bg
        );
        this.background.drawRect(
          0,
          0,
          this.__width + horPadding,
          this.__height + verPadding
        );
      }
      if (this.options.type === "horizontal") {
        this.setInteractive(this.listWidth > this.__width);
      } else {
        this.setInteractive(this.listHeight > this.__height);
      }
      this.lastWidth = this.listWidth;
      this.lastHeight = this.listHeight;
    }
    if (this._trackpad) {
      const maxWidth = this.borderMask.width - this.list.width - this.options.horPadding * 2;
      const maxHeight = this.borderMask.height - this.list.height - this.options.vertPadding * 2;
      if (this.options.type === "vertical") {
        this._trackpad.yAxis.max = -Math.abs(maxHeight);
      } else if (this.options.type === "horizontal") {
        this._trackpad.xAxis.max = -Math.abs(maxWidth);
      } else {
        this._trackpad.yAxis.max = -Math.abs(maxHeight);
        this._trackpad.xAxis.max = -Math.abs(maxWidth);
      }
    }
    this.stopRenderHiddenItems();
  }
  onMouseHover() {
    this.renderAllItems();
    document.addEventListener("mousewheel", this.onMouseScrollBinded);
    document.addEventListener("DOMMouseScroll", this.onMouseScrollBinded);
  }
  onMouseOut() {
    this.stopRenderHiddenItems();
    document.removeEventListener("mousewheel", this.onMouseScrollBinded);
    document.removeEventListener(
      "DOMMouseScroll",
      this.onMouseScrollBinded
    );
  }
  onMouseScroll(event) {
    this.renderAllItems();
    if (this.options.type === "horizontal" && (typeof event.deltaX !== "undefined" || typeof event.deltaY !== "undefined")) {
      const targetPos = event.deltaY ? this.list.x - event.deltaY : this.list.x - event.deltaX;
      if (targetPos < 0 && targetPos + this.listWidth + this.options.horPadding < this.__width) {
        this._trackpad.xAxis.value = this.__width - this.listWidth;
      } else if (targetPos > this.options.horPadding) {
        this._trackpad.xAxis.value = 0;
      } else {
        this._trackpad.xAxis.value = targetPos;
      }
    } else if (typeof event.deltaY !== "undefined") {
      const targetPos = this.list.y - event.deltaY;
      if (targetPos < 0 && targetPos + this.listHeight + this.options.vertPadding < this.__height) {
        this._trackpad.yAxis.value = this.__height - this.listHeight;
      } else if (targetPos > this.options.vertPadding) {
        this._trackpad.yAxis.value = 0;
      } else {
        this._trackpad.yAxis.value = targetPos;
      }
    }
    this.stopRenderHiddenItems();
  }
  /** Makes it scroll down to the last element. */
  scrollBottom() {
    if (!this.interactive) {
      this.scrollTop();
    } else {
      this.scrollTo(this.list.children.length - 1);
    }
  }
  /** Makes it scroll up to the first element. */
  scrollTop() {
    this._trackpad.xAxis.value = 0;
    this._trackpad.yAxis.value = 0;
  }
  renderAllItems() {
    if (this.options.disableDynamicRendering) {
      return;
    }
    this.items.forEach((child) => {
      child.renderable = true;
    });
  }
  stopRenderHiddenItems() {
    if (this.options.disableDynamicRendering) {
      return;
    }
    this.visibleItems.length = 0;
    this.items.forEach((child) => {
      child.renderable = this.isItemVisible(child);
      this.visibleItems.push(child);
    });
  }
  /**
   * Scrolls to the element with the given ID.
   * @param elementID
   */
  scrollTo(elementID) {
    if (!this.interactive) {
      return;
    }
    const target = this.list.children[elementID];
    if (!target) {
      return;
    }
    this._trackpad.xAxis.value = this.options.type === "horizontal" ? this.__width - target.x - target.width - this.options.horPadding : 0;
    this._trackpad.yAxis.value = !this.options.type || this.options.type === "vertical" ? this.__height - target.y - target.height - this.options.vertPadding : 0;
  }
  /** Gets component height. */
  get height() {
    return this.__height;
  }
  /** Gets component width. */
  get width() {
    return this.__width;
  }
  update() {
    if (!this.list)
      return;
    this._trackpad.update();
    const type = this.options.type === "horizontal" ? "x" : "y";
    if (this.list[type] !== this._trackpad[type]) {
      this.list[type] = this._trackpad[type];
    }
  }
  /** Destroys the component. */
  destroy() {
    this.ticker.remove(this.update, this);
    this.background.destroy();
    this.list.destroy();
    super.destroy();
  }
  restoreItemsInteractivity() {
    this.interactiveStorage.forEach((element) => {
      element.item.eventMode = element.eventMode;
    });
    this.interactiveStorage.length = 0;
  }
  revertClick(item) {
    if (item.eventMode !== "auto") {
      isMobile_isMobile.any ? item.emit("pointerupoutside", null) : item.emit("mouseupoutside", null);
      this.interactiveStorage.push({
        item,
        eventMode: item.eventMode
      });
      item.eventMode = "auto";
    }
    if (item instanceof Container_Container && item.children) {
      item.children.forEach((child) => this.revertClick(child));
    }
  }
}


//# sourceMappingURL=ScrollBox.mjs.map

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/ScrolledContent.ts



class ScrolledContent extends Container_Container {
    constructor(le, classResolver = null) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            if (classResolver) {
                return classResolver(le);
            }
        });
        this.scrollBox = new ScrollBox({
            type: 'vertical',
            width: this.area.width,
            height: this.area.height,
            items: [this.content],
            disableDynamicRendering: true,
            disableEasing: true
        });
        this.addChild(this.scrollBox);
        this.area.destroy();
        this.updateScroll();
    }
    addItem(item) {
        this.scrollBox.addItem(item);
    }
    resize(w, h) {
        const oldScrollBox = this.scrollBox;
        this.scrollBox = new ScrollBox({
            type: 'vertical',
            width: w,
            height: h,
            items: [this.content],
            disableDynamicRendering: true,
            disableEasing: true
        });
        this.addChild(this.scrollBox);
        this.updateScroll();
        this.removeChild(oldScrollBox);
        oldScrollBox.destroy();
    }
    updateScroll() {
        this.scrollBox.resize();
        this.scrollBox.scrollTop();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/PaytableContent.ts



class PaytableContent extends ScrolledContent {
    constructor(le) {
        super(le, (le) => {
            let instance = null;
            switch (le.customClass) {
                case 'Button':
                    instance = new Button(le);
                    break;
                case 'TextSpriteCombined':
                    instance = new TextSpriteCombined(le, 10);
                    break;
            }
            return instance;
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/PaytablePanelMobile.ts








class PaytablePanelMobile extends Panel {
    constructor(configuration) {
        super(assets_AssetsManager.layouts.get('PaytablePanelMobile'));
        this.symbolCells = [];
        this.pages = [];
        // LayoutBuilder.create(this.layout, this, (le)=>{
        //     return this.customClassElementCreate(le);
        // });
        this.config = configuration;
        this.textFieldVerticalSpacing = dependency_container_instance.resolve(CommonTokenConstants.PAYTBALE_PANEL_MOBILE_TEXTFIELD_VERTICAL_SPACING);
        this.cellsSpacing = dependency_container_instance.resolve(CommonTokenConstants.PAYTABEL_PANEL_SYMBOL_CELL_SPACING).mobile;
        this.content = this.scrollBox['content'];
        for (let i = 1; this.content['page_' + i]; i++) {
            const p = this.content['page_' + i];
            this.removeChild(p);
            this.pages.push(p);
        }
        this.symbolsContainer = this.pages[0]['item_1'];
        this.createSymbols();
        this.scrollBox['area'].visible = false;
        this.symbolsContainer['area'].visible = false;
        const minMaxTf = this.pages[4]['tf6'];
        minMaxTf.text = minMaxTf.text
            .replace("<DYN_1>", configuration.minBet)
            .replace("<DYN_2>", configuration.maxBet);
        // scroll the scrollBox back
        this.on('removed', () => { this.scrollBox.updateScroll(); }, this);
        this.on('added', () => { this.scrollBox.updateScroll(); }, this);
        this.createSymbolsWithDescription();
    }
    createSymbolsWithDescription() {
        if (!this.config.symbolsWithDescription.length)
            return;
        this.config.symbolsWithDescription.forEach((desc) => {
            this.createSymbolInProperItem(desc.itemId, this.config.symbolsList.find((symbol) => symbol.id === desc.symbolId), desc.symbolDouble ? this.config.symbolsDoubles.find((symbol) => symbol.id === desc.symbolDouble) : null);
        });
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        const offsetBorder = 100;
        const defaultDesktopBackgroundWidth = 1260;
        if (desc.orientation == ScreenOrientation.VERTICAL) {
            //his.background.width = desc.currentWidth + offsetBorder;
            this.y = desc.baseHeight / 2 + (desc.currentHeight - desc.baseHeight) / 2;
        }
        else {
            //this.background.width = defaultDesktopBackgroundWidth;
            this.y = 0;
        }
        this.background.pivot.x = this.background.width / 2;
        // reposition paytable cells
        const scrollBoxOffset = this.scrollBox.x * 2;
        this.updateItemsGrid(this.symbolCells, desc.currentWidth - scrollBoxOffset - (desc.currentWidth - desc.baseWidth), this.cellsSpacing.x, this.cellsSpacing.y, 2);
        //this.symbolsContainer.pivot.x = this.symbolsContainer.width/2
        const spacing = this.textFieldVerticalSpacing;
        this.pages.forEach((page) => {
            for (let i = 0; i < page.children.length; i++) {
                if (i == 0)
                    page.children[i].position.y = this.btnClose.height / 2;
                else {
                    if (page.children[i].text !== '') // do not add spacing if the Text is empty
                        page.children[i].position.y = page.children[i - 1].position.y + page.children[i - 1].height + spacing;
                    else {
                        page.children[i].position.y = page.children[i - 1].position.y + page.children[i - 1].height;
                    }
                }
            }
        });
        this.updateItemsVertically(this.pages, 100);
        this.content['spacerBottom'].y = this.pages[this.pages.length - 1].y + this.pages[this.pages.length - 1].height + 100;
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'PaytableContent':
                instance = new PaytableContent(le);
                break;
            default:
                instance = super.customClassElementCreate(le);
        }
        return instance;
    }
    createSymbols() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        const symbolsCopy = [...this.config.symbolsList];
        const excludedSymbols = this.config.excludedSymbols;
        const symbolsToCreate = symbolsCopy.filter(symbol => !excludedSymbols.includes(symbol.id));
        const symbolsSorted = symbolsToCreate.sort((a, b) => {
            var _a, _b, _c, _d, _e, _f;
            return ((((_c = (_b = (_a = sm === null || sm === void 0 ? void 0 : sm.findRule(a.id, 5)) === null || _a === void 0 ? void 0 : _a.reward) === null || _b === void 0 ? void 0 : _b.line) === null || _c === void 0 ? void 0 : _c.multiplier) > ((_f = (_e = (_d = sm === null || sm === void 0 ? void 0 : sm.findRule(b.id, 5)) === null || _d === void 0 ? void 0 : _d.reward) === null || _e === void 0 ? void 0 : _e.line) === null || _f === void 0 ? void 0 : _f.multiplier)) && a.id) ? -1 : 1;
        });
        const symbolsDouble = this.config.symbolsDoubles ? [...this.config.symbolsDoubles] : [];
        let symbolsDoubleSorted;
        if (symbolsDouble.length) {
            const indexMap = new Map();
            sm.description.rules.forEach(rule => {
                symbolsSorted.forEach((value, index) => {
                    if (rule.pattern.symbolId == value.id)
                        indexMap.set(rule.symbolDoubled, index);
                });
            });
            symbolsDoubleSorted = sm.findDoubledSymbol(symbolsDouble, indexMap);
        }
        this.standardTextureSymbolSize = this.findStandardTexture(symbolsSorted);
        const symbolCellLayout = assets_AssetsManager.layouts.get('PaytableSymbolCellMobile');
        for (let i = 0; i < symbolsSorted.length; i++) {
            const symbolCell = new PaytableSymbolCell(symbolCellLayout, ScreenOrientation.VERTICAL, symbolsSorted[i], {
                setMultipliers: true,
                maxFontSize: 20,
                maxHeight: 60,
                maxWidth: 120,
                multiplierList: this.config.multiplierList,
            }, symbolsDoubleSorted ? symbolsDoubleSorted[i] : null, this.standardTextureSymbolSize, 10);
            this.symbolCells.push(symbolCell);
            this.symbolsContainer.addChild(symbolCell);
        }
    }
    createSymbolInProperItem(itemId, symbolData, symbolDataDouble = null) {
        if (!symbolData)
            return;
        const parent = this.pages[0][`item_${itemId}`];
        const symbolIcon = new PaytableSymbolCell(assets_AssetsManager.layouts.get('PaytableSymbolCellMobile'), ScreenOrientation.VERTICAL, symbolData, {
            setMultipliers: false,
            maxFontSize: 20,
            maxHeight: 60,
            maxWidth: 120,
        }, symbolDataDouble ? symbolDataDouble : null, this.standardTextureSymbolSize);
        if (parent['area']) {
            parent['area'].visible = false;
        }
        if (parent['multiplierDescription']) {
            symbolIcon.scatterMultiplier(symbolData.id, parent);
        }
        parent['iconSlot'].addChild(symbolIcon);
    }
}
PaytablePanelMobile.symbolDoubleOffset = 215;
/* harmony default export */ const ui_PaytablePanelMobile = (PaytablePanelMobile);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/tsyringe/PopupFactoryTokenConstants.ts
var PopupFactoryTokenConstants;
(function (PopupFactoryTokenConstants) {
    PopupFactoryTokenConstants["PAYTABLE_CONFIG"] = "paytableConfig";
    PopupFactoryTokenConstants["CELEBRATION_WIN_TEXT_HORIZONTAL"] = "celebrationWinTextHorizontal";
    PopupFactoryTokenConstants["CELEBRATION_WIN_TEXT_VERTICAL"] = "celebrationWinTextVertical";
    PopupFactoryTokenConstants["CONGRATULATION_FEATURE_TEXT_HORIZONTAL"] = "congratulationFeatureTextHorizontal";
    PopupFactoryTokenConstants["CONGRATULATION_FEATURE_TEXT_VERTICAL"] = "congratulationFeatureTextVertical";
    PopupFactoryTokenConstants["POPUP_TURBO_POSITION_Y_VERTICAL"] = "popupTurboPositionYVertical";
    PopupFactoryTokenConstants["POPUP_TURBO_POSITION_Y_HORIZONTAL"] = "popupTurboPositionYHorizontal";
    PopupFactoryTokenConstants["POPUP_FREESPIN_DESKTOP_SCALE"] = "popupFreespinDesktopScale";
    PopupFactoryTokenConstants["POPUP_BIG_WIN_CONFIG_0"] = "popupBigWinConfig0";
    PopupFactoryTokenConstants["POPUP_BIG_WIN_CONFIG_1"] = "popupBigWinConfig1";
    PopupFactoryTokenConstants["POPUP_BIG_WIN_CONFIG_2"] = "popupBigWinConfig2";
    PopupFactoryTokenConstants["POPUP_BIG_WIN_CONFIG_3"] = "popupBigWinConfig3";
    PopupFactoryTokenConstants["POPUP_CONGRATULATIONS_CONFIG"] = "popupCongratulationsConfig";
    PopupFactoryTokenConstants["POPUP_FREESPINS_CONFIG"] = "popupFreespinsConfig";
    PopupFactoryTokenConstants["POPUP_HOLD_AND_SPINNER_CONFIG"] = "popupHoldAndSpinnerConfig";
    PopupFactoryTokenConstants["POPUP_EXTRA_FREESPIN_CONFIG"] = "popupExtraFreespinsConfig";
    PopupFactoryTokenConstants["EXTRA_FREESPINS_TEXT_HORIZONTAL"] = "extraFreespinsTextHorizontal";
    PopupFactoryTokenConstants["EXTRA_FREESPINS_TEXT_VERTICAL"] = "extraFreespinsTextVertical";
})(PopupFactoryTokenConstants || (PopupFactoryTokenConstants = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupCongratulations.ts









class PopupCongratulations extends Container_Container {
    constructor(config, winValue) {
        super();
        this.config = config;
        const layout = assets_AssetsManager.layouts.has('PopupCelebration')
            ? assets_AssetsManager.layouts.get('PopupCelebration')
            : assets_AssetsManager.layouts.get('PopupFreespins');
        LayoutBuilder.create(layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        if (this.config.scale)
            this.animation.scale.set(this.config.scale);
        this.winValue = winValue;
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
        this.winValue = (winValue instanceof Function ? winValue : () => winValue);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        if (le.customClass.endsWith('Animation')) {
            const asset = assets_AssetsManager.spine.get(this.config.assetName);
            instance = new Spine(asset);
        }
        return instance;
    }
    // PUBLIC API
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        const wallet = dependency_container_instance.resolve(model_Wallet);
        this.tfAmount.text = wallet.getCurrencyValue(value, true);
    }
    onAdded() {
        this.removeChild(this.animation);
        this.addChild(this.animation);
        const index = this.animation.skeleton.findSlotIndex('placeholder');
        const slot = this.animation.skeleton.slots[index];
        const counterContainer = this.animation.slotContainers[index];
        counterContainer.removeChildren();
        counterContainer.addChild(this.tfAmount);
        slot.bone.scaleX = 0.3;
        slot.bone.scaleY = -0.3;
        const countUpDuration = 4;
        const { start, loop, end } = this.config.animationsSelector();
        this.animation.state.addListener({
            start: (entry) => {
                if (entry.animation.name == start) {
                    slot.color.a = 0;
                    ignitionTween.Tweener.addTween(slot.color, {
                        a: 1,
                        time: 0.3,
                        transition: 'easeOutQuad',
                        delay: 0.3,
                    });
                    ignitionTween.Tweener.addTween(slot.bone, {
                        scaleX: 1,
                        scaleY: -1,
                        time: countUpDuration / 8,
                        transition: 'easeOutBack',
                        delay: 0.3,
                    });
                }
                else if (entry.animation.name == end) {
                    ignitionTween.Tweener.addTween(slot.color, {
                        a: 0,
                        time: 0.5,
                        transition: 'easeInQuad',
                    });
                }
            },
        });
        this.value = 0;
        ignitionTween.Tweener.addTween(this, {
            value: this.winValue instanceof Function ? this.winValue() : this.winValue,
            time: countUpDuration,
            transition: 'easeInOutQuad',
            onStart: () => {
                this.loopedSound = sound_SoundManager.loop({
                    id: sound_SoundList.COUNTER_LOOP,
                    volume: 0.25,
                });
            },
            onComplete: () => {
                this.loopedSound.stop();
                sound_SoundManager.play({
                    id: sound_SoundList.COUNTER_END,
                    volume: 0.4,
                });
            },
        });
        const numLoopAnimations = 5;
        this.animation.state.data.setMix(start, loop, 0.7);
        this.animation.state.setAnimation(0, start, false);
        for (let i = 0; i < numLoopAnimations; i++) {
            this.animation.state.addAnimation(0, loop, true, 0);
        }
        this.animation.state.addAnimation(0, end, false, 0);
    }
    onRemoved() {
        if (this.loopedSound)
            this.loopedSound.stop();
        ignitionTween.Tweener.removeTweens(this);
        this.animation.state.setEmptyAnimations(0);
        this.animation.state.clearListeners();
        this.animation['lastTime'] = null;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupFreespins.ts











class PopupFreespins extends Container_Container {
    constructor(config, amount) {
        var _a, _b;
        super();
        this.config = config;
        LayoutBuilder.create(assets_AssetsManager.layouts.get('PopupFreespins'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.tfAmount.text = (amount instanceof Function ? amount() : amount).toString();
        this.winValue = (amount instanceof Function ? amount() : amount);
        const index = this.animation.skeleton.findSlotIndex((_b = (_a = this.config.slotOverrides) === null || _a === void 0 ? void 0 : _a[0].name) !== null && _b !== void 0 ? _b : 'spins_count');
        if (index !== -1) {
            const counterContainer = this.animation.slotContainers[index];
            this.freespinCountSlot = this.animation.skeleton.slots[index];
            counterContainer.removeChildren();
            if (this.freespinCountSlot) {
                // this.tfAmount.scale.y = -this.tfAmount.scale.y;
                counterContainer.addChild(this.tfAmount);
            }
        }
        if (this.config.scale)
            this.animation.scale.set(this.config.scale);
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'FreespinsAnimation':
                const asset = assets_AssetsManager.spine.get(this.config.assetName);
                instance = new Spine(asset);
                break;
        }
        return instance;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        const wallet = dependency_container_instance.resolve(model_Wallet);
        this.tfCounter.text = wallet.getCurrencyValue(value, false);
    }
    onAdded() {
        const numLoopAnimations = 5;
        this.tfAmount.text = dependency_container_instance.resolve(SlotMachine).currentSpinResult.freespins.totalCount;
        this.animation.state.setEmptyAnimations(0);
        const countUpDuration = 4;
        const { start, loop, end } = this.config.animationsSelector();
        this.animation.state.addListener({
            start: (entry) => {
                if (entry.animation.name == start) {
                    if (this.freespinCountSlot) {
                        this.freespinCountSlot.color.a = 0;
                        ignitionTween.Tweener.addTween(this.freespinCountSlot.color, {
                            a: 1,
                            time: 0.3,
                            transition: 'easeOutQuad',
                            delay: 0.3
                        });
                        this.freespinCountSlot.bone.scaleX = 0.3;
                        this.freespinCountSlot.bone.scaleY = -0.3;
                        ignitionTween.Tweener.addTween(this.freespinCountSlot.bone, {
                            scaleX: 1,
                            scaleY: -1,
                            time: countUpDuration / 8,
                            transition: 'easeOutBack',
                            delay: 0.3
                        });
                    }
                }
                else if (entry.animation.name == end) {
                    if (this.freespinCountSlot) {
                        ignitionTween.Tweener.addTween(this.freespinCountSlot.color, {
                            a: 0,
                            time: 0.5,
                            transition: 'easeInQuad',
                        });
                    }
                }
            }
        });
        this.animation.state.data.setMix(start, loop, 0.7);
        this.animation.state.setAnimation(0, start, false);
        for (let i = 0; i < numLoopAnimations; i++) {
            this.animation.state.addAnimation(0, loop, false, 0);
        }
        this.animation.state.addAnimation(0, end, false, 0);
        if (dependency_container_instance.resolve(SlotMachine).currentState === SlotMachineState.FREE_SPINS_ROUND_START) {
            return;
        }
        this.value = 0;
        ignitionTween.Tweener.addTween(this, {
            value: this.winValue,
            time: countUpDuration,
            transition: 'easeInOutQuad',
            onStart: () => {
                this.loopedSound = sound_SoundManager.loop({
                    id: sound_SoundList.COUNTER_LOOP,
                    volume: 0.25
                });
            },
            onComplete: () => {
                this.loopedSound.stop();
                sound_SoundManager.play({
                    id: sound_SoundList.COUNTER_END,
                    volume: 0.4
                });
            }
        });
    }
    onRemoved() {
        if (this.loopedSound)
            this.loopedSound.stop();
        ignitionTween.Tweener.removeTweens(this);
        if (this.freespinCountSlot) {
            ignitionTween.Tweener.removeTweens(this.freespinCountSlot.color);
            ignitionTween.Tweener.removeTweens(this.freespinCountSlot.bone);
        }
        this.animation.state.setEmptyAnimations(0);
        this.animation.state.clearListeners();
        this.animation['lastTime'] = null;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupHoldAndSpinner.ts




class PopupHoldAndSpinner extends Container_Container {
    constructor(config) {
        super();
        this.config = config;
        const asset = assets_AssetsManager.spine.get(this.config.assetName);
        this.animation = new Spine(asset);
        if (this.config.scale)
            this.animation.scale.set(this.config.scale);
        this.on('removed', this.onRemoved, this);
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        this.removeChild(this.animation);
        this.addChild(this.animation);
        const numLoopAnimations = 5;
        const { start, loop, end } = this.config.animationsSelector();
        this.animation.state.data.setMix(start, loop, 0.7);
        this.animation.state.setAnimation(0, start, false);
        for (let i = 0; i < numLoopAnimations; i++) {
            this.animation.state.addAnimation(0, loop, true, 0);
        }
        this.animation.state.addAnimation(0, end, false, 0);
    }
    onRemoved() {
        ignitionTween.Tweener.removeTweens(this);
        this.animation.state.setEmptyAnimations(0);
        this.animation.state.clearListeners();
        this.animation['lastTime'] = null;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/PopupTurboActivate.ts








class PopupTurboActivate extends Container_Container {
    constructor(posY) {
        super();
        LayoutBuilder.create(assets_AssetsManager.layouts.get('TurboPopup'), this);
        this.normal = this['icon'].normal;
        this.turbo = this['icon'].turbo;
        this.superTurbo = this['icon'].superTurbo;
        const slotMachine = dependency_container_instance.resolve(SlotMachine);
        slotMachine.on(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedChanged, this);
        this.onGameSpeedChanged(slotMachine.currentGameSpeedLevel);
        this.position.y = posY;
    }
    onGameSpeedChanged(level) {
        this.normal.visible = level === 0;
        this.turbo.visible = level === 1;
        this.superTurbo.visible = level === 2;
        if (this.normal.visible) {
            this.title.text = translations_Translation.t('turboPopup.normal');
        }
        if (this.turbo.visible) {
            this.title.text = translations_Translation.t('turboPopup.turbo');
        }
        if (this.superTurbo.visible) {
            this.title.text = translations_Translation.t('turboPopup.superTurbo');
        }
        autoscaleText(this.title, 30, 290, 70);
    }
}
PopupTurboActivate.turboPopupAnimationConfiguration = {
    showPopup: {
        scale: {
            value: 1,
            time: 0.3,
            transition: 'easeOutBack',
        },
        alpha: {
            value: 1,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
        scale: {
            value: 0,
            time: 0.3,
            transition: 'easeInBack',
        },
    },
};
/* harmony default export */ const popup_PopupTurboActivate = (PopupTurboActivate);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/popup/SpinePopup.ts





class SpinePopup extends Container_Container {
    constructor(config) {
        super();
        this.loopedSounds = [];
        this.config = config;
        // get all the assets from config
        const asset = assets_AssetsManager.spine.get(this.config.assetName);
        // add spines to array
        this.spine = new Spine(asset);
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
    }
    onAdded() {
        var _a;
        this.addChild(this.spine);
        // get the animations and duration
        const { start, loop, end } = this.config.animationsSelector();
        const loopAnimationCount = (_a = this.config.loopAnimationCount) !== null && _a !== void 0 ? _a : 4;
        // duration of value counting up
        const countUpDuration = 4;
        const appearTime = 0.3;
        const disappearTime = 0.5;
        this.spine.state.setEmptyAnimations(0);
        this.config.slotOverrides.forEach(override => {
            var _a, _b;
            const text = override.textProvider();
            text.anchor.set(0.5);
            const index = this.spine.skeleton.findSlotIndex((_a = override.name) !== null && _a !== void 0 ? _a : 'placeholder');
            const slot = this.spine.skeleton.slots[index];
            if (index !== -1) {
                text.scale.y = -text.scale.y;
                const counterContainer = this.spine.slotContainers[index];
                counterContainer.removeChildren();
                counterContainer.addChild(text);
            }
            else {
                this.addChildAt(text, this.children.length);
            }
            const renderer = (_b = override.valueRenderer) !== null && _b !== void 0 ? _b : ((value) => value.toString());
            if (override.type === 'animated') {
                this.spine.state.addListener({
                    start: (entry) => {
                        // on start animation make slot or only Text appear
                        if (entry.animation.name == start) {
                            if (slot) {
                                slot.color.a = 0;
                                ignitionTween.Tweener.addTween(slot.color, {
                                    a: 1,
                                    time: appearTime,
                                    transition: 'easeOutQuad',
                                    delay: appearTime,
                                });
                                slot.bone.scaleX = slot.bone.scaleY = 0.1;
                                ignitionTween.Tweener.addTween(slot.bone, {
                                    scaleX: 1,
                                    scaleY: 1,
                                    time: appearTime,
                                    transition: 'easeOutBack',
                                    delay: appearTime,
                                });
                            }
                            else if (text) {
                                text.alpha = 0;
                                ignitionTween.Tweener.addTween(text, {
                                    alpha: 1,
                                    time: appearTime,
                                    transition: 'easeOutQuad',
                                });
                            }
                            // on end animation make slot or Text disappear
                        }
                        else if (entry.animation.name == end) {
                            if (slot) {
                                ignitionTween.Tweener.addTween(slot.color, {
                                    a: 0,
                                    time: disappearTime,
                                    transition: 'easeOutQuad',
                                });
                            }
                            else if (text) {
                                ignitionTween.Tweener.addTween(text, {
                                    alpha: 0,
                                    time: disappearTime,
                                    transition: 'easeOutQuad',
                                });
                            }
                        }
                    }
                });
                // do count up animation of win value
                text['__SpinePopupValue__'] = 0;
                text.text = renderer(text['__SpinePopupValue__']);
                ignitionTween.Tweener.addTween(text, {
                    __SpinePopupValue__: override.valueProvider(),
                    time: countUpDuration,
                    transition: 'easeInOutQuad',
                    onUpdate: () => {
                        text.text = renderer(text['__SpinePopupValue__']);
                    },
                    onStart: () => {
                        if (override.soundLoopProvider) {
                            this.loopedSounds.push(sound_SoundManager.loop(override.soundLoopProvider()));
                        }
                    },
                    onComplete: () => {
                        var _a;
                        (_a = this.loopedSounds) === null || _a === void 0 ? void 0 : _a.forEach(sound => sound.stop());
                        if (override.soundEndProvider) {
                            sound_SoundManager.play(override.soundEndProvider());
                        }
                    },
                });
            }
            else {
                // if there is no count up then just set the win to provided value
                text.text = renderer(override.valueProvider());
            }
        });
        // play animations in correct order
        this.spine.state.data.setMix(start, loop, 0.7);
        this.spine.state.setAnimation(0, start, false);
        for (let i = 0; i < loopAnimationCount; i++) {
            this.spine.state.addAnimation(0, loop, false, 0);
        }
        this.spine.state.addAnimation(0, end, false, 0);
    }
    onRemoved() {
        this.loopedSounds.forEach(sound => sound.stop());
        this.loopedSounds.length = 0;
        ignitionTween.Tweener.removeTweens(this);
        this.config.slotOverrides.forEach(override => {
            var _a;
            const slot = this.spine.skeleton.findSlot((_a = override.name) !== null && _a !== void 0 ? _a : 'placeholder');
            if (slot) {
                ignitionTween.Tweener.removeTweens(slot.bone);
                ignitionTween.Tweener.removeTweens(slot.color);
                slot.setToSetupPose();
            }
        });
        this.spine.state.setEmptyAnimations(0);
        this.spine.state.clearListeners();
        this.spine['lastTime'] = null;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/SwitchModule.ts



class SwitchModule extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'SwitchView':
                instance = new SwitchView(le);
                break;
        }
        return instance;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/AdjustSettings.ts









class AdjustSettings extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.gs = dependency_container_instance.resolve(services_GameService);
        this.gs.on(GameServiceEvent_GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateView();
        }, this);
        this.switch_module_1['Selection'].on(SwitchEvent.STATE_CHANGED, this.changeBattery, this);
        this.switch_module_2['Selection'].on(SwitchEvent.STATE_CHANGED, this.changeQuickSpin, this);
        this.switch_module_3['Selection'].on(SwitchEvent.STATE_CHANGED, this.changeSounds, this);
        this.switch_module_4['Selection'].on(SwitchEvent.STATE_CHANGED, this.changeIntroScreen, this);
        this.updateView();
        this.switch_module_5['Selection'].destroy();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'SwitchModule':
                instance = new SwitchModule(le);
                instance.alpha = le.alpha;
                break;
        }
        return instance;
    }
    updateView() {
        this.switch_module_1['Selection'].setInitialState(this.gs.settings.batterySaver ? SwitchState.ON : SwitchState.OFF);
        this.switch_module_2['Selection'].setInitialState(this.gs.settings.quickSpin ? SwitchState.ON : SwitchState.OFF);
        this.switch_module_3['Selection'].setInitialState(this.gs.settings.soundFx ? SwitchState.ON : SwitchState.OFF);
        this.switch_module_4['Selection'].setInitialState(this.gs.settings.skipScreen ? SwitchState.ON : SwitchState.OFF);
    }
    changeQuickSpin() {
        this.gs.settings.quickSpin = this.gs.settings.quickSpin == 0 ? 1 : 0;
        this.gs.saveSettings();
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentGameSpeedLevel = sm.currentGameSpeedLevel == 0 ? 1 : 0;
    }
    changeBattery() {
        this.gs.settings.batterySaver = !this.gs.settings.batterySaver;
        this.gs.saveSettings();
    }
    changeAmbient() {
    }
    changeSounds() {
        this.gs.settings.soundFx = !this.gs.settings.soundFx;
        this.gs.saveSettings();
        sound_SoundManager.getChannel('default').mute = !this.gs.settings.soundFx;
        sound_SoundManager.getChannel('ambient').mute = !this.gs.settings.soundFx;
    }
    changeIntroScreen() {
        this.gs.settings.skipScreen = !this.gs.settings.skipScreen;
        this.gs.saveSettings();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/SystemSettingsPanel.ts



class SystemSettingsPanel extends Panel {
    constructor(le) {
        super(le);
        //this.fetchTranslationFile()
        this.once('added', () => {
            this.adjustSettings.updateView();
        }, this);
    }
    customClassElementCreate(le) {
        let instance;
        switch (le.customClass) {
            case 'AdjustSettings':
                instance = new AdjustSettings(le);
                break;
            default:
                instance = super.customClassElementCreate(le);
        }
        return instance;
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        if (desc.orientation === ScreenOrientation.HORIZONTAL) {
            this.scale.set(1);
        }
        else {
            this.scale.set(2);
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/factories/PopupFactory.ts


















var PopupFactoryType;
(function (PopupFactoryType) {
    PopupFactoryType["BIG_WIN_HORIZONTAL"] = "bigWinHorizontal";
    PopupFactoryType["BIG_WIN_FREESPIN_HORIZONTAL"] = "bigWinFreeSpinHorizontal";
    PopupFactoryType["BIG_WIN_FREESPIN_VERTICAL"] = "bigWinFreeSpinVertical";
    PopupFactoryType["BIG_WIN_VERTICAL"] = "bigWinVertical";
    PopupFactoryType["HISTORY_VERTICAL"] = "historyVertical";
    PopupFactoryType["HISTORY_HORIZONTAL"] = "historyHorizontal";
    PopupFactoryType["AUTOSPIN_SETTINGS_HORIZONTAL"] = "autospinSettingsHorizontal";
    PopupFactoryType["AUTOSPIN_SETTINGS_VERTICAL"] = "autospinSettingsVertical";
    PopupFactoryType["ADJUST_BET_HORIZONTAL"] = "adjustBetHorizontal";
    PopupFactoryType["ADJUST_BET_VERTICAL"] = "adjustBetVertical";
    PopupFactoryType["PAYTABLE_HORIZONTAL"] = "paytableHorizontal";
    PopupFactoryType["PAYTABLE_VERTICAL"] = "paytableVertical";
    PopupFactoryType["MENU_SETTINGS_VERTICAL"] = "systemSettingsVertical";
    PopupFactoryType["MENU_SETTINGS_HORIZONTAL"] = "systemSettingsHorizontal";
    PopupFactoryType["BALANCE_HORIZONTAL"] = "balanceHorizontal";
    PopupFactoryType["BALANCE_VERTICAL"] = "balanceVertical";
    PopupFactoryType["CONNECTION_LOST_HORIZONTAL"] = "connectionLostHorizontal";
    PopupFactoryType["CONNECTION_LOST_VERTICAL"] = "connectionLostVertical";
    PopupFactoryType["FREESPIN_BUY_HORIZONTAL"] = "freespinBuyHorizontal";
    PopupFactoryType["FREESPIN_BUY_VERTICAL"] = "freespinBuyVertical";
    PopupFactoryType["HOLD_AND_SPINNER_BUY_HORIZONTAL"] = "holdAndSpinnerBuyHorizontal";
    PopupFactoryType["HOLD_AND_SPINNER_BUY_VERTICAL"] = "holdAndSpinnerBuyVertical";
    PopupFactoryType["FREESPIN_POPUP_HORIZONTAL"] = "freespinPopupHorizontal";
    PopupFactoryType["FREESPIN_POPUP_VERTICAL"] = "freespinPopupVertical";
    PopupFactoryType["CONGRATULATIONS_POPUP_HORIZONTAL"] = "congratulationsHorizontal";
    PopupFactoryType["CONGRATULATIONS_POPUP_VERTICAL"] = "congratulationsVertical";
    PopupFactoryType["EXTRA_FREESPIN_POPUP_HORIZONTAL"] = "extraFreespinPopupHorizontal";
    PopupFactoryType["EXTRA_FREESPIN_POPUP_VERTICAL"] = "extraFreespinPopupVertical";
    PopupFactoryType["HOLD_SPINNER_POPUP_HORIZONTAL"] = "holdSpinnerPopupHorizontal";
    PopupFactoryType["HOLD_SPINNER_POPUP_VERTICAL"] = "holdSpinnerPopupVertical";
    PopupFactoryType["TURBO_ACTIVATE_HORIZONTAL"] = "turboActivateHorizontal";
    PopupFactoryType["TURBO_ACTIVATE_VERTICAL"] = "turboActivateVertical";
})(PopupFactoryType || (PopupFactoryType = {}));
class PopupFactory {
    constructor() { throw new Error(`${this.constructor.name} is a static class`); }
    static retrieveTemplate(popupType, provider, updateLayoutDescription) {
        var _a;
        let popup = this.popups.get(popupType);
        if (!popup) {
            popup = provider();
            this.popups.set(popupType, popup);
        }
        if (updateLayoutDescription) {
            (_a = popup['updateLayout']) === null || _a === void 0 ? void 0 : _a.call(popup, updateLayoutDescription);
        }
        return popup;
    }
    static retrieveBigWinHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(`${PopupFactoryType.BIG_WIN_HORIZONTAL}${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`, () => new SpinePopup(this[`popupBigWinConfig${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`]), updateLayoutDescription);
    }
    static retrieveBigWinVertical(updateLayoutDescription) {
        return this.retrieveTemplate(`${PopupFactoryType.BIG_WIN_VERTICAL}${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`, () => new SpinePopup(this[`popupBigWinConfig${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`]), updateLayoutDescription);
    }
    static retrieveBigWinFreeSpinHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(`${PopupFactoryType.BIG_WIN_FREESPIN_HORIZONTAL}${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`, () => new SpinePopup(this[`popupBigWinConfig${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`]), updateLayoutDescription);
    }
    static retrieveBigWinFreeSpinVertical(updateLayoutDescription) {
        return this.retrieveTemplate(`${PopupFactoryType.BIG_WIN_FREESPIN_VERTICAL}${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`, () => new SpinePopup(this[`popupBigWinConfig${this.slotMachine.bigWinLevel(this.slotMachine.roundResult)}`]), updateLayoutDescription);
    }
    static retrieveCongratulationPopupHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.CONGRATULATIONS_POPUP_HORIZONTAL, () => new PopupCongratulations(this.popupCongratulationsConfig, () => this.slotMachine.roundResult.totalWinValue), updateLayoutDescription);
    }
    static retrieveCongratulationPopupVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.CONGRATULATIONS_POPUP_VERTICAL, () => new PopupCongratulations(this.popupCongratulationsConfig, () => this.slotMachine.roundResult.totalWinValue), updateLayoutDescription);
    }
    static retrieveExtraFreespinPopupHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.EXTRA_FREESPIN_POPUP_HORIZONTAL, () => new SpinePopup(this.popupExtraFreespinConfig), updateLayoutDescription);
    }
    static retrieveExtraFreespinPopupVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.EXTRA_FREESPIN_POPUP_VERTICAL, () => new SpinePopup(this.popupExtraFreespinConfig), updateLayoutDescription);
    }
    static retrieveFreespinPopupHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.FREESPIN_POPUP_HORIZONTAL, () => new PopupFreespins(this.popupFreespinsConfig, () => this.slotMachine.currentSpinResult.freespins.totalCount), updateLayoutDescription);
    }
    static retrieveFreespinPopupVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.FREESPIN_POPUP_VERTICAL, () => new PopupFreespins(this.popupFreespinsConfig, () => this.slotMachine.currentSpinResult.freespins.totalCount), updateLayoutDescription);
    }
    static retrieveHoldAndSpinnerPopupHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.HOLD_SPINNER_POPUP_HORIZONTAL, () => new PopupHoldAndSpinner(this.popupHoldAndSpinnerConfig), updateLayoutDescription);
    }
    static retrieveHoldAndSpinnerPopupVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.HOLD_SPINNER_POPUP_VERTICAL, () => new PopupHoldAndSpinner(this.popupHoldAndSpinnerConfig), updateLayoutDescription);
    }
    static retrieveTurboActivatePopupHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.TURBO_ACTIVATE_HORIZONTAL, () => new popup_PopupTurboActivate(this.popupTurboPosYHorizontal), updateLayoutDescription);
    }
    static retrieveTurboActivatePopupVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.TURBO_ACTIVATE_VERTICAL, () => new popup_PopupTurboActivate(this.popupTurboPosYVertical), updateLayoutDescription);
    }
    static retrieveAutospinSettingsHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.AUTOSPIN_SETTINGS_HORIZONTAL, () => new AutospinPanel(assets_AssetsManager.layouts.get('AutospinPanelDesktop')), updateLayoutDescription);
    }
    static retrieveAutospinSettingsVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.AUTOSPIN_SETTINGS_VERTICAL, () => new AutospinPanel(assets_AssetsManager.layouts.get('AutospinPanelMobile')), updateLayoutDescription);
    }
    static retrieveAdjustBetHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.ADJUST_BET_HORIZONTAL, () => new AdjustBetPanel(assets_AssetsManager.layouts.get('AdjustBetPanel')), updateLayoutDescription);
    }
    static retrieveAdjustBetVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.ADJUST_BET_VERTICAL, () => new AdjustBetPanel(assets_AssetsManager.layouts.get('AdjustBetPanelMobile')), updateLayoutDescription);
    }
    static retrieveSystemSettingsHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.MENU_SETTINGS_HORIZONTAL, () => new SystemSettingsPanel(assets_AssetsManager.layouts.get('MenuSettingsPanel')), updateLayoutDescription);
    }
    static retrieveSystemSettingsVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.MENU_SETTINGS_VERTICAL, () => new SystemSettingsPanel(assets_AssetsManager.layouts.get('MenuSettingsPanelMobile')), updateLayoutDescription);
    }
    static retrievePaytableHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.PAYTABLE_HORIZONTAL, () => new PaytablePanelDesktop(this.paytableConfig), updateLayoutDescription);
    }
    static retrievePaytableVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.PAYTABLE_VERTICAL, () => new ui_PaytablePanelMobile(this.paytableConfig), updateLayoutDescription);
    }
    static retrieveBalanceHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.BALANCE_HORIZONTAL, () => new PopupNotEnoughBalance(), updateLayoutDescription);
    }
    static retrieveBalanceVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.BALANCE_VERTICAL, () => new PopupNotEnoughBalance(), updateLayoutDescription);
    }
    static retrieveConnectionLostHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.CONNECTION_LOST_HORIZONTAL, () => new PopupConnectionLost(), updateLayoutDescription);
    }
    static retrieveConnectionLostVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.CONNECTION_LOST_VERTICAL, () => new PopupConnectionLost(), updateLayoutDescription);
    }
    static retrieveFreespinBuyHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.FREESPIN_BUY_HORIZONTAL, () => new PopupFeatureBuy(FeatureTypes.FREESPIN), updateLayoutDescription);
    }
    static retrieveFreespinBuyVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.FREESPIN_BUY_VERTICAL, () => new PopupFeatureBuy(FeatureTypes.FREESPIN), updateLayoutDescription);
    }
    static retrieveHoldAndSpinnerBuyHorizontal(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.HOLD_AND_SPINNER_BUY_HORIZONTAL, () => new PopupFeatureBuy(FeatureTypes.HOLD_AND_SPINNER), updateLayoutDescription);
    }
    static retrieveHoldAndSpinnerBuyVertical(updateLayoutDescription) {
        return this.retrieveTemplate(PopupFactoryType.HOLD_AND_SPINNER_BUY_VERTICAL, () => new PopupFeatureBuy(FeatureTypes.HOLD_AND_SPINNER), updateLayoutDescription);
    }
    static retrieve(popupType, updateLayoutDescription) {
        switch (popupType) {
            case PopupFactoryType.BIG_WIN_HORIZONTAL:
                return PopupFactory.retrieveBigWinHorizontal(updateLayoutDescription);
            case PopupFactoryType.BIG_WIN_VERTICAL:
                return PopupFactory.retrieveBigWinVertical(updateLayoutDescription);
            case PopupFactoryType.BIG_WIN_FREESPIN_HORIZONTAL:
                return PopupFactory.retrieveBigWinFreeSpinHorizontal(updateLayoutDescription);
            case PopupFactoryType.BIG_WIN_FREESPIN_VERTICAL:
                return PopupFactory.retrieveBigWinFreeSpinVertical(updateLayoutDescription);
            case PopupFactoryType.HISTORY_HORIZONTAL:
            case PopupFactoryType.HISTORY_VERTICAL:
            case PopupFactoryType.AUTOSPIN_SETTINGS_HORIZONTAL:
                return PopupFactory.retrieveAutospinSettingsHorizontal(updateLayoutDescription);
            case PopupFactoryType.AUTOSPIN_SETTINGS_VERTICAL:
                return PopupFactory.retrieveAutospinSettingsVertical(updateLayoutDescription);
            case PopupFactoryType.ADJUST_BET_HORIZONTAL:
                return PopupFactory.retrieveAdjustBetHorizontal(updateLayoutDescription);
            case PopupFactoryType.ADJUST_BET_VERTICAL:
                return PopupFactory.retrieveAdjustBetVertical(updateLayoutDescription);
            case PopupFactoryType.PAYTABLE_HORIZONTAL:
                return PopupFactory.retrievePaytableHorizontal(updateLayoutDescription);
            case PopupFactoryType.PAYTABLE_VERTICAL:
                return PopupFactory.retrievePaytableVertical(updateLayoutDescription);
            case PopupFactoryType.MENU_SETTINGS_VERTICAL:
                return PopupFactory.retrieveSystemSettingsVertical(updateLayoutDescription);
            case PopupFactoryType.MENU_SETTINGS_HORIZONTAL:
                return PopupFactory.retrieveSystemSettingsHorizontal(updateLayoutDescription);
            case PopupFactoryType.BALANCE_HORIZONTAL:
                return PopupFactory.retrieveBalanceHorizontal(updateLayoutDescription);
            case PopupFactoryType.BALANCE_VERTICAL:
                return PopupFactory.retrieveBalanceVertical(updateLayoutDescription);
            case PopupFactoryType.CONNECTION_LOST_HORIZONTAL:
                return PopupFactory.retrieveConnectionLostHorizontal(updateLayoutDescription);
            case PopupFactoryType.CONNECTION_LOST_VERTICAL:
                return PopupFactory.retrieveConnectionLostVertical(updateLayoutDescription);
            case PopupFactoryType.FREESPIN_BUY_HORIZONTAL:
                return PopupFactory.retrieveFreespinBuyHorizontal(updateLayoutDescription);
            case PopupFactoryType.FREESPIN_BUY_VERTICAL:
                return PopupFactory.retrieveFreespinBuyVertical(updateLayoutDescription);
            case PopupFactoryType.HOLD_AND_SPINNER_BUY_HORIZONTAL:
                return PopupFactory.retrieveHoldAndSpinnerBuyHorizontal(updateLayoutDescription);
            case PopupFactoryType.HOLD_AND_SPINNER_BUY_VERTICAL:
                return PopupFactory.retrieveHoldAndSpinnerBuyVertical(updateLayoutDescription);
            case PopupFactoryType.FREESPIN_POPUP_HORIZONTAL:
                return PopupFactory.retrieveFreespinPopupHorizontal(updateLayoutDescription);
            case PopupFactoryType.FREESPIN_POPUP_VERTICAL:
                return PopupFactory.retrieveFreespinPopupVertical(updateLayoutDescription);
            case PopupFactoryType.EXTRA_FREESPIN_POPUP_HORIZONTAL:
                return PopupFactory.retrieveExtraFreespinPopupHorizontal(updateLayoutDescription);
            case PopupFactoryType.EXTRA_FREESPIN_POPUP_VERTICAL:
                return PopupFactory.retrieveExtraFreespinPopupVertical(updateLayoutDescription);
            case PopupFactoryType.CONGRATULATIONS_POPUP_HORIZONTAL:
                return PopupFactory.retrieveCongratulationPopupHorizontal(updateLayoutDescription);
            case PopupFactoryType.CONGRATULATIONS_POPUP_VERTICAL:
                return PopupFactory.retrieveCongratulationPopupVertical(updateLayoutDescription);
            case PopupFactoryType.HOLD_SPINNER_POPUP_HORIZONTAL:
                return PopupFactory.retrieveHoldAndSpinnerPopupHorizontal(updateLayoutDescription);
            case PopupFactoryType.HOLD_SPINNER_POPUP_VERTICAL:
                return PopupFactory.retrieveHoldAndSpinnerPopupVertical(updateLayoutDescription);
            case PopupFactoryType.TURBO_ACTIVATE_HORIZONTAL:
                return PopupFactory.retrieveTurboActivatePopupHorizontal(updateLayoutDescription);
            case PopupFactoryType.TURBO_ACTIVATE_VERTICAL:
                return PopupFactory.retrieveTurboActivatePopupVertical(updateLayoutDescription);
            default:
                throw new Error(`${this.constructor.name} does not know how to handle the '${popupType}'`);
        }
    }
    static initialize() {
        if (this.initialized) {
            throw new Error(`${this.constructor.name} has been already initialized`);
        }
        this.popups = new Map();
        this.popupTurboPosYVertical = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_TURBO_POSITION_Y_VERTICAL);
        this.popupTurboPosYHorizontal = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_TURBO_POSITION_Y_HORIZONTAL);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.paytableConfig = dependency_container_instance.resolve(PopupFactoryTokenConstants.PAYTABLE_CONFIG);
        this.popupBigWinConfig0 = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_0);
        this.popupBigWinConfig1 = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_1);
        this.popupBigWinConfig2 = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_2);
        this.popupBigWinConfig3 = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_3);
        this.popupFreespinsConfig = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_FREESPINS_CONFIG);
        this.popupHoldAndSpinnerConfig = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_HOLD_AND_SPINNER_CONFIG);
        this.popupCongratulationsConfig = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_CONGRATULATIONS_CONFIG);
        this.popupExtraFreespinConfig = dependency_container_instance.resolve(PopupFactoryTokenConstants.POPUP_EXTRA_FREESPIN_CONFIG);
    }
}
PopupFactory.initialized = false;

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/AutospinSettings.ts
class AutospinSettings {
    constructor() {
        this.skipScreens = false;
        this.turboSpin = false;
        this.limitlessAutoSpin = false;
        this.sliderAmount = 0;
    }
}

;// CONCATENATED MODULE: ./src/the-miner/config/popups/PopupBigWinConfig.ts





const BigWinConfiguration = {
    assetName: `big_win`,
    animationsSelector: () => ({
        start: 'in',
        loop: 'loop',
        end: 'out'
    }),
    slotOverrides: [
        {
            type: "animated",
            name: "counter",
            textProvider: () => dependency_container_instance.resolve(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL),
            valueProvider: () => {
                var _a;
                const slotMachine = dependency_container_instance.resolve(SlotMachine);
                return ((_a = slotMachine.currentSpinResult.freespins) === null || _a === void 0 ? void 0 : _a.remainingCount)
                    ? slotMachine.roundResult.actualSpinWinValue
                    : slotMachine.roundResult.totalWinValue;
            },
            valueRenderer: (value) => dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true),
            soundLoopProvider: () => ({
                id: sound_SoundList.COUNTER_LOOP,
                volume: 0.25
            }),
            soundEndProvider: () => ({
                id: sound_SoundList.COUNTER_END,
                volume: 0.4
            }),
        }
    ],
    loopAnimationCount: 10,
};
const MegaWinConfiguration = {
    assetName: `mega_win`,
    animationsSelector: () => ({
        start: 'in',
        loop: 'loop',
        end: 'out'
    }),
    slotOverrides: [
        {
            type: "animated",
            name: "counter",
            textProvider: () => dependency_container_instance.resolve(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL),
            valueProvider: () => {
                var _a;
                const slotMachine = dependency_container_instance.resolve(SlotMachine);
                return ((_a = slotMachine.currentSpinResult.freespins) === null || _a === void 0 ? void 0 : _a.remainingCount)
                    ? slotMachine.roundResult.actualSpinWinValue
                    : slotMachine.roundResult.totalWinValue;
            },
            valueRenderer: (value) => dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true),
            soundLoopProvider: () => ({
                id: sound_SoundList.COUNTER_LOOP,
                volume: 0.25
            }),
            soundEndProvider: () => ({
                id: sound_SoundList.COUNTER_END,
                volume: 0.4
            }),
        }
    ],
    loopAnimationCount: 10,
};
const SuperWinConfiguration = {
    assetName: `super_win`,
    animationsSelector: () => ({
        start: 'in',
        loop: 'loop',
        end: 'out'
    }),
    slotOverrides: [
        {
            type: "animated",
            name: "counter",
            textProvider: () => dependency_container_instance.resolve(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL),
            valueProvider: () => {
                var _a;
                const slotMachine = dependency_container_instance.resolve(SlotMachine);
                return ((_a = slotMachine.currentSpinResult.freespins) === null || _a === void 0 ? void 0 : _a.remainingCount)
                    ? slotMachine.roundResult.actualSpinWinValue
                    : slotMachine.roundResult.totalWinValue;
            },
            valueRenderer: (value) => dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true),
            soundLoopProvider: () => ({
                id: sound_SoundList.COUNTER_LOOP,
                volume: 0.25
            }),
            soundEndProvider: () => ({
                id: sound_SoundList.COUNTER_END,
                volume: 0.4
            }),
        }
    ],
    loopAnimationCount: 10,
};
const GrandWinConfiguration = {
    assetName: `grand_win`,
    animationsSelector: () => ({
        start: 'in',
        loop: 'loop',
        end: 'out'
    }),
    slotOverrides: [
        {
            type: "animated",
            name: "counter",
            textProvider: () => dependency_container_instance.resolve(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL),
            valueProvider: () => {
                var _a;
                const slotMachine = dependency_container_instance.resolve(SlotMachine);
                return ((_a = slotMachine.currentSpinResult.freespins) === null || _a === void 0 ? void 0 : _a.remainingCount)
                    ? slotMachine.roundResult.actualSpinWinValue
                    : slotMachine.roundResult.totalWinValue;
            },
            valueRenderer: (value) => dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true),
            soundLoopProvider: () => ({
                id: sound_SoundList.COUNTER_LOOP,
                volume: 0.25
            }),
            soundEndProvider: () => ({
                id: sound_SoundList.COUNTER_END,
                volume: 0.4
            }),
        }
    ],
    loopAnimationCount: 10,
};

;// CONCATENATED MODULE: ./src/the-miner/config/popups/PopupFreespinsConfig.ts
const PopupFreespinsConfig_name = 'freegame';
/* harmony default export */ const PopupFreespinsConfig = ({
    assetName: 'congratulation_popup',
    animationsSelector: () => ({
        start: `${PopupFreespinsConfig_name}_in`,
        loop: `${PopupFreespinsConfig_name}_loop`,
        end: `${PopupFreespinsConfig_name}_out`
    }),
});

;// CONCATENATED MODULE: ./src/the-miner/config/popups/PopupCongratulationsConfig.ts
const PopupCongratulationsConfig_name = 'congratulation';
/* harmony default export */ const PopupCongratulationsConfig = ({
    assetName: `congratulation_popup`,
    animationsSelector: () => ({
        start: `${PopupCongratulationsConfig_name}_in`,
        loop: `${PopupCongratulationsConfig_name}_loop`,
        end: `${PopupCongratulationsConfig_name}_out`
    }),
});

;// CONCATENATED MODULE: ./src/the-miner/config/popups/PopupHoldAndSpinnerConfig.ts
const PopupHoldAndSpinnerConfig_name = 'hold_spin';
/* harmony default export */ const PopupHoldAndSpinnerConfig = ({
    assetName: 'congratulation_popup',
    animationsSelector: () => ({
        start: `${PopupHoldAndSpinnerConfig_name}_in`,
        loop: `${PopupHoldAndSpinnerConfig_name}_loop`,
        end: `${PopupHoldAndSpinnerConfig_name}_out`
    }),
});

;// CONCATENATED MODULE: ./src/the-miner/config/popups/PopupExtraFreespinConfig.ts



const PopupExtraFreespinConfig_name = 'extra_spin';
/* harmony default export */ const PopupExtraFreespinConfig = ({
    assetName: 'congratulation_popup',
    animationsSelector: () => ({
        start: `${PopupExtraFreespinConfig_name}_in`,
        loop: `${PopupExtraFreespinConfig_name}_loop`,
        end: `${PopupExtraFreespinConfig_name}_out`
    }),
    slotOverrides: [
        {
            type: 'static',
            name: "extra_spins_count",
            valueProvider: () => {
                const sm = dependency_container_instance.resolve(SlotMachine);
                return sm.roundResult.holdAndSpinnerMultiplierMap.featureMultiplier;
            },
            textProvider: () => dependency_container_instance.resolve(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL),
            valueRenderer: (value) => `x${value}`,
        }
    ]
});

;// CONCATENATED MODULE: ./src/ignition-interactive/common/tsyringe/defaults.ts








dependency_container_instance.register(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL, { useValue: new Text() });
dependency_container_instance.register(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_VERTICAL, { useToken: PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL });
dependency_container_instance.register(PopupFactoryTokenConstants.CONGRATULATION_FEATURE_TEXT_HORIZONTAL, { useValue: new Container_Container() });
dependency_container_instance.register(PopupFactoryTokenConstants.CONGRATULATION_FEATURE_TEXT_VERTICAL, { useToken: PopupFactoryTokenConstants.CONGRATULATION_FEATURE_TEXT_HORIZONTAL });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_FREESPIN_DESKTOP_SCALE, { useValue: 0.65 });
dependency_container_instance.register(PopupFactoryTokenConstants.EXTRA_FREESPINS_TEXT_HORIZONTAL, { useValue: new Text() });
dependency_container_instance.register(PopupFactoryTokenConstants.EXTRA_FREESPINS_TEXT_VERTICAL, { useToken: PopupFactoryTokenConstants.EXTRA_FREESPINS_TEXT_HORIZONTAL });
// Popup configuration
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_0, { useValue: BigWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_1, { useValue: MegaWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_2, { useValue: SuperWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_3, { useValue: GrandWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_FREESPINS_CONFIG, { useValue: PopupFreespinsConfig });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_CONGRATULATIONS_CONFIG, { useValue: PopupCongratulationsConfig });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_HOLD_AND_SPINNER_CONFIG, { useValue: PopupHoldAndSpinnerConfig });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_EXTRA_FREESPIN_CONFIG, { useValue: PopupExtraFreespinConfig });

;// CONCATENATED MODULE: ./src/the-miner/control/command/ConfirmFreeSpinResultCommand.ts






class ConfirmFreeSpinResultCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        const roundResult = sm.roundResult;
        // show big win before spinning in freespins state
        if (sm.bigWinLevel(roundResult) != -1 && !sm.bigWinShown) {
            // State is diff than BIG_WIN, because onHidden there should be different controlEvent sent
            sm.currentState = SlotMachineState.BIG_WIN_FREE_SPIN;
        }
        else {
            new ControlEvent(SlotGameEvent.FREE_SPIN_START).dispatch();
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/control/command/ConfirmFreeSpinsRoundCompleteCommandOverride.ts





class ConfirmFreeSpinsRoundCompleteCommandOverride extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.freespins.roundComplete = true;
        sm.bigWinShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/the-miner/control/command/ConfirmHoldAndSpinnerRoundCompleteCommand.ts





class ConfirmHoldAndSpinnerRoundCompleteCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentSpinResult.bonus.bonusGameComplete = true;
        sm.bigWinShown = true;
        new ControlEvent(SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/the-miner/control/command/HoldAndSpinnerCommand.ts








class HoldAndSpinnerCommand extends ControlCommand {
    execute() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult = null;
        sm.currentState = SlotMachineState.SPINNING;
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.spin().then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent(SlotGameEvent.SPIN_STOP).dispatch();
        }).catch((e) => {
            utils_Logger.error(e);
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            sm.currentState = SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}

;// CONCATENATED MODULE: ./src/the-miner/sound/SoundListExtended.ts

class SoundListExtended extends sound_SoundList {
}
SoundListExtended.BASEGAME_BACKGROUND = 'basegame_loop';
SoundListExtended.FREEGAME_BACKGROUND = 'freegame_loop';
SoundListExtended.REEL_ANTICIPATION = 'reel_anticipation';
SoundListExtended.WIN_FRAME = 'win_frame';
SoundListExtended.SYMBOL_LOW_PAYOUT_1 = 'symbol_lp1_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_2 = 'symbol_lp2_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_3 = 'symbol_lp3_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_4 = 'symbol_lp4_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_5 = 'symbol_lp5_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_1 = 'symbol_hp1_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_2 = 'symbol_hp2_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_3 = 'symbol_hp3_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_4 = 'symbol_hp4_win';
SoundListExtended.MULTIPLIER = 'multiplier';
SoundListExtended.SYMBOL_WILD = 'symbol_wild_win';
SoundListExtended.SYMBOL_WILD_LAND = 'symbol_wild_land';
SoundListExtended.SYMBOL_SCATTER = 'symbol_scatter_win';
SoundListExtended.SYMBOL_SCATTER_LAND = 'symbol_scatter_land';
SoundListExtended.SYMBOL_BONUS = 'symbol_bonus_win';
/* harmony default export */ const sound_SoundListExtended = (SoundListExtended);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ButtonSpinAnimation.ts



class ButtonSpinAnimation extends Spine {
    constructor() {
        super(assets_AssetsManager.spine.get('button-spin'));
        this.state.data.setMix(ButtonSpinAnimation.SPIN, ButtonSpinAnimation.LOOP, 0.15);
        this.state.data.setMix(ButtonSpinAnimation.LOOP, ButtonSpinAnimation.STOP, 0.15);
        this.state.data.setMix(ButtonSpinAnimation.LOOP, ButtonSpinAnimation.SPIN, 0.15);
        this.state.data.setMix(ButtonSpinAnimation.WAIT_DELAY, ButtonSpinAnimation.SPIN, 0.15);
        this.setAnimation(ButtonSpinAnimation.WAIT_DELAY);
        this.text = new BitmapText('0', {
            fontName: 'Alexandria-Bold',
            fontSize: 45,
            align: 'center',
            tint: 0x434343
        });
        this.text.x = 0;
        this.text.y = 0;
        this.text.anchor.set(0.5, 0.5);
        const counterContainer = this.slotContainers[this.skeleton.findSlotIndex('Stop icon')];
        counterContainer.parent.addChild(this.text);
        this.text.visible = false;
    }
    setAnimation(name) {
        this.state.setAnimation(0, name, name === ButtonSpinAnimation.LOOP ||
            name === ButtonSpinAnimation.WAIT ||
            name === ButtonSpinAnimation.WAIT_DELAY ||
            name === ButtonSpinAnimation.WAIT_DELAY_INTRO);
        if (this.text)
            this.text.visible = name === ButtonSpinAnimation.LOOP_CONTINUE;
    }
    addAnimation(name, delay) {
        this.state.addAnimation(0, name, name === ButtonSpinAnimation.LOOP, delay);
    }
    getAnimationDuration(name, isSpinning) {
        if (name == ButtonSpinAnimation.LOOP && isSpinning)
            return 0;
        return this.spineData.animations.find((animation) => animation.name === name).duration;
    }
    setAutoPlayLeftValue(value) {
        this.text.text = value.toString();
    }
}
ButtonSpinAnimation.SPIN = 'spin_hover';
ButtonSpinAnimation.LOOP = 'spin_click';
ButtonSpinAnimation.STOP = 'spin_idle';
ButtonSpinAnimation.WAIT = 'spin_idle';
ButtonSpinAnimation.WAIT_DELAY = 'spin_idle';
ButtonSpinAnimation.WAIT_DELAY_INTRO = 'spin_idle';
ButtonSpinAnimation.LOOP_CONTINUE = 'stop_idle';
/* harmony default export */ const view_ButtonSpinAnimation = (ButtonSpinAnimation);

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/text/TextFormat.ts

const multiStyledText = function (tf, colorsArray, endPoints, spaceX = 0, isReturning = false) {
    const parent = tf.parent;
    const newPartsArr = [];
    colorsArray.forEach((color, index) => {
        let part;
        if (index === 0)
            part = tf.text.substring(0, tf.text.indexOf(endPoints[index]) + 1);
        else if (index > 0 && index < colorsArray.length - 1)
            part = tf.text.substring(tf.text.indexOf(endPoints[index - 1]) + 1, tf.text.indexOf(endPoints[index]) + 1);
        else
            part = tf.text.substring(tf.text.indexOf(endPoints[index - 1]) + 1, tf.text.length);
        const newText = new Text(part, color);
        newText.style.fontSize = tf.style.fontSize;
        newPartsArr.push(newText);
    });
    const newContainer = new Container_Container();
    newPartsArr.forEach((text, index) => {
        newContainer.addChild(text);
        if (index !== 0 && !text.text.includes('\n'))
            text.x = newPartsArr[index - 1].x + newPartsArr[index - 1].width + spaceX;
    });
    if (parent && !isReturning) {
        parent.addChild(newContainer);
        parent.removeChild(tf);
    }
    newContainer.pivot.x = newContainer.width / 2;
    newContainer.pivot.y = newContainer.height / 2;
    newContainer.x = tf.x;
    newContainer.y = tf.y;
    tf.destroy();
    if (isReturning) {
        return newContainer;
    }
};

;// CONCATENATED MODULE: ./src/the-miner/view/IntroScreenBackground.ts



class IntroScreenBackground extends Sprite {
    constructor() {
        super(assets_AssetsManager.textures.get('intro-screen-bg'));
        this.anchor.set(0.5, 0.5);
    }
    // PUBLIC API
    updateLayout(desc) {
        // hardcoded value!
        switch (desc.orientation) {
            case ScreenOrientation.HORIZONTAL:
                const xScale = desc.currentWidth / desc.baseWidth;
                const yScale = desc.currentHeight / desc.baseHeight;
                this.scale.set(xScale > yScale ? xScale : yScale);
                break;
            case ScreenOrientation.VERTICAL:
                const offsetX = (desc.currentWidth - desc.baseWidth) / 2;
                const backgroundWidth = 1920;
                this.scale.set((desc.currentHeight / desc.baseHeight) * 2);
                this.pivot.x = -(backgroundWidth / 2);
                this.x = 0 - offsetX;
                break;
        }
        if (desc.orientation == ScreenOrientation.VERTICAL) {
            const offsetX = (desc.currentWidth - desc.baseWidth) / 2;
            const backgroundWidth = 1920;
            this.pivot.x = -(backgroundWidth / 2);
            this.x = 0 - offsetX;
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ButtonSpin.ts




class ButtonSpin extends Button {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        this.buttonAnimator = this.normal;
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ButtonSpinAnimation':
                instance = new view_ButtonSpinAnimation();
                break;
            default:
                instance = super.customClassElementCreate(le);
                break;
        }
        return instance;
    }
    removeTweens() {
        this.buttonAnimator.visible = false;
        this.buttonAnimator.state.setEmptyAnimations(0);
    }
    waitAnimation(waitAnimation) {
        this.buttonAnimator.setAnimation(waitAnimation);
    }
    spinAnimation(inAnim, outAnim, showPattern = false, addRotation = false, isSpinning = true) {
        if (this.currentAnim === outAnim) {
            return;
        }
        this.buttonAnimator.setAnimation(inAnim);
        this.buttonAnimation(outAnim, this.buttonAnimator.getAnimationDuration(inAnim, isSpinning), addRotation);
        this.currentAnim = inAnim;
    }
    setAutoPlayLeftValue(value) {
        this.buttonAnimator.setAutoPlayLeftValue(value);
    }
    buttonAnimation(startAnim, delay = 0, addRotation = false) {
        ignitionTween.Tweener.removeTweens(this.scale);
        ignitionTween.Tweener.removeTweens(this.normal);
        this.normal.rotation = 0;
        if (startAnim.length > 0) {
            (delay > 0) ? this.buttonAnimator.addAnimation(startAnim, delay) : this.buttonAnimator.setAnimation(startAnim);
        }
        ignitionTween.Tweener.addTween(this.scale, {
            x: this.startScale * 0.83,
            y: this.startScale * 0.83,
            time: 0.2,
            transition: 'easeOutSine',
            onComplete: () => {
                ignitionTween.Tweener.addTween(this.scale, {
                    x: this.startScale,
                    y: this.startScale,
                    time: 0.25,
                    delay: 0.1,
                    transition: 'easeOutBounce'
                });
            }
        });
        if (addRotation) {
            ignitionTween.Tweener.addTween(this.normal, {
                rotation: degToRad(360),
                time: 0.35,
                transition: 'easeOutQuad',
                onComplete: () => {
                    this.normal.rotation = 0;
                }
            });
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/IntroScreen.ts












class IntroScreen extends AdjustableLayoutContainer {
    constructor() {
        super(assets_AssetsManager.layouts.get('intro-screen'));
        LayoutBuilder.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.tfIntroTextMobile.style.align = 'center';
        this.btnGetStarted.on('pointerup', this.onGetStartedClicked, this);
        const styleArr = [
            {
                fontFamily: assets_AssetsManager.webFonts.get('LuckiestGuy').family,
                fill: [
                    0xffffff
                ],
            },
            {
                fontFamily: assets_AssetsManager.webFonts.get('LuckiestGuy').family,
                fill: [
                    0x60f6ff,
                    0x7efbff,
                    0x7ceaf5
                ],
                fillGradientType: 1
            }, {
                fontFamily: assets_AssetsManager.webFonts.get('LuckiestGuy').family,
                fill: [
                    0xffffff
                ],
            }
        ];
        multiStyledText(this.tfIntroText['text'], styleArr, ['O', 'x']);
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        this.tfIntroText.pivot.set(0, this.tfIntroText.height / 2);
        if (desc.orientation == ScreenOrientation.VERTICAL) {
            this.tfIntroTextMobile.x = desc.baseWidth / 2;
            this.shadowMobile.y = desc.baseHeight + (desc.currentHeight - desc.baseHeight) / 2;
            this.shadowMobile.width = desc.currentWidth;
            this.tfIntroTextMobile.pivot.set(this.tfIntroTextMobile.width / 2, this.tfIntroTextMobile.height / 2);
            this.tfIntroTextMobile.position.set(this.shadowMobile.x, this.shadowMobile.y - this.shadowMobile.height / 2);
        }
    }
    // PRIVATE API
    onRemoved() {
        ignitionTween.Tweener.removeTweens(this);
        this.btnGetStarted.removeTweens();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ButtonGetStarted':
                instance = new ButtonSpin(le);
                const btn = instance;
                break;
            case 'IntroScreenBackground':
                instance = new IntroScreenBackground();
                break;
        }
        return instance;
    }
    onAdded() {
        this.btnGetStarted.waitAnimation(view_ButtonSpinAnimation.WAIT_DELAY);
    }
    // USER INTERACTION
    onGetStartedClicked() {
        this.btnGetStarted.enabled = false;
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        this.emit(IntroScreenEvent.ON_GET_STARTED_CLICKED);
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/TextFit.ts




class TextFit extends Container_Container {
    constructor(le, maxFontSize = 50) {
        super();
        this.maxFontSize = maxFontSize;
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        if (this.text instanceof MultiShadowText)
            this.text.autoScale(maxFontSize, this.area.width, this.area.height);
        else
            autoscaleText(this.text, maxFontSize, this.area.width, this.area.height);
        if (this.text.style.align == 'center')
            this.text.position.set(this.area.x, this.area.y);
        // nnnew.position.set(
        //     this.text.position.x + Math.cos(nnnew.style.dropShadowAngle) * (nnnew.style.dropShadowDistance),
        //     this.text.position.y + Math.sin(nnnew.style.dropShadowAngle) * (nnnew.style.dropShadowDistance),
        // )
        this.area.visible = false;
    }
    updateLayout() {
        if (this.text instanceof MultiShadowText)
            this.text.autoScale(this.maxFontSize, this.area.width, this.area.height);
        else
            autoscaleText(this.text, this.maxFontSize, this.area.width, this.area.height);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'MultiShadowText':
                instance = new MultiShadowText(le);
                break;
        }
        return instance;
    }
    setText(value) {
        this.text.text = value;
        this.updateLayout();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/features-components/FeatureWinBanner.ts









class FeatureWinBanner extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        if (this.winValue instanceof ValueText) {
            this.winValue.renderValueFunction = (tf, value) => {
                tf.text = `${dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true)}`;
            };
        }
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ValueText':
                instance = new ValueText(le);
                break;
            case 'MultiShadowText':
                instance = new MultiShadowText(le);
                break;
            case "TextFit":
                instance = new TextFit(le);
                break;
        }
        return instance;
    }
    setValue(value) {
        if (this.winValue instanceof ValueText) {
            this.winValue.value = Number(value.toFixed(2));
        }
        else if (this.winValue instanceof TextFit) {
            this.winValue.setText(`${dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true)}`);
        }
        else {
            this.winValue.text = `${dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value, true)}`;
        }
        this.winAnimation();
        if (value > 0) {
            this.winValue.alpha = 1;
        }
        else {
            this.reset();
        }
    }
    reset() {
        if (this.winValue instanceof ValueText) {
            this.winValue.value = 0;
        }
        else if (this.winValue instanceof TextFit) {
            this.winValue.setText(`${dependency_container_instance.resolve(model_Wallet).getCurrencyValue(0, true)}`);
        }
        else {
            this.winValue.text = `${dependency_container_instance.resolve(model_Wallet).getCurrencyValue(0, true)}`;
        }
        this.winValue.alpha = 0;
    }
    updateBackground(orientation) {
        if (orientation == ScreenOrientation.VERTICAL) {
            this.bcgMobile.visible = true;
            this.bcgDesktop.visible = false;
        }
        else {
            this.bcgMobile.visible = false;
            this.bcgDesktop.visible = true;
        }
    }
    winAnimation() {
        const totalWinIn = 0.6;
        const totalWinOut = 0.5;
        ignitionTween.Tweener.addTween(this.winValue.scale, {
            x: 1.5,
            y: 1.5,
            time: totalWinIn,
            transition: 'easeOutQuint',
            onComplete: () => {
                ignitionTween.Tweener.addTween(this.winValue.scale, {
                    x: 1,
                    y: 1,
                    time: totalWinOut,
                    transition: 'easeInQuint',
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/TotalWinFrame.ts










class TotalWinFrame extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        const wallet = dependency_container_instance.resolve(model_Wallet);
        this.totalWinValue.renderValueFunction = (tf, value) => {
            tf.text = `${wallet.getCurrencyValue(value)}`;
        };
        // this.totalWinIso = this.getChildByName('isoText');
        // this.totalWinIso.text= Wallet.currency.isoCode; 
        this.setValue(0);
        this.once('added', this.onAdded, this);
    }
    onAdded() {
        this._defaultPos = this.position.y;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'TotalWinGlow':
                instance = new Spine(Assets.get('total-win-glow').spineData);
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
        }
        return instance;
    }
    setValue(value, animated = false) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (animated) {
            if (value < this.totalWinValue.value) {
                this.totalWinValue.value = 0;
            }
            //To fix the issue when previous tween is not finished yet
            if (ignitionTween.Tweener.isTweening(this.totalWinValue)) {
                ignitionTween.Tweener.removeTweens(this.totalWinValue);
                this.totalWinValue.value = value;
                return;
            }
            const isTurbo = sm.currentGameSpeedLevel === 1;
            this.totalWinValue.setValue(value, {
                countUpDuration: isTurbo ? 0 : 0.6
            });
            this.winAnimation(isTurbo);
        }
        else {
            this.totalWinValue.value = value;
        }
    }
    changePosition(offset = 0, skipAnimation = false) {
        if (skipAnimation) {
            this.position.y = this._defaultPos + offset;
            return;
        }
        ignitionTween.Tweener.addTween(this.position, {
            y: this._defaultPos + offset,
            time: 0.8,
            transition: 'easeOutQuint'
        });
    }
    winAnimation(isTurbo = false) {
        if (isTurbo) {
            return;
        }
        const totalWinIn = 0.4;
        const totalWinOut = 0.35;
        if (this.visible) {
            this.loopedSound = sound_SoundManager.loop({
                id: sound_SoundList.COUNTER_LOOP,
                volume: 0.3,
            });
        }
        //Animate the total win
        ignitionTween.Tweener.addTween(this.totalWinValue.scale, {
            x: 1.1,
            y: 1.1,
            time: totalWinIn,
            transition: 'easeOutQuint',
            onComplete: () => {
                ignitionTween.Tweener.addTween(this.totalWinValue.scale, {
                    x: 1,
                    y: 1,
                    time: totalWinOut,
                    transition: 'easeInQuint',
                });
                this.loopedSound.stop();
            }
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/BalanceInfo.ts



class BalanceInfo extends Button {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        LayoutBuilder.create(le, this, (le) => {
            return new ValueText(le);
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/model/event/ButtonVolumeEvent.ts
var ButtonVolumeEvent;
(function (ButtonVolumeEvent) {
    ButtonVolumeEvent["STATE_CHANGED"] = "onStateChanged";
})(ButtonVolumeEvent || (ButtonVolumeEvent = {}));
var ButtonVolumeState;
(function (ButtonVolumeState) {
    ButtonVolumeState["ON"] = "on";
    ButtonVolumeState["OFF"] = "off";
})(ButtonVolumeState || (ButtonVolumeState = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ButtonVolume.ts


class ButtonVolume extends Button {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        this.on('pointerup', this.onClick, this);
        this.btn_on = this.normal['btn_on'];
        this.btn_off = this.normal['btn_off'];
    }
    set state(state) {
        if (this._state == state)
            return;
        this._state = state;
        this.changeState();
        this.emit(ButtonVolumeEvent.STATE_CHANGED, this._state);
    }
    changeState() {
        [this.btn_off, this.btn_on].forEach((view) => {
            view.visible = false;
        });
        switch (this._state) {
            case ButtonVolumeState.ON:
                this.btn_on.visible = true;
                break;
            case ButtonVolumeState.OFF:
                this.btn_off.visible = true;
                break;
        }
    }
    onClick() {
        this.state = this._state == ButtonVolumeState.ON ? ButtonVolumeState.OFF : ButtonVolumeState.ON;
    }
    setInitialState(music, fx) {
        if (!music && !fx) {
            this._state = ButtonVolumeState.OFF;
        }
        else {
            this._state = ButtonVolumeState.ON;
        }
        this.changeState();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/features-components/DoubleChanceSwitch.ts






class DoubleChanceSwitch extends Container_Container {
    constructor(le) {
        super();
        this._active = false;
        this.offset = 6;
        LayoutBuilder.create(le, this);
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.on(GameServiceEvent_GameServiceEvent.DOUBLE_CHANCE_CHANGED, () => {
            this.active = gs.doubleUpChance;
        }, this);
        this.active = gs.doubleUpChance;
    }
    set active(isActive) {
        this._active = isActive;
        this.updateView();
    }
    updateView() {
        ignitionTween.Tweener.removeTweens(this.switchArrow);
        ignitionTween.Tweener.removeTweens(this.switchConfirm);
        this.switchConfirm.alpha = this._active ? 1 : 0;
        this.switchArrow.alpha = this._active ? 0 : 1;
        [this.switchConfirm, this.switchArrow].forEach((btn) => {
            ignitionTween.Tweener.addTween(btn, {
                x: this._active ? this.switch_off.x : 0,
                time: 0.25,
                transition: 'easeOutSine'
            });
        });
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/features-components/DoubleChanceButton.ts















class DoubleChanceButton extends Button {
    constructor(l) {
        super(l, (le) => {
            let instance = null;
            switch (le.customClass) {
                case 'DoubleChanceSwitch':
                    instance = new DoubleChanceSwitch(le);
                    break;
                case 'Switch':
                    instance = new SwitchView(le);
                    break;
                case 'TextFit':
                    instance = new TextFit(le);
                    break;
            }
            return instance;
        });
        this.costRate = dependency_container_instance.resolve(CommonTokenConstants.DOUBLE_CHANCE_BUTTON_COST_RATE);
        this.tfValue = this['normal']['tfValue'];
        this.tfDescription = this['normal']['tfDescription'];
        this.tfTitle = this['normal']['tfTitle'];
        this.doubleChanceSwitch = this['normal']['doubleChanceSwitch'];
        this.gs = dependency_container_instance.resolve(services_GameService);
        if (this.doubleChanceSwitch instanceof SwitchView) {
            // SAME ENGINE DIFFERENT DESIGNS
            this.gs.on(GameServiceEvent_GameServiceEvent.DOUBLE_CHANCE_CHANGED, () => {
                this.changeChance();
            }, this);
            this.changeChance();
        }
        const sm = dependency_container_instance.resolve(SlotMachine);
        const wallet = dependency_container_instance.resolve(model_Wallet);
        sm.on(SlotMachineEvent.BET_VALUE_CHANGED, () => {
            this.setValue(wallet.getCurrencyValue(this.costRate * sm.totalBet * wallet.coinValue, true));
        }, this);
        wallet.on(WalletEvent.COIN_VALUE_CHANGED, () => {
            this.setValue(wallet.getCurrencyValue(this.costRate * sm.totalBet * wallet.coinValue, true));
        }, this);
        this.setValue(wallet.getCurrencyValue(this.costRate * sm.totalBet * wallet.coinValue, true));
        this.setTexts();
        this.on('pointerup', this.onClick, this);
    }
    changeChance() {
        this.doubleChanceSwitch.state = (this.gs.doubleUpChance ? SwitchState.ON : SwitchState.OFF);
    }
    setValue(value) {
        if (this.tfValue) {
            this.tfValue.text.text = value;
        }
    }
    onClick() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.doubleUpChance = !gs.doubleUpChance;
    }
    setTexts() {
        if (this.tfDescription) {
            this.tfDescription.text.style.align = 'center';
        }
    }
    set enabled(value) {
        super.enabled = value;
        if (this.doubleChanceSwitch instanceof SwitchView) {
            this.interactiveChildren = value;
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/features-components/HeartBanner.ts
var HeartBanner_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





class HeartBanner extends Container_Container {
    constructor(le) {
        super();
        this.heartArr = [];
        LayoutBuilder.create(le, this);
        for (let i = 0; this['heart' + i]; i++) {
            this.heartArr.push(this['heart' + i]);
        }
        this.heartArr.reverse();
        this.restore(true);
    }
    updateHearts() {
        this.heartArr.forEach((heart, index) => {
            if (index <= this.healthLevel - 1) {
                heart.active.visible = true;
                heart.disabled.visible = false;
            }
            else {
                heart.active.visible = false;
                heart.disabled.visible = true;
            }
        });
    }
    restore(updateHearts) {
        var _a, _b, _c, _d;
        const sm = dependency_container_instance.resolve(SlotMachine);
        this.prevHeartLevel = (_a = this.healthLevel) !== null && _a !== void 0 ? _a : 4;
        this.healthLevel = (_d = (_c = (_b = sm.roundResult) === null || _b === void 0 ? void 0 : _b.holdAndSpinner) === null || _c === void 0 ? void 0 : _c.remainingCount) !== null && _d !== void 0 ? _d : 4;
        if (updateHearts)
            this.updateHearts();
    }
    resetHearts(animate) {
        return HeartBanner_awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                if (this.healthLevel == 4) {
                    resolve();
                    return;
                }
                this.restore(false);
                if (!animate) {
                    this.heartArr.forEach((element) => {
                        element.active.visible = true;
                        element.disabled.visible = false;
                    });
                    this.prevHeartLevel = this.healthLevel;
                    this.healthLevel = 4;
                    resolve();
                    return;
                }
                else {
                    this.prevHeartLevel = this.healthLevel;
                    this.healthLevel = 4;
                    this.animateReset(resolve);
                }
            });
        });
    }
    animateReset(resolve) {
        return HeartBanner_awaiter(this, void 0, void 0, function* () {
            const time = 0.2;
            let delayIteration = 0;
            for (let i = 0; i <= this.healthLevel - 1; i++) {
                if (this.heartArr[i].active.visible == false) {
                    ignitionTween.Tweener.removeTweens(this.heartArr[i].active);
                    ignitionTween.Tweener.addTween(this.heartArr[i].active, {
                        onStart: () => {
                            this.heartArr[i].active.alpha = 0;
                            this.heartArr[i].active.visible = true;
                            this.heartArr[i].disabled.visible = false;
                        },
                        delay: (time * 2) * delayIteration * 1.1,
                        alpha: 1,
                        time: time,
                    });
                    ignitionTween.Tweener.addTween(this.heartArr[i].active.scale, {
                        x: 1.5,
                        y: 1.5,
                        time: time,
                        delay: (time * 2) * delayIteration * 1.1,
                        onComplete: () => {
                            ignitionTween.Tweener.addTween(this.heartArr[i].active.scale, {
                                x: 1,
                                y: 1,
                                time: time,
                                onComplete: () => {
                                    if (i == this.healthLevel - 1) {
                                        resolve();
                                    }
                                }
                            });
                        }
                    });
                    delayIteration++;
                }
            }
        });
    }
    reduceHeart() {
        this.restore(false);
        const currHeart = this.heartArr[this.healthLevel - 1];
        if (currHeart.active.visible) {
            currHeart.active.visible = false;
            currHeart.disabled.visible = true;
            return;
        }
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/features-components/HoldAndSpinnerButton.ts


















class HoldAndSpinnerButton extends Button {
    constructor(l) {
        super(l, (le) => {
            let instance = null;
            switch (le.customClass) {
                case 'TextFit':
                    instance = new TextFit(le);
                    break;
            }
            return instance;
        });
        this.tfValue = this.normal['tfValue'];
        this.tfDescription = this.normal['tfDescription'];
        const sm = dependency_container_instance.resolve(SlotMachine);
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.on(GameServiceEvent_GameServiceEvent.DOUBLE_CHANCE_CHANGED, () => {
            this.setActive(!gs.doubleUpChance);
        }, this);
        const feature = gs.featureBuyConfig.config.find(feature => feature.RoundType == FeatureTypes.HOLD_AND_SPINNER);
        sm.on(SlotMachineEvent.BET_VALUE_CHANGED, () => {
            this.setTexts(translations_Translation.t('holdSpinner.description'), wallet.getCurrencyValue(feature.Multiplier * sm.totalBet * wallet.coinValue, true));
        }, this);
        wallet.on(WalletEvent.COIN_VALUE_CHANGED, () => {
            this.setTexts(translations_Translation.t('holdSpinner.description'), wallet.getCurrencyValue(feature.Multiplier * sm.totalBet * wallet.coinValue, true));
        }, this);
        this.setTexts(translations_Translation.t('holdSpinner.description'), wallet.getCurrencyValue(feature.Multiplier * sm.totalBet * wallet.coinValue, true));
        const styleArr = dependency_container_instance.resolve(CommonTokenConstants.HOLD_AND_SPINNER_MULTI_STYLED_TEXT);
        multiStyledText(this.tfDescription.text, styleArr, ['D', '&'], 0);
        this.on('pointerup', this.onClick, this);
    }
    onClick() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        const data = {
            type: PopupType.HOLD_AND_SPINNER_BUY,
            hideOnClick: false,
            duration: -1,
            callbacks: null
        };
        new ControlEvent(UIPanelEvent.SHOW_POPUP, data).dispatch();
    }
    setTexts(title, value, isActive = true) {
        this.tfDescription.text.text = title;
        if (this.tfValue)
            this.tfValue.text.text = value;
        this.setActive(isActive);
        this.tfValue.updateLayout();
    }
    setActive(isActive) {
        this.enabled = isActive;
        isActive ? this.alpha = 1 : this.alpha = 0.4;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/TurboSelectExpanding.ts











class TurboSelectExpanding extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.allButtonOptions = [this.btnNormal, this.btnTurbo, this.btnSuperTurbo];
        this.allButtonOptions.forEach((btn, index) => btn.on('pointerup', () => this.onTurboSelect(index)));
        this.btnSelected.on('pointerup', this.show, this);
        this.currentSelectedSpeed = CurrentSpeedButton.NORMAL;
        this.hide();
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.on(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        this.onGameSpeedLevelChanged();
    }
    onGameSpeedLevelChanged() {
        this.changeCurrentSpeed(this.slotMachine.currentGameSpeedLevel);
        this.hide();
    }
    show() {
        this.updateView();
        this.allButtonOptions.forEach((button, index) => {
            ignitionTween.Tweener.removeTweens(button);
            ignitionTween.Tweener.addTween(button, {
                alpha: 1,
                time: 0.12,
                transition: 'easeOutQuad',
                delay: index * 0.1,
                onComplete: () => button.visible = true
            });
        });
        // Hide the selected button at the same time as the first expanding button
        ignitionTween.Tweener.removeTweens(this.btnSelected);
        ignitionTween.Tweener.addCaller(this.btnSelected, {
            count: 1,
            time: 0.12,
            onComplete: () => this.btnSelected.visible = false
        });
    }
    updateView() {
        this.btnSelected.children.forEach((type) => type.visible = false);
        this.btnSelected[`${this.currentSelectedSpeed}`].visible = true;
    }
    hide() {
        this.updateView();
        this.allButtonOptions.reverse().forEach((button, index) => {
            ignitionTween.Tweener.removeTweens(button);
            ignitionTween.Tweener.addTween(button, {
                alpha: 0,
                time: 0.12,
                transition: 'easeOutQuad',
                delay: index * 0.1,
                onComplete: () => button.visible = false
            });
        });
        this.allButtonOptions.reverse();
        // Show the selected button at the same time the last expanding button starts hiding
        ignitionTween.Tweener.removeTweens(this.btnSelected);
        ignitionTween.Tweener.addCaller(this.btnSelected, {
            count: 1,
            time: 0.12,
            delay: (Math.max(this.allButtonOptions.length - 2, 0)) * 0.1,
            onComplete: () => this.btnSelected.visible = true
        });
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
        }
        return instance;
    }
    onTurboSelect(level) {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIEventExtension.GAME_SPEED_LEVEL_SELECT, level).dispatch();
        // new ControlEvent(UIPanelEvent.SHOW_POPUP, {
        //     type: PopupType.TURBO_ACTIVATE,
        //     hideOnClick: true,
        //     duration: 1,
        //     callbacks: null
        // }).dispatch();
        this.changeCurrentSpeed(level);
        this.hide();
    }
    changeCurrentSpeed(level) {
        this.currentSelectedSpeed = Object.values(CurrentSpeedButton)[level];
    }
}
var CurrentSpeedButton;
(function (CurrentSpeedButton) {
    CurrentSpeedButton["NORMAL"] = "normal";
    CurrentSpeedButton["TURBO"] = "turbo";
    CurrentSpeedButton["SUPER_TURBO"] = "superTurbo";
})(CurrentSpeedButton || (CurrentSpeedButton = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/FreeSpinButton.ts




















class FreeSpinButton extends Button {
    constructor(l) {
        var _a, _b, _c;
        super(l, (le) => {
            let instance = null;
            switch (le.customClass) {
                case 'TextFit':
                    instance = new TextFit(le);
                    break;
            }
            return instance;
        });
        const sm = dependency_container_instance.resolve(SlotMachine);
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const gs = dependency_container_instance.resolve(services_GameService);
        sm.on(SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
        this.currentValue = ((_c = (_b = (_a = sm.currentSpinResult) === null || _a === void 0 ? void 0 : _a.freespins) === null || _b === void 0 ? void 0 : _b.remainingCount) !== null && _c !== void 0 ? _c : 1) - 1;
        if (Number.isNaN(this.currentValue)) {
            this.currentValue = 0;
        }
        this.currentTheme = BackgroundType.NORMAL;
        this.icon = this.normal.children.find((child) => child.name !== 'bcg' && child instanceof Sprite);
        this.tfTitle = this.normal['tfTitle'];
        this.tfValue = this.normal['tfValue'];
        this.tfValueDefaultX = this.tfValue.x;
        this.tfTitle.text.style.align = 'center';
        const feature = gs.featureBuyConfig.config.find(feature => feature.RoundType == FeatureTypes.FREESPIN);
        sm.on(SlotMachineEvent.BET_VALUE_CHANGED, () => {
            this.setTexts(translations_Translation.t('freeSpins.buy'), wallet.getCurrencyValue(feature.Multiplier * sm.totalBet * wallet.coinValue, true));
        }, this);
        wallet.on(WalletEvent.COIN_VALUE_CHANGED, () => {
            this.setTexts(translations_Translation.t('freeSpins.buy'), wallet.getCurrencyValue(feature.Multiplier * sm.totalBet * wallet.coinValue, true));
        }, this);
        gs.on(GameServiceEvent_GameServiceEvent.DOUBLE_CHANCE_CHANGED, () => {
            this.setActive(!gs.doubleUpChance, !gs.doubleUpChance ? 1 : 0.4);
        }, this);
        this.on('pointerup', this.onClick, this);
        if (dependency_container_instance.isRegistered(CommonTokenConstants.FREESPIN_MULTI_STYLED_TEXT)) {
            const styleArr = dependency_container_instance.resolve(CommonTokenConstants.FREESPIN_MULTI_STYLED_TEXT);
            multiStyledText(this.tfTitle.text, styleArr, ['Y',]);
        }
        // At this point SlotMachine, Wallet and GameService are fully initialized and contains valid data to be displayed
        this.setTexts(translations_Translation.t('freeSpins.buy'), wallet.getCurrencyValue(/*gs.featureBuyConfig.Rate * */ sm.totalBet * wallet.coinValue, true));
    }
    moreAwarded() {
        var _a, _b, _c;
        this.currentValue = (_c = (_b = (_a = dependency_container_instance.resolve(SlotMachine).currentSpinResult) === null || _a === void 0 ? void 0 : _a.freespins) === null || _b === void 0 ? void 0 : _b.remainingCount) !== null && _c !== void 0 ? _c : 0;
        if (Number.isNaN(this.currentValue)) {
            this.currentValue = 0;
        }
    }
    onSlotMachineStateChanged(currentState) {
        switch (currentState) {
            case SlotMachineState.SPINNING:
                if (this.currentTheme == BackgroundType.FREEGAME) {
                    this.currentValue--;
                    this.setTexts(translations_Translation.t('freeSpins.left'), (this.currentValue).toString(), false);
                }
                break;
        }
    }
    // onSlotMachineStateChanged doesn't synchronize with transition animation, so below function is used to change state during transition
    changeState(theme) {
        var _a, _b, _c;
        const sm = dependency_container_instance.resolve(SlotMachine);
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const gs = dependency_container_instance.resolve(services_GameService);
        this.currentValue = (_c = (_b = (_a = sm.currentSpinResult) === null || _a === void 0 ? void 0 : _a.freespins) === null || _b === void 0 ? void 0 : _b.remainingCount) !== null && _c !== void 0 ? _c : 0;
        this.currentTheme = theme;
        const feature = gs.featureBuyConfig.config.find(feature => feature.RoundType == FeatureTypes.FREESPIN);
        switch (theme) {
            case BackgroundType.NORMAL:
                this.setTexts(translations_Translation.t('freeSpins.buy'), wallet.getCurrencyValue(feature.Multiplier * sm.totalBet * wallet.coinValue, true), true, true);
                if (this.icon) {
                    this.icon.alpha = 1;
                    this.tfValue.x = this.tfValueDefaultX;
                }
                break;
            case BackgroundType.FREEGAME:
                if (sm.currentState == SlotMachineState.FREE_SPINS_ROUND_START)
                    this.setTexts(translations_Translation.t('freeSpins.left'), (this.currentValue).toString(), false, true);
                //else if(sm.currentState == SlotMachineState.SPIN_RESULT_FREE_SPINS)
                //  this.setTexts(Translation.t('freeSpins.left'), (sm.currentSpinResult.freespins.totalCount).toString(), false, true);
                if (this.icon) {
                    this.icon.alpha = 0;
                    this.tfValue.x = this.normal.width * 0.5;
                }
                break;
        }
    }
    onClick() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        const data = {
            type: PopupType.FREESPIN_BUY,
            hideOnClick: false,
            duration: -1,
            callbacks: null
        };
        new ControlEvent(UIPanelEvent.SHOW_POPUP, data).dispatch();
    }
    setTexts(title, value, isActive = true, isNotAlpha = true) {
        this.tfTitle.text.text = title;
        this.tfValue.text.text = value;
        this.setActive(isActive);
        this.updateLayout();
        isNotAlpha ? this.alpha = 1 : this.alpha = 0.4;
    }
    setActive(isActive, alpha) {
        this.enabled = isActive;
        if (alpha)
            this.alpha = alpha;
    }
    updateLayout() {
        this.tfTitle.updateLayout();
        this.tfValue.updateLayout();
    }
}
var BackgroundType;
(function (BackgroundType) {
    BackgroundType["NORMAL"] = "main-screen-background";
    BackgroundType["FREEGAME"] = "freegame-screen-background";
    BackgroundType["BONUS"] = "bonus-screen";
})(BackgroundType || (BackgroundType = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ButtonAutospin.ts

class ButtonAutospin extends Button {
    //private tfSpinNumber:Text;
    //private counterBackground: NineSlicePlane;
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        //this.tfSpinNumber = this.normal['tfSpinNumber'];
        //this.counterBackground = this.normal['counterBackground'];
    }
    autospinChange(value) {
        //this.counter = value;
        //this.normal['stop'].alpha = this.counterBackground.alpha = (value<=0) ? 0: 1;
        //this.normal['play'].alpha = (value<=0) ? 1 : 0
        this.enabled = value <= 0;
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            default:
                instance = super.customClassElementCreate(le);
                break;
        }
        return instance;
    }
    // private set counter(value:number){
    //     this.tfSpinNumber.text = value > 0 ? `${value}` : '';
    //     this.counterBackground.width = this.tfSpinNumber.width + 30;
    //     this.counterBackground.pivot.set(this.counterBackground.width/2, this.counterBackground.pivot.y);
    // }
    updateView() {
        super.updateView();
        //this.alpha = this.enabled ? 1: 0.4;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/UITurboSettings.ts








class UITurboSettings extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.btnNormalTurbo.on('pointerup', () => {
            this.onTurboBtnSelected(0);
        }, this);
        this.btnTurbo.on('pointerup', () => {
            this.onTurboBtnSelected(1);
        }, this);
        this.btnSuperTurbo.on('pointerup', () => {
            this.onTurboBtnSelected(2);
        }, this);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
        }
        return instance;
    }
    onTurboBtnSelected(level) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        sm.currentGameSpeedLevel = level;
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        const gs = dependency_container_instance.resolve(services_GameService);
        gs.settings.quickSpin = level;
        gs.saveSettings();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/UIPanelDesktop.ts







































class UIPanelDesktop extends AdjustableLayoutContainer {
    constructor(config) {
        super(assets_AssetsManager.layouts.get('UIPanelDesktop'));
        this._config = config;
        LayoutBuilder.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        // additional container is used to keep scale bounce animation intact
        this.btnSpin = this['btnSpinContainer'].btnSpin;
        this.baseXPositions = {
            heartBanner: this.heartBanner.position.x,
        };
        this.baseYPositions = {
            btnMenu: this.btnMenu.position.y,
            btnSound: this.btnSound.position.y,
            btnInfo: this.btnInfo.position.y,
            btnTurbo: this.btnTurbo.position.y,
            btnAutospin: this.btnAutoSpin.position.y,
            btnMinus: this.btnBetDown.position.y,
            btnPlus: this.btnBetUp.position.y,
            btnSpin: this['btnSpinContainer'].position.y,
            uiTurboSettings: this.uiTurboSettingsDesktop.position.y,
            btnFreeSpin: this.btnFreeSpin.position.y,
        };
        this.btnBetUp.on('pointerup', this.onBtnBetUp, this);
        this.btnBetDown.on('pointerup', this.onBtnBetDown, this);
        this.btnAutoSpin.on('pointerup', this.onBtnAutoSpin, this);
        this.btnTurbo.on('pointerup', this.onShowTurboSetting, this);
        this.btnSpin.on('pointerup', this.onBtnSpin, this);
        this.btnMenu.on('pointerup', this.onBtnMenu, this);
        this.btnSound.on(SwitchEvent.STATE_CHANGED, this.onBtnSound, this);
        this.btnInfo.on('pointerup', this.onBtnInfo, this);
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.autoplay.on(AutoplayEvent.ENABLED, this.onAutospinEnabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent.DISABLED, this.onAutospinDisabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent.SPINS_LEFT_CHANGED, this.onAutospinSpinsLeftChange, this);
        this.onAutospinSpinsLeftChange();
        this.gs = dependency_container_instance.resolve(services_GameService);
        this.gs.on(GameServiceEvent_GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateVolume();
        }, this);
        this.updateVolume();
        // this.statusComponent.winValue = 0
        this.slotMachine.on(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        this.onGameSpeedLevelChanged(this.slotMachine.currentGameSpeedLevel);
        this.uiTurboSettingsDesktop.children.forEach((child) => {
            child.alpha = 0;
        });
        if (this.slotMachine.autoplay.enabled)
            this.btnSpin.waitAnimation(view_ButtonSpinAnimation.LOOP_CONTINUE);
        document.body.addEventListener('keydown', (e) => this.onSpaceClick(e));
        this.btnSound.setInitialState(this.gs.settings.soundFx ? SwitchState.ON : SwitchState.OFF);
    }
    moveBtnFreespin(basePos) {
        const baseBtnFreespinPos = this.baseYPositions.btnFreeSpin;
        ignitionTween.Tweener.addTween(this.btnFreeSpin, {
            y: basePos ? baseBtnFreespinPos : 307.5,
            time: 0.2,
            transition: 'easeInOutQuart'
        });
    }
    // PUBLIC API
    setFeatureButtonsVisibility(type) {
        if (type == UIPanelDesktop_BackgroundType.FREEGAME) {
            this.btnHoldAndSpinner.visible = this.btnDoubleChance.visible = this.heartBanner.visible = false;
            this.btnFreeSpin.visible = true;
            this.moveBtnFreespin(false);
        }
        else if (type == UIPanelDesktop_BackgroundType.BONUS) {
            this.btnHoldAndSpinner.visible = this.btnDoubleChance.visible = this.btnFreeSpin.visible = false;
            this.heartBanner.visible = true;
            this.heartBanner.resetHearts(false);
        }
        else {
            this.btnHoldAndSpinner.visible = this.btnDoubleChance.visible = this.btnFreeSpin.visible = true;
            this.heartBanner.visible = false;
            this.moveBtnFreespin(true);
        }
        this.btnFreeSpin.changeState(type);
    }
    lock() {
        [
            this.btnBetDown,
            this.btnDoubleChance,
            this.btnAutoSpin,
            this.btnBetUp,
            this.btnFreeSpin,
            this.btnHoldAndSpinner,
            this.btnMenu,
            this.btnSpin,
        ].forEach((btn) => {
            btn.enabled = false;
        });
        if (!this.slotMachine.autoplay.enabled) {
            this.btnAutoSpin.enabled = false;
        }
        else {
            this.btnSpin.enabled = true;
        }
        new ControlEvent(UIPanelEvent.CLOSE_SETTINGS).dispatch();
    }
    unlock() {
        [
            this.btnDoubleChance,
            this.btnAutoSpin,
            this.btnBetDown,
            this.btnBetUp,
            this.btnSpin,
            this.btnFreeSpin,
            this.btnHoldAndSpinner,
            this.btnMenu
        ].forEach((btn) => {
            btn.enabled = true;
        });
        this.btnSpin.waitAnimation(view_ButtonSpinAnimation.WAIT_DELAY);
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        // IF necessary stick hearts banner to the left side
        if (this.baseXPositions.heartBanner == 0) {
            this.heartBanner.x = -(desc.currentWidth - desc.baseWidth) / 2;
        }
        this.background.width = desc.currentWidth * 1.01;
        this.background.x = -(desc.currentWidth - desc.baseWidth) / 2 - 10;
        if (desc.currentHeight > desc.baseHeight) {
            this.background.y = this.statusComponent.y = desc.baseHeight + (desc.currentHeight - desc.baseHeight) / 2;
        }
        else {
            this.background.y = this.statusComponent.y = desc.baseHeight;
        }
        this.totalWinFrame.y = this.background.y - 99;
        let bottomY = desc.baseHeight;
        if (desc.currentHeight > desc.baseHeight) {
            bottomY = desc.baseHeight + (desc.currentHeight - desc.baseHeight) / 2;
        }
        this.btnTurbo.y = this.btnTurbo.y = bottomY - (desc.baseHeight - this.baseYPositions.btnTurbo);
        this.btnMenu.y = this.btnMenu.y = bottomY - (desc.baseHeight - this.baseYPositions.btnMenu);
        this.btnSound.y = this.btnSound.y = bottomY - (desc.baseHeight - this.baseYPositions.btnSound);
        this.btnInfo.y = this.btnInfo.y = bottomY - (desc.baseHeight - this.baseYPositions.btnInfo);
        this.btnAutoSpin.y = bottomY - (desc.baseHeight - this.baseYPositions.btnAutospin);
        this.btnBetDown.y = bottomY - (desc.baseHeight - this.baseYPositions.btnMinus);
        this.btnBetUp.y = bottomY - (desc.baseHeight - this.baseYPositions.btnPlus);
        this['btnSpinContainer'].y = bottomY - (desc.baseHeight - this.baseYPositions.btnSpin);
        this.uiTurboSettingsDesktop.y = bottomY - (desc.baseHeight - this.baseYPositions.uiTurboSettings);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        let btn;
        switch (le.customClass) {
            case 'ButtonSpin':
                instance = new ButtonSpin(le);
                btn = instance;
                //btn.hitArea = new Circle(105, 105, 110);
                break;
            case 'ButtonAutospin':
                instance = new ButtonAutospin(le);
                btn = instance;
                break;
            case 'Button':
                instance = new Button(le);
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
            case 'SwitchView':
                instance = new SwitchView(le);
                break;
            case 'BalanceInfo':
                instance = new BalanceInfo(le);
                break;
            case 'FreeSpinButton':
                instance = new FreeSpinButton(le);
                break;
            case 'DoubleChanceButton':
                instance = new DoubleChanceButton(le);
                break;
            case 'HoldAndSpinnerButton':
                instance = new HoldAndSpinnerButton(le);
                break;
            case 'ButtonVolume':
                instance = new ButtonVolume(le);
                break;
            case 'HeartBanner':
                instance = new HeartBanner(le);
                break;
            case 'ButtonTurbo':
                instance = new Button(le);
                break;
            case 'StatusBar':
                instance = new StatusBar(le);
                break;
            case 'AdjustTotalBet':
                instance = new AdjustTotalBet(le);
                break;
            case 'TotalWinFrame':
                instance = new TotalWinFrame(le);
                break;
            case 'TurboSelectExpanding':
                instance = new TurboSelectExpanding(le);
                break;
            case 'UITurboSettingsDesktop':
                instance = new UITurboSettings(le);
                break;
            case 'StatusComponent':
                instance = new StatusComponent(le);
                break;
        }
        return instance;
    }
    // USER INTERACTION
    onAutospinEnabled() {
        this.btnSpin.waitAnimation(view_ButtonSpinAnimation.LOOP_CONTINUE);
    }
    onAutospinDisabled() {
        if (this.slotMachine.currentState != SlotMachineState.IDLE) {
            this.btnAutoSpin.enabled = false;
            this.btnSpin.visible = true;
            this.btnSpin.waitAnimation(view_ButtonSpinAnimation.WAIT_DELAY);
        }
    }
    onAutospinSpinsLeftChange() {
        this.btnAutoSpin.autospinChange(this.slotMachine.autoplay.spinsLeft);
        this.btnSpin.setAutoPlayLeftValue(this.slotMachine.autoplay.spinsLeft);
    }
    onGameSpeedLevelChanged(speedLevel) {
        const spriteIcon = this.btnTurbo.normal.children[0];
        spriteIcon.width = 36;
        spriteIcon.pivot.set(0);
        spriteIcon.anchor.set(0.5);
        spriteIcon.texture = (assets_AssetsManager.textures.get(`turbo-btn-${speedLevel + 1}`));
        this.gs.settings.quickSpin = speedLevel;
        this.onHideTurboSetting();
        spriteIcon.scale.set(spriteIcon.scale.x);
    }
    onBtnBetUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.BET_SETTINGS).dispatch();
    }
    onBtnBetDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.BET_SETTINGS).dispatch();
    }
    onBtnAutoSpin() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.slotMachine.autoplay.enabled) {
            //this.slotMachine.autoplay.infinite = false;
            new ControlEvent(UIEvent.AUTO_SPIN).dispatch();
        }
        else {
            new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.AUTOSPIN_SETTINGS).dispatch();
        }
    }
    onShowTurboSetting() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        this.btnTurbo.visible = false;
        this.uiTurboSettingsDesktop.children.forEach((child, index) => {
            ignitionTween.Tweener.addTween(child, {
                alpha: 1,
                time: 0.3,
                transition: 'easeOutSine',
                delay: index * 0.1,
            });
        });
        // new ControlEvent(UIEvent.GAME_SPEED_LEVEL_UP).dispatch();
    }
    onHideTurboSetting() {
        this.btnTurbo.visible = true;
        this.uiTurboSettingsDesktop.children.forEach((child, index) => {
            child.alpha = 0;
        });
    }
    onBtnSpin() {
        if (this.slotMachine.autoplay.enabled) {
            //this.slotMachine.autoplay.infinite = false;
            new ControlEvent(UIEvent.AUTO_SPIN).dispatch();
            return;
        }
        if (this.slotMachine.currentState !== SlotMachineState.IDLE) {
            if (this.slotMachine.stopRequested)
                return;
            sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
            this.btnSpin.spinAnimation(view_ButtonSpinAnimation.LOOP, view_ButtonSpinAnimation.SPIN);
            new ControlEvent(SlotGameEvent.STOP_REQUESTED).dispatch();
            this.btnSpin.enabled = false;
        }
        else {
            sound_SoundManager.play({
                id: sound_SoundList.UI_BUTTON_SPIN_START,
                volume: 0.5
            });
            this.btnSpin.spinAnimation(view_ButtonSpinAnimation.LOOP, view_ButtonSpinAnimation.SPIN, false, this._config.UIMainConfiguration.buttonSpinConfig.useRotationInStartAnimation, false);
            new ControlEvent(SlotGameEvent.SPIN_START).dispatch();
            this.btnSpin.enabled = true;
        }
        this.onHideTurboSetting();
    }
    onSpaceClick(event) {
        const uiState = dependency_container_instance.resolve(UIState);
        const popupState = dependency_container_instance.resolve(PopupState);
        if (event.code === 'Space') {
            if (!uiState.activePanel && (!popupState.activePopup || popupState.activeType !== PopupType.CONNECTION_LOST)) {
                //this.onBtnSpin();
                //this.btnSpin.dispatchEvent(new Event("pointerup"));
                this.btnSpin.emit("pointerup", null);
            }
        }
    }
    updateBtnMenu() {
        const uiState = dependency_container_instance.resolve(UIState);
        if (uiState.activePanel == UIPanelType.MENU_SETTINGS) {
            this.btnMenu['normal']['icon-on'].visible = true;
            this.btnMenu['normal']['icon-off'].visible = false;
        }
        else {
            this.btnMenu['normal']['icon-on'].visible = false;
            this.btnMenu['normal']['icon-off'].visible = true;
        }
    }
    updateVolume() {
        //this.btnVolume.setInitialState(this.gs.settings.ambientMusic, this.gs.settings.soundFx)
        this.btnSound.setInitialState(this.gs.settings.soundFx ? SwitchState.ON : SwitchState.OFF);
    }
    onBtnMenu() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.MENU_SETTINGS).dispatch();
    }
    onBtnSound() {
        console.log('onBtnSound');
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        const isMute = this.btnSound.state == SwitchState.OFF;
        this.gs.settings.soundFx = !isMute;
        this.gs.saveSettings();
        sound_SoundManager.getChannel('default').mute = isMute;
        sound_SoundManager.getChannel('ambient').mute = isMute;
    }
    onBtnInfo() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.PAYTABLE).dispatch();
    }
}
var UIPanelDesktop_BackgroundType;
(function (BackgroundType) {
    BackgroundType["NORMAL"] = "main-screen-background";
    BackgroundType["FREEGAME"] = "freegame-screen-background";
    BackgroundType["BONUS"] = "bonus-screen";
})(UIPanelDesktop_BackgroundType || (UIPanelDesktop_BackgroundType = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/UIMain.ts

























class UIMain extends Container_Container {
    constructor(le, config) {
        super();
        this.pressAndHoldAutoPlayEnable = false;
        this._config = config;
        this.gs = dependency_container_instance.resolve(services_GameService);
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.btnSpin.on('pointerup', this.onBtnSpin, this);
        this.btnSpin.on('pointerdown', this.onBtnSpinPointerDown, this);
        this.btnAutoSpin.on('pointerup', this.onBtnAutoSpin, this);
        this.btnBetUp.on('pointerup', this.onBtnBetUp, this);
        //this.btnBetDown.on('pointerup', this.onBtnBetDown, this);
        this.btnInfo.on('pointerup', this.onBtnInfo, this);
        this.btnSound.on(SwitchEvent.STATE_CHANGED, this.onBtnSound, this);
        // this.btnTurboSpinEnable.on('pointerup', this.onBtnTurboSpinEnable, this);
        // this.btnTurboSpinDisable.on('pointerup', this.onBtnTurboSpinDisable, this);
        this.btnNormalTurbo.on('pointerup', this.onBtnTurboSpinEnable, this);
        this.btnFastTurbo.on('pointerup', this.onBtnTurboSpinDisable, this);
        this.btnSuperTurbo.on('pointerup', this.onBtnSuperTurbo, this);
        this.btnMenu.on('pointerup', this.onBtnMenu, this);
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.wallet
            .on(WalletEvent.NOT_ENOUGH_BALANCE, () => {
            this.btnSpin.spinAnimation(view_ButtonSpinAnimation.LOOP, view_ButtonSpinAnimation.STOP);
        }, this);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.on(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        this.slotMachine.autoplay.on(AutoplayEvent.DISABLED, this.onAutospinDisabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent.ENABLED, this.onAutospinEnabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent.SPINS_LEFT_CHANGED, this.onAutospinSpinsLeftChange, this);
        this.slotMachine.on(SlotMachineEvent.STATE_CHANGED, this.onStateChanged, this);
        // this.slotMachine.on(SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        // this.onGameSpeedLevelChanged(this.slotMachine.currentGameSpeedLevel);
        // this.uiTurboSettingsMobile.children.forEach((child) => {
        //     child.alpha = 0;
        // })
        if (!this.slotMachine.autoplay.enabled)
            this.btnSpin.waitAnimation(view_ButtonSpinAnimation.LOOP_CONTINUE);
        this.once('added', this.onAdded, this);
        this.gs = dependency_container_instance.resolve(services_GameService);
        this.gs.on(GameServiceEvent_GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateVolume();
        }, this);
        this.updateVolume();
    }
    onStateChanged(currentState, previousState) {
        if (currentState === SlotMachineState.FREE_SPINS_ROUND_START) {
            this.btnAutoSpin.visible = false;
            this.btnSpin.visible = false;
            this.btnBetUp.visible = false;
        }
        else if (this.slotMachine.currentState === SlotMachineState.FREE_SPINS_ROUND_END) {
            this.btnAutoSpin.visible = true;
            this.btnSpin.visible = true;
            this.btnBetUp.visible = true;
        }
    }
    lock() {
        // [this.btnSpin, this.btnBetUp, this.btnBetDown, this.btnTurboSpinEnable, this.btnTurboSpinDisable, this.btnMenu].forEach((btn: Button) => {
        [this.btnSpin, this.btnBetUp, this.btnAutoSpin, this.btnMenu].forEach((btn) => {
            btn.enabled = false;
        });
        if (!this.slotMachine.autoplay.enabled) {
            this.btnAutoSpin.enabled = false;
        }
        else {
            this.btnSpin.enabled = true;
        }
    }
    unlock() {
        // [this.btnSpin, this.btnBetUp, this.btnBetDown, this.btnTurboSpinEnable, this.btnTurboSpinDisable, this.btnMenu].forEach((btn: Button) => {
        // [this.btnSpin, this.btnBetUp, this.btnBetDown, this.btnMenu].forEach((btn: Button) => {
        //     btn.enabled = true;
        // });
        [this.btnSpin, this.btnBetUp, this.btnAutoSpin, this.btnMenu].forEach((btn) => {
            btn.enabled = true;
        });
        this.btnSpin.waitAnimation(view_ButtonSpinAnimation.WAIT_DELAY);
    }
    updateVolume() {
        this.btnSound.setInitialState(this.gs.settings.soundFx ? SwitchState.ON : SwitchState.OFF);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        let btn;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'ButtonSpin':
                instance = new ButtonSpin(le);
                btn = instance;
                //btn.hitArea = new Circle(0, 0, 150);
                break;
            case 'ButtonAutoSpinStop':
                break;
            case 'SwitchView':
                instance = new SwitchView(le);
                break;
            case 'ButtonAutospin':
                instance = new ButtonAutospin(le);
                btn = instance;
                // btn.hitArea = new Circle(90,90,50)
                break;
            case 'ButtonTurbo':
                instance = new Button(le);
                btn = instance;
                // btn.hitArea = new Circle(90,90,50)
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
        }
        return instance;
    }
    onAdded() {
        this.onGameSpeedLevelChanged(this.slotMachine.currentGameSpeedLevel);
        this.onAutospinSpinsLeftChange();
    }
    onBtnMenu() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.MENU_SETTINGS).dispatch();
    }
    onBtnSound() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        const isMute = this.btnSound.state == SwitchState.OFF;
        this.gs.settings.soundFx = !isMute;
        this.gs.saveSettings();
        sound_SoundManager.getChannel('default').mute = isMute;
        sound_SoundManager.getChannel('ambient').mute = isMute;
    }
    onGameSpeedLevelChanged(speedLevel) {
        this.btnNormalTurbo.visible = (speedLevel == 0);
        this.btnFastTurbo.visible = (speedLevel == 1);
        this.btnSuperTurbo.visible = (speedLevel == 2);
        //container.resolve(GameService).settings.gameSpeedLevel = speedLevel;
    }
    onAutospinDisabled() {
        //  console.log("autoplay disabled");
        if (this.slotMachine.currentState != SlotMachineState.IDLE) {
            this.btnSpin.visible = true;
            this.btnSpin.waitAnimation(view_ButtonSpinAnimation.WAIT_DELAY);
        }
    }
    onAutospinEnabled() {
        this.btnSpin.waitAnimation(view_ButtonSpinAnimation.LOOP_CONTINUE);
    }
    onAutospinSpinsLeftChange() {
        this.btnAutoSpin.autospinChange(this.slotMachine.autoplay.spinsLeft);
        this.btnSpin.setAutoPlayLeftValue(this.slotMachine.autoplay.spinsLeft);
    }
    // USER INTERACTION
    onBtnSettings() {
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.MENU_SETTINGS).dispatch();
    }
    onBtnInfo() {
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.PAYTABLE).dispatch();
    }
    onBtnSpin() {
        this.setTimeoutID && clearTimeout(this.setTimeoutID);
        if (this.slotMachine.autoplay.enabled) {
            //this.slotMachine.autoplay.infinite = false;
            new ControlEvent(UIEvent.AUTO_SPIN).dispatch();
            return;
        }
        if (this.pressAndHoldAutoPlayEnable) {
            this.pressAndHoldAutoPlayEnable = false;
        }
        if (this.slotMachine.currentState !== SlotMachineState.IDLE) {
            if (this.slotMachine.stopRequested)
                return;
            // SoundManager.play(SoundList.UI_BUTTON_SPIN_STOP);
            this.btnSpin.spinAnimation(view_ButtonSpinAnimation.LOOP, view_ButtonSpinAnimation.SPIN);
            new ControlEvent(SlotGameEvent.STOP_REQUESTED).dispatch();
            this.btnSpin.enabled = false;
        }
        else {
            sound_SoundManager.play({
                id: sound_SoundList.UI_BUTTON_SPIN_START,
            });
            this.btnSpin.spinAnimation(view_ButtonSpinAnimation.LOOP, view_ButtonSpinAnimation.SPIN, false, this._config.buttonSpinConfig.useRotationInStartAnimation, false);
            new ControlEvent(SlotGameEvent.SPIN_START).dispatch();
            this.btnSpin.enabled = true;
        }
    }
    onBtnSpinPointerDown() {
        this.setTimeoutID = setTimeout(() => {
            this.pressAndHoldAutoPlayEnable = true;
            this.setTimeoutID = undefined;
            sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
            if (this.slotMachine.autoplay.enabled) {
                new ControlEvent(UIEvent.AUTO_SPIN).dispatch();
            }
            else {
                new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.AUTOSPIN_SETTINGS).dispatch();
            }
        }, 1000);
    }
    onBtnAutoSpin() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        if (this.slotMachine.autoplay.enabled) {
            //this.slotMachine.autoplay.infinite = false;
            new ControlEvent(UIEvent.AUTO_SPIN).dispatch();
        }
        else {
            new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.AUTOSPIN_SETTINGS).dispatch();
        }
    }
    onBtnTurboSpinEnable() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIEvent.GAME_SPEED_LEVEL_UP).dispatch();
        this.slotMachine.currentGameSpeedLevel = 1;
        //this.gs.settings.quickSpin = 1;
        this.gs.saveSettings();
    }
    onBtnTurboSpinDisable() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIEvent.GAME_SPEED_LEVEL_DOWN).dispatch();
        this.slotMachine.currentGameSpeedLevel = 2;
        //this.gs.settings.quickSpin = 2;
        this.gs.saveSettings();
    }
    onBtnSuperTurbo() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIEvent.GAME_SPEED_LEVEL_DOWN).dispatch();
        this.slotMachine.currentGameSpeedLevel = 0;
        //his.gs.settings.quickSpin = 0;
        this.gs.saveSettings();
    }
    onBtnBetUp() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.BET_SETTINGS).dispatch();
    }
    onBtnBetDown() {
        sound_SoundManager.play(sound_SoundList.UI_BUTTON_CLICK);
        new ControlEvent(UIPanelEvent.OPEN_PANEL, UIPanelType.BET_SETTINGS).dispatch();
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/common/view/ui/UIPanelMobileVertical.ts



















class UIPanelMobileVertical extends AdjustableLayoutContainer {
    constructor(config) {
        super(assets_AssetsManager.layouts.get('UIPanelMobileVertical'));
        this._config = config;
        LayoutBuilder.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.baseBtnFreespinPos = {
            y: this.btnFreeSpin.y,
            x: this.btnFreeSpin.x
        };
        this.wallet = dependency_container_instance.resolve(model_Wallet);
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.on(SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
    }
    moveBtnFreespin(basePos) {
        ignitionTween.Tweener.addTween(this.btnFreeSpin, {
            x: basePos ? this.baseBtnFreespinPos.x : 540,
            y: basePos ? this.baseBtnFreespinPos.y : -664,
            time: 0.25,
            transition: 'easeInOutQuart'
        });
    }
    // PUBLIC API
    setFeatureButtonsVisibility(theme) {
        if (theme == UIPanelMobileVertical_BackgroundType.FREEGAME) {
            this.btnHoldAndSpinner.visible = this.btnDoubleChance.visible = this.heartBanner.visible = false;
            this.btnFreeSpin.visible = true;
            this.moveBtnFreespin(false);
        }
        else if (theme == UIPanelMobileVertical_BackgroundType.BONUS) {
            this.btnHoldAndSpinner.visible = this.btnDoubleChance.visible = this.btnFreeSpin.visible = false;
            this.heartBanner.visible = true;
            this.heartBanner.resetHearts(false);
        }
        else {
            this.btnHoldAndSpinner.visible = this.btnDoubleChance.visible = this.btnFreeSpin.visible = true;
            this.heartBanner.visible = false;
            this.moveBtnFreespin(true);
        }
        this.btnFreeSpin.changeState(theme);
    }
    lock() {
        this.uiMain.lock();
        [
            this.btnFreeSpin,
            this.btnDoubleChance,
            this.btnHoldAndSpinner
        ].forEach((btn) => {
            btn.enabled = false;
        });
        new ControlEvent(UIPanelEvent.CLOSE_SETTINGS).dispatch();
    }
    unlock() {
        this.uiMain.unlock();
        [
            this.btnFreeSpin,
            this.btnDoubleChance,
            this.btnHoldAndSpinner
        ].forEach((btn) => {
            btn.enabled = true;
        });
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        this.background.width = desc.currentWidth;
        this.background.x = -(desc.currentWidth - desc.baseWidth) / 2;
        if (desc.baseWidth < desc.currentWidth) {
            this.uiMain.y = this.background.y = this.statusComponent.y = 0;
        }
        else {
            this.uiMain.y = this.background.y = this.statusComponent.y = (desc.currentHeight - desc.baseHeight) / 2;
        }
    }
    // PRIVATE API
    onSlotMachineStateChanged(currentState) {
        // const sm: SlotMachine = this.slotMachine;
        // const wallet: Wallet = container.resolve(Wallet);
        // const gs: GameService = container.resolve(GameService);
        switch (currentState) {
            case SlotMachineState.SPINNING:
                break;
            case SlotMachineState.SPIN_END:
            case SlotMachineState.COMMUNICATION_ERROR:
                break;
            case SlotMachineState.SPIN_RESULT_MULTI_WIN:
                break;
            case SlotMachineState.SPIN_RESULT_SCATTER:
                break;
            case SlotMachineState.SPIN_RESULT_CASCADE:
                break;
            case SlotMachineState.SPIN_RESULT_FREE_SPINS:
                break;
            case SlotMachineState.FREE_SPINS_ROUND_START:
                break;
            case SlotMachineState.FREE_SPINS:
                break;
            case SlotMachineState.FREE_SPINS_ROUND_END:
                break;
            case SlotMachineState.IDLE:
                break;
        }
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button(le);
                break;
            case 'ValueText':
                instance = new ValueText(le);
                break;
            case 'UIMain':
                instance = new UIMain(le, this._config.UIMainConfiguration);
                break;
            case 'FreeSpinButton':
                instance = new FreeSpinButton(le);
                break;
            case 'DoubleChanceButton':
                instance = new DoubleChanceButton(le);
                break;
            case 'HoldAndSpinnerButton':
                instance = new HoldAndSpinnerButton(le);
                break;
            case 'StatusComponent':
                instance = new StatusComponent(le);
                break;
            case 'HeartBanner':
                instance = new HeartBanner(le);
                break;
        }
        return instance;
    }
}
var UIPanelMobileVertical_BackgroundType;
(function (BackgroundType) {
    BackgroundType["NORMAL"] = "main-screen-background";
    BackgroundType["FREEGAME"] = "freegame-screen-background";
    BackgroundType["BONUS"] = "bonus-screen";
})(UIPanelMobileVertical_BackgroundType || (UIPanelMobileVertical_BackgroundType = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/event/ReelsViewEvent.ts
var ReelsViewEvent;
(function (ReelsViewEvent) {
    ReelsViewEvent["WIN_ANIMATION_COMPLETE"] = "onReelsViewWinAnimationComplete";
})(ReelsViewEvent || (ReelsViewEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/event/SymbolViewEvent.ts
var SymbolViewEvent;
(function (SymbolViewEvent) {
    SymbolViewEvent["WIN_ANIMATION_LOOP"] = "onSymbolViewWinAnimationLoop";
    SymbolViewEvent["WIN_ANIMATION_COMPLETE"] = "onSymbolViewWinAnimationComplete";
})(SymbolViewEvent || (SymbolViewEvent = {}));

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/SymbolView.ts
var SymbolView_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







class SymbolView extends Container_Container {
    constructor(data) {
        super();
        this.winAnimationLoopCount = 0;
        this.winAnimationCompleteLimit = 0;
        this.originalParentInfo = {
            parent: null,
            childIndex: -1
        };
        this.isBuilt = false;
        this.data = data;
        this.staticIcon = new Sprite(this.data.staticIcon.texture);
        this.staticIcon.anchor.set(0.5, 0.5);
        this.addChild(this.staticIcon);
    }
    buildSpine() {
        var _a, _b, _c, _d;
        if (this.isBuilt)
            return;
        this.isBuilt = true;
        if (this.data.spineAnimations) {
            this.spineAnimation = new Spine(this.data.spineAnimations.skeletonData);
            this.spineAnimation.visible = false;
            this.addChild(this.spineAnimation);
            if (this.data.spineAnimations.skinName)
                this.spineAnimation.skeleton.setSkinByName(this.data.spineAnimations.skinName);
            const winAnimationName = (_a = this.data.spineAnimations) === null || _a === void 0 ? void 0 : _a.winAnimationName;
            const idleAnimationName = (_b = this.data.spineAnimations) === null || _b === void 0 ? void 0 : _b.idleAnimationName;
            const stopAnimationName = (_c = this.data.spineAnimations) === null || _c === void 0 ? void 0 : _c.stopAnimationName;
            const mixTime = (_d = this.data.spineAnimations) === null || _d === void 0 ? void 0 : _d.mixTime;
            if (mixTime > 0) {
                if ((winAnimationName && typeof winAnimationName != 'undefined') && (idleAnimationName && typeof idleAnimationName != 'undefined') && typeof winAnimationName == 'string')
                    this.spineAnimation.state.data.setMix(winAnimationName, idleAnimationName, mixTime ? mixTime : 0.15);
                if ((stopAnimationName && typeof stopAnimationName != 'undefined') && (winAnimationName && typeof winAnimationName != 'undefined') && typeof winAnimationName == 'string')
                    this.spineAnimation.state.data.setMix(stopAnimationName, winAnimationName, mixTime ? mixTime : 0.15);
            }
            this.spineAnimation.state.addListener({
                complete: (entry) => {
                    // nasty hack for faulty spine events system implementation
                    setTimeout(() => {
                        if (!entry.animation)
                            return;
                        if (entry.animation.name == stopAnimationName || entry.animation.name == idleAnimationName)
                            this.playAnimation(this.spineAnimation, idleAnimationName);
                        if (typeof winAnimationName === 'string') {
                            this.onWinAnimationLoop();
                            return;
                        }
                        if (entry.animation.name == winAnimationName[winAnimationName.length - 1]) {
                            this.onWinAnimationLoop();
                            console.log('looping animation');
                        }
                    }, 0);
                }
            });
        }
        if (this.data.spriteAnimations) {
            this.winAnimation = this.initializeAnimatedSpriteFromData(this.data.spriteAnimations.winAnimation);
            this.idleAnimation = this.initializeAnimatedSpriteFromData(this.data.spriteAnimations.idleAnimation);
            this.stopAnimation = this.initializeAnimatedSpriteFromData(this.data.spriteAnimations.stopAnimation);
            [this.winAnimation, this.idleAnimation, this.stopAnimation].forEach((animation) => {
                if (animation === null)
                    return;
                this.addChild(animation);
            });
            [this.winAnimation, this.idleAnimation].forEach((animation) => {
                animation.loop = true;
                animation.onLoop = () => {
                    this.onWinAnimationLoop();
                };
            });
        }
    }
    // PUBLIC API
    get spinIconTexture() {
        return this.data.spinIcon.texture;
    }
    get spineAnim() {
        if (!this.spineAnimation)
            this.buildSpine();
        return this.spineAnimation;
    }
    animateWin(times = 1) {
        this.buildSpine();
        this.staticIcon.visible = false;
        this.winAnimationCompleteLimit = times;
        this.winAnimationLoopCount = 0;
        this.resetAnimation(this.stopAnimation);
        //Play spine animation
        this.playAnimation(this.spineAnimation, this.data.spineAnimations.winAnimationName, times > 1);
        //Play sprite animation
        this.playAnimation(this.winAnimation);
        sound_SoundManager.play(this.data.winSound);
    }
    animateY(startOffset, endOffset, time = 0.4, delay = 0) {
        return SymbolView_awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const defaultPos = this.y;
                this.y = defaultPos + startOffset;
                ignitionTween.Tweener.addTween(this, {
                    y: defaultPos + endOffset,
                    time: time,
                    transition: 'easeOutBack',
                    delay: delay,
                    onComplete: () => {
                        resolve();
                    }
                });
            });
        });
    }
    animateLanding() {
        var _a;
        if (isMobile_isMobile.any || this.data.id < 1000)
            return;
        this.buildSpine();
        //Play spine animation
        this.playAnimation(this.spineAnimation, (_a = this.data.spineAnimations) === null || _a === void 0 ? void 0 : _a.stopAnimationName);
        //Play sprite animation
        this.playAnimation(this.stopAnimation);
        return this.data.landSound;
    }
    reset() {
        ignitionTween.Tweener.removeTweens(this);
        this.staticIcon.visible = true;
        this.winAnimationLoopCount = 0;
        this.winAnimationCompleteLimit = 1;
        //Reset spine if exists
        this.resetAnimation(this.spineAnimation);
        //Reset sprite animations if exists
        this.resetAnimation(this.stopAnimation);
        this.resetAnimation(this.winAnimation);
        this.resetAnimation(this.idleAnimation);
        if (this.originalParentInfo.parent) {
            this.swapParentKeepingGlobalPosition(this.originalParentInfo.parent, this.originalParentInfo.childIndex);
            this.originalParentInfo.parent = null;
            this.originalParentInfo.childIndex = -1;
        }
    }
    destroy(_options) {
        this.reset();
        [this.spineAnimation, this.winAnimation, this.idleAnimation, this.stopAnimation].forEach((child) => {
            if (child != null) {
                this.removeChild(child);
                child.destroy();
            }
        });
        super.destroy(_options);
    }
    reattachTo(newParent) {
        if (!this.originalParentInfo.parent) {
            this.originalParentInfo.parent = this.parent;
            this.originalParentInfo.childIndex = this.parent.children.indexOf(this) - 1;
        }
        this.swapParentKeepingGlobalPosition(newParent);
    }
    setStaticIconVisibility(visible) {
        this.staticIcon.alpha = visible ? 1 : 0;
    }
    isWinFrameEnabled() {
        if (typeof this.data.skipWinFrameAnimation === 'undefined') //Take it as default === enabled
            return true;
        return !this.data.skipWinFrameAnimation;
    }
    // PRIVATE API
    onWinAnimationLoop() {
        this.winAnimationLoopCount++;
        if (this.winAnimationCompleteLimit == this.winAnimationLoopCount) {
            this.reset();
            this.emit(SymbolViewEvent.WIN_ANIMATION_COMPLETE);
        }
        else {
            this.emit(SymbolViewEvent.WIN_ANIMATION_LOOP, this.winAnimationLoopCount);
        }
    }
    swapParentKeepingGlobalPosition(newParent, id = -1) {
        const newPosition = newParent.toLocal(new Point(0, 0), this);
        this.position.set(newPosition.x, newPosition.y);
        this.removeChild(this.parent);
        id === -1 ? newParent.addChild(this) : newParent.addChildAt(this, id);
    }
    playAnimation(animation, animationName = '', loop = false) {
        if (animation === null)
            return;
        if (animation instanceof AnimatedSprite) {
            animation.visible = true;
            animation.loop = loop;
            animation.gotoAndPlay(0);
        }
        else if (animation instanceof Spine) {
            if (dependency_container_instance.resolve(SlotMachine).currentGameSpeedLevel == 1 && Array.isArray(animation)) {
                if (animation.find((animation) => {
                    animation.name === 'destroy';
                })) {
                    const name = animation.find((animation) => {
                        animation.name === 'destroy';
                    });
                    animation.visible = true;
                    animation.state.setAnimation(0, name, loop);
                    return;
                }
            }
            if (typeof animationName === 'string') {
                if (!animation.skeleton.data.animations.find((animation) => animation.name === animationName) && animationName.length <= 0)
                    return;
                animation.visible = true;
                animation.state.setAnimation(0, animationName, loop);
            }
            else {
                for (let i = 0; i < animationName.length; i++) {
                    if (!animation.skeleton.data.animations.find((animation) => animation.name === animationName[i]) && animationName[i].length <= 0)
                        return;
                }
                animation.visible = true;
                const sm = dependency_container_instance.resolve(SlotMachine);
                if (sm.currentGameSpeedLevel != 0) {
                    animation.state.setAnimation(0, animationName[animationName.length - 1], false);
                    return;
                }
                for (let j = 0; j < animationName.length; j++) {
                    if (j == 0)
                        animation.state.setAnimation(0, animationName[0], false);
                    else
                        animation.state.addAnimation(0, animationName[j], false, animation.skeleton.data.animations.find((animation) => animation.name === animationName[j - 1]).duration);
                }
            }
        }
    }
    resetAnimation(animation) {
        if (animation === null)
            return;
        if (animation instanceof AnimatedSprite) {
            animation.visible = false;
            animation.gotoAndStop(0);
        }
        else if (animation instanceof Spine) {
            animation.visible = false;
            animation.state.setEmptyAnimations(0);
            animation.skeleton.setToSetupPose();
        }
    }
    initializeAnimatedSpriteFromData(animationData) {
        if (!animationData)
            return;
        const animation = new AnimatedSprite(animationData.animationTextures);
        animation.animationSpeed = animationData.fps / 60;
        animation.gotoAndStop(0);
        animation.visible = false;
        animation.anchor.set(0.5, 0.5);
        return animation;
    }
}

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/ReelView.ts
var ReelView_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









class ReelView extends Container_Container {
    constructor(le, config) {
        super();
        this.gameSpeedLevel = 0;
        this.fallingCascade = false;
        this.spinSound = null;
        this.anticipationSound = null;
        LayoutBuilder.create(le, this);
        this.reelIndex = config.index;
        this.spinContainer.mask = this.reelMask;
        this.reel = config.reelDescription;
        this.symbols = config.symbol;
        this.symbolSize = config.symbolSize;
        this.mainStripe = new Container_Container();
        this.spinContainer.addChild(this.mainStripe);
        this.spinStripe1 = new Container_Container();
        this.spinStripe1.y = 1000;
        this.spinContainer.addChild(this.spinStripe1);
        this.spinStripe2 = new Container_Container();
        this.spinStripe2.y = 1000;
        this.spinContainer.addChild(this.spinStripe2);
        if (this.anticipationAnimation)
            this.anticipationAnimation.alpha = 0;
        this.output = [];
        //set output from login response
        if (config.restoredResult)
            this.output = config.restoredResult;
        else {
            for (let i = 0; i < this.reel.numRows; i++) {
                this.output.push(randomArrayElement(this.reel.availableSymbols));
            }
        }
        this.fallingCascade = config.fallingCascade;
        this.animationConfig = {
            startTiltSize: config.reelAnimationConfig.startTiltSize,
            cascadeTime: config.reelAnimationConfig.cascadeTime,
            blurSpinTime: config.reelAnimationConfig.blurSpinTime
        };
        this
            .on('added', this.onAdded, this)
            .on('removed', this.onRemoved, this);
    }
    // PUBLIC API
    spin(gameSpeedLevel = 0, startDelay = 0, spinSound = null, gameSpeedOption) {
        this.reset();
        this.gameSpeedLevel = gameSpeedLevel;
        const startTiltTime = gameSpeedOption.spin.tilt ? gameSpeedOption.spin.tilt : 0;
        ignitionTween.Tweener.addTween(this.mainStripe, {
            y: gameSpeedOption.spin.tilt ? -this.symbolSize.y - this.animationConfig.startTiltSize : -this.symbolSize.y,
            time: startTiltTime,
            transition: 'easeOutQuad',
            delay: startDelay,
            onComplete: () => {
                if (spinSound) {
                    this.spinSound = sound_SoundManager.loop(spinSound);
                }
            }
        });
        ignitionTween.Tweener.addTween(this.mainStripe, {
            y: this.symbolSize.y * (this.reel.numRows + 1),
            time: gameSpeedOption.spin.time,
            transition: 'easeInSine',
            delay: startTiltTime + startDelay
        });
        this.spinStripe1.y = -this.spinStripe1.height * 2;
        this.spinStripe2.y = -this.spinStripe2.height * 2;
        this.spinContainer.addChild(this.spinStripe1);
        this.spinContainer.addChild(this.spinStripe2);
        this.spinBlur(this.spinStripe1, startTiltTime + 0.1 + startDelay);
    }
    stop(output, stopSound = null, gameSpeedOption) {
        return ReelView_awaiter(this, void 0, void 0, function* () {
            ignitionTween.Tweener.removeTweens(this.mainStripe);
            ignitionTween.Tweener.removeTweens(this.spinStripe1);
            ignitionTween.Tweener.removeTweens(this.spinStripe2);
            this.output = output;
            const stopTime = gameSpeedOption.stop.time;
            return new Promise((resolve) => {
                ignitionTween.Tweener.addTween(this.spinStripe1, {
                    y: this.symbolSize.y * (this.reel.numRows + 1),
                    time: stopTime,
                    transition: 'easeOutQuad',
                });
                ignitionTween.Tweener.addTween(this.spinStripe2, {
                    y: this.symbolSize.y * (this.reel.numRows + 1),
                    time: stopTime,
                    transition: 'easeOutQuad'
                });
                this.buildMainStripe(this.output.slice());
                this.mainStripe.y = -this.mainStripe.height - this.symbolSize.y;
                const fellPromises = [];
                const fallingCascadeLandAnimationTime = 0.03;
                const finalStopTime = (this.gameSpeedLevel == 0 && this.fallingCascade) ? ((this.visibleSymbols.length + 1) * fallingCascadeLandAnimationTime) : 0.15;
                ignitionTween.Tweener.addTween(this.mainStripe, {
                    // y: this.gameSpeedLevel == 0 ? -this.symbolSize.y + this.startTiltSize:-this.symbolSize.y,
                    y: this.fallingCascade ? -this.symbolSize.y : gameSpeedOption.stop.tilt ? -this.symbolSize.y + this.animationConfig.startTiltSize : -this.symbolSize.y + (this.animationConfig.startTiltSize / 3),
                    time: stopTime,
                    transition: 'easeOutQuad',
                    onStart: () => {
                        if (this.fallingCascade) {
                            this.visibleSymbols.forEach((symbol, index) => {
                                fellPromises.push(symbol.animateY(-300, 0, this.gameSpeedLevel == 0 ? stopTime : 0.01, (this.gameSpeedLevel == 0 ? (this.visibleSymbols.length - (index + 1)) * fallingCascadeLandAnimationTime : 0)));
                            });
                        }
                    }
                });
                Promise.all(fellPromises).then(() => {
                    ignitionTween.Tweener.addTween(this.mainStripe, {
                        y: -this.symbolSize.y,
                        time: finalStopTime,
                        transition: 'easeInOutQuad',
                        delay: stopTime,
                        onStart: () => {
                            if (this.spinSound) {
                                this.spinSound.stop();
                                this.spinSound = null;
                            }
                            this.visibleSymbols.forEach((symbol) => {
                                const landSound = symbol.animateLanding();
                                if (landSound) {
                                    sound_SoundManager.play(landSound);
                                }
                            });
                            if (stopSound) {
                                sound_SoundManager.play(stopSound);
                            }
                        },
                        onComplete: () => {
                            this.anticipationVisibility(0);
                            this.spinContainer.removeChild(this.spinStripe1);
                            this.spinContainer.removeChild(this.spinStripe2);
                            resolve();
                        }
                    });
                });
            });
        });
    }
    anticipationVisibility(value, delay = 0, anticipationSound = null) {
        if (!this.anticipationAnimation)
            return;
        ignitionTween.Tweener.removeTweens(this.anticipationAnimation);
        ignitionTween.Tweener.addTween(this.anticipationAnimation, {
            alpha: value,
            delay: delay,
            time: 0.15,
            transition: 'easeOutSine',
            onStart: () => {
                if (value === 1) {
                    this.anticipationAnimation.gotoAndPlay(0);
                    this.anticipationAnimation.visible = true;
                    this.anticipationSound = sound_SoundManager.play(anticipationSound);
                }
            },
            onComplete: () => {
                if (value === 0) {
                    this.anticipationAnimation.stop();
                    this.anticipationAnimation.visible = false;
                    if (this.anticipationSound)
                        this.anticipationSound.stop();
                }
            }
        });
    }
    get numRows() {
        return this.reel.numRows;
    }
    getVisibleSymbols() {
        return [...this.visibleSymbols];
    }
    getMainStripe() {
        return this.mainStripe;
    }
    changeSymbolVisiblity(symbolIndex, visible, transitionTime = 0) {
        // this.mainStripe.cacheAsBitmap = false;
        const symbol = this.visibleSymbols[symbolIndex];
        ignitionTween.Tweener.addTween(symbol, {
            alpha: visible ? 1 : 0,
            time: transitionTime,
            onComplete: () => {
                symbol.visible = visible;
            }
        });
        // this.mainStripe.cacheAsBitmap = true;
    }
    cascade(symbolDisappearPattern, targetOutput) {
        return ReelView_awaiter(this, void 0, void 0, function* () {
            this.reset();
            // make symbols disappear
            const destroyedSymbols = [];
            for (let i = 0; i < symbolDisappearPattern.length; i++) {
                if (symbolDisappearPattern[i]) {
                    const destroyedSymbol = this.visibleSymbols[i];
                    this.mainStripe.removeChild(destroyedSymbol);
                    destroyedSymbols.push(destroyedSymbol);
                }
            }
            destroyedSymbols.forEach((s) => {
                removeArrayElement(this.visibleSymbols, s);
                s.destroy();
            });
            // create missing symbols on top
            const numMissingSymbols = targetOutput.length - this.visibleSymbols.length;
            for (let i = numMissingSymbols - 1; i >= 0; i--) {
                const symbolX = Math.floor(this.symbolSize.x / 2);
                const symbolY = (i - numMissingSymbols) * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
                const symbolData = this.symbols.get(targetOutput[i]);
                const symbolView = new SymbolView(symbolData);
                symbolView.position.set(symbolX, symbolY);
                this.mainStripe.addChildAt(symbolView, 0);
                this.visibleSymbols.unshift(symbolView);
            }
            // drop symbols down
            return new Promise((resolve) => {
                let cascading = false;
                this.visibleSymbols.forEach((symbol, index) => {
                    const targetSymbolY = (index + 1) * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
                    if (symbol.y != targetSymbolY) {
                        cascading = true;
                        ignitionTween.Tweener.addTween(symbol, {
                            y: targetSymbolY,
                            time: this.animationConfig.cascadeTime,
                            transition: 'easeInOutQuad'
                        });
                    }
                });
                if (cascading) {
                    ignitionTween.Tweener.addCaller(this, {
                        count: 1,
                        time: this.animationConfig.cascadeTime,
                        onComplete: () => {
                            resolve();
                        }
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    reset() {
        ignitionTween.Tweener.removeTweens(this.mainStripe);
        ignitionTween.Tweener.removeTweens(this.spinStripe1);
        ignitionTween.Tweener.removeTweens(this.spinStripe2);
        for (const s of this.visibleSymbols) {
            s.off(SymbolViewEvent.WIN_ANIMATION_COMPLETE);
            s.reset();
        }
    }
    swapSymbol(symbolInReelId, symbol, transitionTime = 0, delayTime = 0, transitionSound = null) {
        return ReelView_awaiter(this, void 0, void 0, function* () {
            const oldSymbol = this.visibleSymbols[symbolInReelId];
            return new Promise((resolve) => {
                this.visibleSymbols[symbolInReelId] = symbol;
                symbol.parent = oldSymbol.parent;
                symbol.originalParentInfo = oldSymbol.originalParentInfo;
                symbol.position = oldSymbol.position;
                symbol.alpha = 0;
                this.mainStripe.addChildAt(symbol, this.mainStripe.getChildIndex(oldSymbol) + 1);
                ignitionTween.Tweener.addTween(symbol, {
                    alpha: 1,
                    time: transitionTime,
                    delay: delayTime,
                    onStart: () => {
                        if (transitionSound) {
                            sound_SoundManager.play(transitionSound.id);
                        }
                    },
                    onComplete: () => {
                        oldSymbol.visible = false;
                        this.mainStripe.removeChildAt(this.mainStripe.getChildIndex(oldSymbol));
                        oldSymbol.destroy();
                        resolve();
                    }
                });
            });
        });
    }
    pullReel(newResult, pullSpeed, offsetY = 0) {
        return ReelView_awaiter(this, void 0, void 0, function* () {
            this.reset();
            return new Promise((resolve) => {
                const oldSymbols = [...this.visibleSymbols];
                const lastSymbolPos = this.mainStripe.children[this.mainStripe.children.length - 1].y;
                // create new Container to keep new symbols
                const newStripe = new Container_Container();
                this.addChild(newStripe);
                newStripe.position.y = lastSymbolPos;
                // create new symbols
                newResult.forEach((number, index) => {
                    const symbolX = Math.floor(this.symbolSize.x / 2);
                    const symbolY = this.symbolSize.y * (index + 1) + Math.floor(this.symbolSize.x / 2);
                    const symbolData = this.symbols.get(number);
                    let newSymbol;
                    if (symbolData.specialViewClass) {
                        newSymbol = new symbolData.specialViewClass(symbolData, this.reelIndex, index);
                    }
                    else {
                        newSymbol = new SymbolView(symbolData);
                    }
                    newSymbol.position.set(symbolX, symbolY);
                    // add new symbols
                    newStripe.addChild(newSymbol);
                    this.visibleSymbols.push(newSymbol);
                });
                // move new and old stripes up
                ignitionTween.Tweener.addTween(this.mainStripe, {
                    y: -(this.symbolSize.y * (this.reel.numRows + 1) + offsetY),
                    time: pullSpeed,
                    transition: 'easeInSine',
                });
                ignitionTween.Tweener.addTween(newStripe, {
                    y: -(this.symbolSize.y * (this.reel.numRows + 1) + Math.floor(this.symbolSize.x / 2) - newStripe.y),
                    time: pullSpeed,
                    transition: 'easeInSine',
                    onComplete: () => {
                        // destroy old symbols
                        oldSymbols.forEach((symbol) => {
                            this.mainStripe.removeChild(symbol);
                            removeArrayElement(this.visibleSymbols, symbol);
                            symbol.destroy();
                        });
                        // set empty mainStripe's pos to same pos as new created
                        this.mainStripe.y = newStripe.y;
                        // reattach all symbols from newStripe to mainStripe
                        while (newStripe.children.length > 0) {
                            const child = newStripe.children[0];
                            this.mainStripe.addChild(child);
                            newStripe.removeChild(child);
                        }
                        this.removeChild(newStripe);
                        newStripe.destroy();
                        resolve();
                    }
                });
            });
        });
    }
    // PRIVATE API
    onAdded() {
        this.buildSpinStripe(this.spinStripe1, this.output.length + 2);
        this.buildSpinStripe(this.spinStripe2, this.output.length + 2);
        this.buildMainStripe(this.output.slice());
        this.mainStripe.y = -this.symbolSize.y;
    }
    onRemoved() {
        // implement in derived class if needed
    }
    buildMainStripe(output) {
        // this.mainStripe.cacheAsBitmap = false;
        if (!this.fallingCascade) {
            output.push(randomArrayElement(this.reel.availableSymbols));
            output.unshift(randomArrayElement(this.reel.availableSymbols));
        }
        // clear stripe
        this.visibleSymbols = [];
        while (this.mainStripe.children.length) {
            const symbolIcon = this.mainStripe.removeChildAt(0);
            symbolIcon.destroy();
        }
        for (let i = 0; i < output.length; i++) {
            const symbolData = this.symbols.get(output[i]);
            const symbolX = Math.floor(this.symbolSize.x / 2);
            const symbolY = (i + (this.fallingCascade ? 1 : 0)) * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
            if ((i == 0 || i == this.reel.numRows + 1) && !this.fallingCascade) {
                // build additional textures
                const symbolSprite = new Sprite(symbolData.staticIcon.texture);
                symbolSprite.pivot.set(Math.floor(symbolSprite.width / 2), Math.floor(symbolSprite.height / 2));
                symbolSprite.position.set(symbolX, symbolY);
                this.mainStripe.addChild(symbolSprite);
            }
            else {
                // build main SymbolViews
                let symbolView;
                if (symbolData.specialViewClass) {
                    symbolView = new symbolData.specialViewClass(symbolData, this.reelIndex, i);
                }
                else {
                    symbolView = new SymbolView(symbolData);
                }
                symbolView.position.set(symbolX, symbolY);
                this.mainStripe.addChild(symbolView);
                this.visibleSymbols.push(symbolView);
            }
        }
        // this.mainStripe.cacheAsBitmap = true;
    }
    buildSpinStripe(parent, stripeLength) {
        var _a, _b, _c;
        const symbols = [];
        let spinSymbols = this.reel.availableSymbols;
        // on feature all blur icons should be picked from description availableSymbols
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (((_b = (_a = sm.previousRoundResult) === null || _a === void 0 ? void 0 : _a.spins[0]) === null || _b === void 0 ? void 0 : _b.bonus) && ((_c = sm.description.bonusGames) === null || _c === void 0 ? void 0 : _c.reel.reels[0].availableSymbols))
            spinSymbols = dependency_container_instance.resolve(SlotMachine).description.bonusGames.reel.reels[0].availableSymbols;
        while (symbols.length != stripeLength) {
            symbols.push(randomArrayElement(spinSymbols));
        }
        while (parent.children.length < symbols.length) {
            parent.addChild(new Sprite());
        }
        for (let i = 0; i < symbols.length; i++) {
            const symbolId = symbols[i];
            if (!this.symbols.has(symbolId)) {
                throw new Error(`No SymbolData with id: ${symbolId}`);
            }
            let texture = this.symbols.get(symbolId).staticIcon.texture;
            const symbolData = this.symbols.get(symbolId);
            if (blur && symbolData.spinIcon) {
                if (symbolData.specialViewClass) {
                    const dummySymbol = new symbolData.specialViewClass(symbolData);
                    texture = dummySymbol.spinIconTexture;
                    dummySymbol.destroy();
                }
                else {
                    texture = symbolData.spinIcon.texture;
                }
            }
            const symbolSprite = parent.getChildAt(i);
            symbolSprite.texture = texture;
            symbolSprite.pivot.set(Math.floor(symbolSprite.width / 2), Math.floor(symbolSprite.height / 2));
            symbolSprite.x = Math.floor(this.symbolSize.x / 2);
            symbolSprite.y = i * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
            // container.addChild(symbolSprite);
        }
    }
    spinBlur(blurStripe, startDelay = 0, startPosition = null) {
        //this.buildSpinStripe(blurStripe, this.output.length + 2);
        if (startPosition === null) {
            blurStripe.y = -blurStripe.height - this.symbolSize.y;
        }
        else {
            blurStripe.y = startPosition;
        }
        let trackPosition = true;
        ignitionTween.Tweener.addTween(blurStripe, {
            y: this.symbolSize.y * (this.reel.numRows + 1),
            time: this.animationConfig.blurSpinTime,
            transition: 'linear',
            delay: startDelay,
            onUpdate: () => {
                if (blurStripe.y > -this.symbolSize.y && trackPosition) {
                    trackPosition = false;
                    if (blurStripe == this.spinStripe1) {
                        this.spinBlur(this.spinStripe2, 0, blurStripe.y - this.spinStripe2.height);
                    }
                    else {
                        this.spinBlur(this.spinStripe1, 0, blurStripe.y - this.spinStripe1.height);
                    }
                }
            }
        });
    }
}
ReelView.defaultReelAnimationConfiguration = {
    startTiltSize: 60,
    blurSpinTime: 0.5,
    cascadeTime: 0.4
};
/* harmony default export */ const view_ReelView = (ReelView);

;// CONCATENATED MODULE: ./src/ignition-interactive/slots/view/ReelsView.ts
var ReelsView_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};












class ReelsView extends Container_Container {
    constructor(le, reelSetDescription, symbols, reelConfiguration = ReelsView.defaultReelConfiguration) {
        super();
        this.reelViews = [];
        this.symbols = new Map();
        this.gameSpeedLevel = 0;
        this.symbolWinAnimations = [];
        this.winFrameAnimations = [];
        this.anticipationDelay = 0;
        reelConfiguration = Object.assign(Object.assign({}, ReelsView.defaultReelConfiguration), reelConfiguration);
        this.reelSetDescription = reelSetDescription;
        this.reelConfiguration = reelConfiguration;
        for (const symbol of symbols) {
            this.symbols.set(symbol.id, symbol);
        }
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.reelsContainer.mask = this.reelsMask;
        if (this.symbolAnimationContainerMask) {
            this.symbolAnimationContainer.mask = this.symbolAnimationContainerMask;
        }
        const winFrameAnimation = this.reelConfiguration.winFrameAnimation;
        if (winFrameAnimation) {
            if ('animationPrefix' in winFrameAnimation) {
                winFrameAnimation.animationTextures = assets_AssetsManager.getAnimationTextures(winFrameAnimation.animationPrefix);
            }
            for (let i = 0; i < this.reelViews.length; i++) {
                const rv = this.reelViews[i];
                this.winFrameAnimations.push([]);
                for (let j = 0; j < rv.numRows; j++) {
                    const winFrameAnimatedSprite = new AnimatedSprite(winFrameAnimation.animationTextures);
                    winFrameAnimatedSprite.animationSpeed = winFrameAnimation.fps / 60;
                    winFrameAnimatedSprite.anchor.set(0.5, 0.5);
                    winFrameAnimatedSprite.gotoAndStop(0);
                    winFrameAnimatedSprite.loop = true;
                    winFrameAnimatedSprite.visible = false;
                    this.winFrameAnimations[i].push(winFrameAnimatedSprite);
                    this.winFrameAnimationContainer.addChild(winFrameAnimatedSprite);
                }
            }
        }
    }
    // PUBLIC API
    spin(gameSpeedLevel, soundData, gameSpeedLevelOption) {
        this.reset();
        this.gameSpeedLevel = gameSpeedLevel;
        this.reelViews.forEach((reelView, index) => {
            reelView.spin(this.gameSpeedLevel, (this.reelConfiguration.fallingCascade && gameSpeedLevelOption.spin.delayPerReel) ? (gameSpeedLevelOption.spin.delayPerReel * index) : 0, soundData, gameSpeedLevelOption);
        });
        new ControlEvent(SlotGameEvent.REELS_STARTED).dispatch();
        if (gameSpeedLevelOption.stop.delay) {
            ignitionTween.Tweener.addCaller(this, {
                count: 1,
                time: gameSpeedLevelOption.stop.delay,
                onComplete: () => {
                    new ControlEvent(SlotGameEvent.SPIN_TIME_LAPSED).dispatch();
                }
            });
        }
        else {
            new ControlEvent(SlotGameEvent.SPIN_TIME_LAPSED).dispatch();
        }
    }
    stop(output, sounds, gameSpeedLevel = -1, anticipationReelIds = null, gameSpeedOption) {
        return ReelsView_awaiter(this, void 0, void 0, function* () {
            console.log(output);
            if (gameSpeedLevel != -1) {
                this.gameSpeedLevel = gameSpeedLevel;
            }
            this.anticipationDelay = 0;
            const stopPromises = [];
            for (let i = 0; i < output.length; i++) {
                const triggerAnticipation = (anticipationReelIds && anticipationReelIds.length > 0 && anticipationReelIds.includes(i));
                stopPromises.push(this.stopReel(i, output[i], sounds, triggerAnticipation, gameSpeedOption));
            }
            yield Promise.all(stopPromises);
        });
    }
    animateWins(symbolPattern, times = 1, visibleOnComplete = true) {
        // const sm: SlotMachine = container.resolve(SlotMachine);
        for (let i = 0; i < symbolPattern.length; i++) {
            const reelView = this.reelViews[i];
            const reelPattern = symbolPattern[i];
            const visibleSymbols = reelView.getVisibleSymbols();
            for (let j = 0; j < reelPattern.length; j++) {
                if (reelPattern[j]) {
                    const symbol = visibleSymbols[j];
                    this.symbolWinAnimations.push(symbol);
                    // //Select proper symbol to attach symbol on.
                    const symbolNewParent = this.symbolAnimationContainer;
                    symbol.reattachTo(symbolNewParent);
                    symbol.once(SymbolViewEvent.WIN_ANIMATION_COMPLETE, () => {
                        symbol.setStaticIconVisibility(visibleOnComplete);
                        symbol.reset();
                        this.resetWinFrameAnimation(i, j);
                        removeArrayElement(this.symbolWinAnimations, symbol);
                        if (!this.symbolWinAnimations.length) {
                            this.emit(ReelsViewEvent.WIN_ANIMATION_COMPLETE);
                        }
                    });
                    symbol.animateWin(times);
                    if (!symbol.isWinFrameEnabled())
                        continue;
                    // show win frame if any
                    if (this.winFrameAnimations.length) {
                        const winFrameAnimation = this.winFrameAnimations[i][j];
                        winFrameAnimation.position.set(symbol.x, symbol.y);
                        winFrameAnimation.play();
                        winFrameAnimation.visible = true;
                    }
                }
            }
        }
    }
    cascade(symbolDisappearPattern, targetOutput) {
        return ReelsView_awaiter(this, void 0, void 0, function* () {
            const cascadePromises = [];
            for (let i = 0; i < symbolDisappearPattern.length; i++) {
                cascadePromises.push(this.reelViews[i].cascade(symbolDisappearPattern[i], targetOutput[i]));
            }
            yield Promise.all(cascadePromises);
        });
    }
    reset() {
        for (const symbol of this.symbolWinAnimations) {
            symbol.off(SymbolViewEvent.WIN_ANIMATION_COMPLETE);
            symbol.reset();
        }
        this.symbolWinAnimations = [];
        if (this.winFrameAnimations.length) {
            for (let i = 0; i < this.reelViews.length; i++) {
                const rv = this.reelViews[i];
                for (let j = 0; j < rv.numRows; j++) {
                    this.resetWinFrameAnimation(i, j);
                }
            }
        }
    }
    getReelViews() {
        return [...this.reelViews];
    }
    // PRIVATE API
    customClassElementCreate(le) {
        const sm = dependency_container_instance.resolve(SlotMachine);
        let instance = null;
        switch (le.customClass) {
            case 'ReelView':
                const reelDescription = this.reelSetDescription.reels[this.reelViews.length];
                const reelResult = sm.currentSpinResult.result[this.reelViews.length];
                const reelInitConfig = {
                    reelDescription: reelDescription,
                    symbol: this.symbols,
                    symbolSize: this.reelConfiguration.symbolSize,
                    fallingCascade: this.reelConfiguration.fallingCascade,
                    restoredResult: reelResult,
                    index: this.reelViews.length,
                    reelAnimationConfig: this.reelConfiguration.reelAnimationConfig
                };
                instance = new view_ReelView(le, reelInitConfig);
                this.reelViews.push(instance);
                break;
        }
        return instance;
    }
    stopReel(index, output, sounds, anticipation, gameSpeedOption) {
        return ReelsView_awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const rv = this.reelViews[index];
                let stopDelay = (this.reelConfiguration.fallingCascade && gameSpeedOption.stop.delayPerReel) ? index * gameSpeedOption.stop.delayPerReel : 0;
                if (anticipation && this.gameSpeedLevel === 0) {
                    rv.anticipationVisibility(1, stopDelay + this.anticipationDelay, sounds.anticipationSoundData);
                    this.anticipationDelay += (stopDelay + this.reelConfiguration.anticipationTime);
                }
                stopDelay += this.anticipationDelay;
                ignitionTween.Tweener.addTween(rv, {
                    time: stopDelay,
                    onComplete: () => {
                        rv.stop(output, sounds.stopSoundData, gameSpeedOption)
                            .then(() => {
                            resolve();
                        });
                    }
                });
            });
        });
    }
    resetWinFrameAnimation(indexX, indexY) {
        if (!this.winFrameAnimations || this.winFrameAnimations.length === 0)
            return;
        const winFrameAnimation = this.winFrameAnimations[indexX][indexY];
        winFrameAnimation.gotoAndStop(0);
        winFrameAnimation.visible = false;
    }
}
ReelsView.defaultReelConfiguration = {
    symbolSize: new Point(212, 212),
    winFrameAnimation: null,
    anticipationTime: 0,
    fallingCascade: false,
    reelAnimationConfig: view_ReelView.defaultReelAnimationConfiguration
};
/* harmony default export */ const view_ReelsView = (ReelsView);

;// CONCATENATED MODULE: ./src/the-miner/model/MultiplierEvent.ts
var MultiplierEvent;
(function (MultiplierEvent) {
    MultiplierEvent["ON_INITIALIZED_MULTIPLIER_SYMBOLS"] = "onInitializeMultiplierSymbols";
    MultiplierEvent["ON_MULTIPLIER_ANIMATION_END"] = "onMultiplierAnimationEnd";
    MultiplierEvent["ON_TOTAL_MULTIPLIER_ANIMATION_END"] = "onTotalMultiplierAnimationEnd";
    MultiplierEvent["ON_ALL_MULTIPLIER_ANIMATION_END"] = "onAllMultiplierAnimationEnd";
})(MultiplierEvent || (MultiplierEvent = {}));

;// CONCATENATED MODULE: ./src/the-miner/view/Character.ts




class Character extends Container_Container {
    constructor() {
        super();
        this.animationChances = [
            {
                animation: 'idle',
                chance: 100,
            }
        ];
        this.totalChances = 0;
        const asset = assets_AssetsManager.spine.get('character');
        this.spine = new Spine(asset);
        this.addChild(this.spine);
        this.spine.state.addListener({
            complete: (entry) => {
                const result = randomInt(1, this.totalChances);
                let counter = 0;
                let animationName;
                for (const ac of this.animationChances) {
                    counter += ac.chance;
                    if (result <= counter) {
                        animationName = ac.animation;
                        break;
                    }
                }
                this.spine.state.setAnimation(0, animationName, false);
            }
        });
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        this.spine.state.setEmptyAnimations(0);
        this.spine.state.setAnimation(0, 'idle', false);
    }
    playWinAnimation() {
        this.spine.state.setAnimation(0, 'win', false);
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/MultiplierCell.ts
var MultiplierCell_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class MultiplierCell extends Container_Container {
    constructor(le) {
        super();
        LayoutBuilder.create(le, this);
    }
    deactivate() {
        if (this.activatedView.visible == false) {
            return;
        }
        this.disabledView.visible = true;
        this.activatedView.visible = false;
    }
    activate(animate = true) {
        return MultiplierCell_awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                if (this.activatedView.visible == true) {
                    resolve();
                    return;
                }
                if (!animate) {
                    this.activatedView.visible = true;
                    this.disabledView.visible = false;
                    resolve();
                    return;
                }
                ignitionTween.Tweener.removeTweens(this.activatedView);
                ignitionTween.Tweener.addTween(this.activatedView.scale, {
                    onStart: () => {
                        this.activatedView.visible = true;
                        this.disabledView.visible = false;
                    },
                    x: 1.3,
                    y: 1.3,
                    time: 0.4,
                    onComplete: () => {
                        ignitionTween.Tweener.addTween(this.activatedView.scale, {
                            x: 1,
                            y: 1,
                            time: 0.4,
                            onComplete: () => resolve()
                        });
                    }
                });
            });
        });
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/FreespinMultiplierBoard.ts
var FreespinMultiplierBoard_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





class FreespinMultiplierBoard extends Container_Container {
    constructor(le) {
        super();
        this.multiplierCellsArr = [];
        this.bonusArr = [];
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        for (let i = 0; this['multiplier' + i]; i++) {
            const m = this['multiplier' + i];
            this.multiplierCellsArr.push(m);
        }
        this.multiplierCellsArr.splice(3, 0, this.bonusx2);
        this.multiplierCellsArr.splice(7, 0, this.bonusx3);
        this.multiplierCellsArr.push(this.bonusx10);
        this.currentValueOn = 0;
        this.deactivateCells();
    }
    restore() {
        var _a;
        this.currentValueOn = (_a = dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.collectedCount) !== null && _a !== void 0 ? _a : 0;
        if (this.currentValueOn > 12) {
            this.currentValueOn = 12;
        }
        if (dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.toCollect && this.currentValueOn != 0)
            this.currentValueOn--;
        for (let i = 0; i < this.currentValueOn; i++) {
            this.multiplierCellsArr[i].activate(false);
        }
    }
    update() {
        return FreespinMultiplierBoard_awaiter(this, void 0, void 0, function* () {
            if (this.currentValueOn == 12) {
                return;
            }
            this.currentValueOn += 1;
            yield this.multiplierCellsArr[this.currentValueOn - 1].activate();
            this.updateBonuses();
        });
    }
    getNextCell() {
        // multiplier should move to each cell position
        if (this.currentValueOn < 0 || this.currentValueOn >= this.multiplierCellsArr.length) {
            console.warn(`FreespinMultiplierBoard.getNextCell: currentValueOn (${this.currentValueOn}) is out of bounds for multiplierCellsArr (length: ${this.multiplierCellsArr.length})`);
            return null;
        }
        return this.multiplierCellsArr[this.currentValueOn];
    }
    deactivateCells() {
        this.multiplierCellsArr.forEach((cell) => {
            cell.deactivate();
        });
        this.bonusArr.forEach((cell) => {
            cell.deactivate();
        });
        this.currentValueOn = 0;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'MultiplierCell':
                instance = new MultiplierCell(le);
                break;
        }
        return instance;
    }
    updateBonuses() {
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (sm.roundResult.holdAndSpinnerMultiplierMap.featureMultiplier == 1) {
            this.bonusArr.forEach((bonus) => {
                bonus.deactivate();
            });
        }
        else if (sm.roundResult.holdAndSpinnerMultiplierMap.featureMultiplier == 2) {
            this.bonusx2.activate();
        }
        else if (sm.roundResult.holdAndSpinnerMultiplierMap.featureMultiplier == 3) {
            this.bonusx3.activate();
        }
        else if (sm.roundResult.holdAndSpinnerMultiplierMap.featureMultiplier == 10) {
            this.bonusx10.activate();
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/strategies/animation/MultiplierAnimationStrategy.ts
var MultiplierAnimationStrategy_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class BaseMultiplierAnimationStrategy {
    animate(target, time, delay = 0, data) {
        return MultiplierAnimationStrategy_awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                const { translation, scale } = data;
                Tweener.addTween(target, {
                    x: translation.x,
                    time,
                    delay,
                    transition: 'linear'
                });
                Tweener.addTween(target, {
                    y: translation.y,
                    time,
                    delay,
                    transition: 'easeOutSine'
                });
                Tweener.addCaller(target, {
                    count: 1,
                    time,
                    onComplete: () => resolve()
                });
            });
        });
    }
}
class FreespinMultiplierAnimationStrategy {
    animate(target, time, delay, data, scaleDown = false) {
        return MultiplierAnimationStrategy_awaiter(this, void 0, void 0, function* () {
            return yield new Promise(resolve => {
                const { translation, scale } = data;
                ignitionTween.Tweener.addTween(target.scale, {
                    x: scale.x,
                    y: scale.y,
                    time: time / 4,
                    delay: delay,
                    transition: 'easeOut',
                    onComplete: () => {
                        ignitionTween.Tweener.addTween(target.scale, {
                            x: 1,
                            y: 1,
                            time: time / 2,
                            transition: 'linear',
                            onComplete: () => {
                                ignitionTween.Tweener.addTween(target, {
                                    x: translation.x,
                                    time,
                                    transition: 'easeOut'
                                });
                                ignitionTween.Tweener.addTween(target, {
                                    y: translation.y,
                                    time,
                                    transition: 'linear',
                                    onComplete: () => {
                                        if (scaleDown) {
                                            const scaleTime = 0.4;
                                            time += scaleTime * 2;
                                            ignitionTween.Tweener.addTween(target.scale, {
                                                x: 1.1,
                                                y: 1.1,
                                                time: scaleTime,
                                                onComplete: () => {
                                                    ignitionTween.Tweener.addTween(target.scale, {
                                                        x: 0,
                                                        y: 0,
                                                        time: scaleTime,
                                                        onComplete: () => resolve()
                                                    });
                                                }
                                            });
                                        }
                                        else {
                                            resolve();
                                        }
                                    }
                                });
                            }
                        });
                    }
                });
            });
        });
    }
}
// export class BounceMultiplierAnimationStartegy implements IAnimationStrategy<Text> {
//     public async animate(target: Text, time: number, delay: number, data: Transformation): Promise<void> {
//         return new Promise(resolve => {
//             const {x,y} = data.scale;
//             for (let i = 0; i < times; i++) {
//                 Tweener.addTween(target.scale,{
//                     x,
//                     y,
//                     time:time,
//                     transition: 'easeOutBack',
//                     delay: i*(time*2) *1.1,
//                     onComplete: () => {
//                         Tweener.addTween(target.scale, {
//                             x: 1,
//                             y: 1,
//                             time: time,
//                             transition: 'easeInOutSine',
//                             onComplete:()=>{
//                                 if (i === times - 1)
//                                     resolve()
//                             }
//                         });
//
//                     }
//                 })
//
//             }
//
//         })
//     }
//}
class InitializeMultiplierAnimationStartegy {
    animate(target, time, delay, data) {
        return MultiplierAnimationStrategy_awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                const { x, y } = data.scale;
                Tweener.addTween(target.scale, {
                    x,
                    y,
                    time,
                    transition: 'easeOutBack',
                    delay,
                    onComplete: () => resolve()
                });
            });
        });
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/FeatureView.ts






class FeatureView extends Container_Container {
    constructor(le, reels, banner) {
        super();
        this._animationMoveStrategy = new FreespinMultiplierAnimationStrategy();
        LayoutBuilder.create(le, this);
        this.reels = reels;
        this.banner = banner;
    }
    updateLayout(desc) {
        this.layoutDesc = desc;
    }
    animateSymbol(symbolView, animationName, delay = 0) {
        setTimeout(() => {
            symbolView.spineAnim.visible = true;
            symbolView.spineAnim.state.setAnimation(0, animationName, false);
            sound_SoundManager.play(sound_SoundListExtended.MULTIPLIER);
        }, delay * 1000);
    }
    createMultiplier(symbol, value, style) {
        const m = new Text(value, style);
        m.pivot.set(m.width / 2, 0);
        symbol.addChild(m);
        this.animateScale(m);
        m.name = "multiplier";
        return m;
    }
    animateScale(m) {
        m.scale.set(0);
        ignitionTween.Tweener.addTween(m.scale, {
            x: 1.1,
            y: 1.1,
            time: 0.5,
            onComplete: () => {
                ignitionTween.Tweener.addTween(m.scale, {
                    x: 1,
                    y: 1,
                    time: 0.4
                });
            }
        });
    }
    resetSpine(spine) {
        spine.visible = false;
        spine.state.setEmptyAnimations(0);
        spine.state.clearListeners();
        spine.skeleton.setToSetupPose();
        spine['lastTime'] = null;
    }
}

;// CONCATENATED MODULE: ./src/the-miner/extends/MultiplierUtils.ts




function intializeMultiplier(reelIndex, symbolIndex, multiplierStyle) {
    var _a;
    const roundResult = dependency_container_instance.resolve(SlotMachine).roundResult;
    let m;
    const initMap = (_a = roundResult === null || roundResult === void 0 ? void 0 : roundResult.holdAndSpinnerMultiplierMap) === null || _a === void 0 ? void 0 : _a.initializationMap;
    if (initMap === null || initMap === void 0 ? void 0 : initMap.length) {
        initMap.forEach(mp => {
            if (mp.x == reelIndex && mp.y == symbolIndex) {
                const value = mp.multiplier * dependency_container_instance.resolve(SlotMachine).totalBet;
                m = new Text(dependency_container_instance.resolve(model_Wallet).getCurrencyValue(value), multiplierStyle);
                m.name = 'multiplier';
                m.pivot.x = m.width / 2;
                m.pivot.y = m.height / 2;
                m.y = m.height / 2;
                if (!dependency_container_instance.resolve(SlotMachine).currentSpinResult.freespins && !dependency_container_instance.resolve(SlotMachine).currentSpinResult.bonus)
                    m.alpha = 0.5;
            }
        });
    }
    return m;
}

;// CONCATENATED MODULE: ./src/the-miner/extends/ChosenSymbolView.ts







class ChosenSymbolView extends SymbolView {
    // There is one id "301", which should be used as 4 diff spines, depending on multipliers value
    // In Symbol list there have to be all the available SymbolData, (one with correct api id, ane the other ones can have random unused ids)
    // This is important, bcs on game start all the textures are created and assigned to each symbol data
    // In this class we are only choosing correct symbol data to pass to the SymbolView constructor
    constructor(data, reelIndex, symbolIndex) {
        var _a, _b;
        let option = 0;
        if ((_a = dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap) === null || _a === void 0 ? void 0 : _a.featureSymbolMultiplierMap) {
            dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.featureSymbolMultiplierMap.forEach(m => {
                if (m.x == reelIndex && m.y == symbolIndex) {
                    dependency_container_instance.resolve(SlotMachine).description.multiplierCompartment.some((maxValue, index) => {
                        if (maxValue > m.multiplier) {
                            option = index;
                            return true;
                        }
                    });
                }
            });
        }
        const defaultAssetName = 'symbol-multiplier-0';
        const searchedName = defaultAssetName.slice(0, -1) + option.toString();
        const newData = SymbolsList.find(symbolD => {
            return searchedName == symbolD.staticIcon.assetName;
        });
        super(newData);
        (_b = this.multiplierStyle) !== null && _b !== void 0 ? _b : (this.multiplierStyle = dependency_container_instance.resolve(CommonTokenConstants.MULTIPLIER_STYLE));
        this.multiplier = intializeMultiplier(reelIndex, symbolIndex, this.multiplierStyle);
        if (this.multiplier) {
            this.addChild(this.multiplier);
            autoscaleText(this.multiplier, 60, this.spineAnim.width, this.spineAnim.height);
            this.multiplier.pivot.set(this.multiplier.width * 0.5, this.multiplier.height * 0.5);
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/extends/WildSymbolView.ts






class WildSymbolView extends SymbolView {
    constructor(data) {
        super(data);
        this.style = dependency_container_instance.resolve(CommonTokenConstants.WILD_MULTIPLIER_STYLE);
        const spinResult = dependency_container_instance.resolve(SlotMachine).currentSpinResult;
        const roundResult = dependency_container_instance.resolve(SlotMachine).roundResult;
        const colCount = roundResult.holdAndSpinnerMultiplierMap.collectedCount;
        if (spinResult.freespins && roundResult.holdAndSpinnerMultiplierMap.featureMultiplier > 1 && colCount > 4) {
            let wildMultiplier = roundResult.holdAndSpinnerMultiplierMap.featureMultiplier;
            // we are getting from api that after collecting 4 or 8 or 12 wilds the multiplier is changing x2 -> x3 ->x10
            // but if we don't change it to the previous featureMultiplier there will be higher wildMultiplier before even winning extra freespins
            // if (colCount == 8 ){
            //     wildMultiplier = 2;
            // }
            // else if (colCount == 12 ){
            //     wildMultiplier = 3;
            // }
            this.multiplier = new Text(`x${wildMultiplier}`, this.style);
            this.addChild(this.multiplier);
            autoscaleText(this.multiplier, 50, this.spineAnim.width, this.spineAnim.height);
            this.multiplier.pivot.set(this.multiplier.width / 2, this.multiplier.height / 2);
            this.multiplier.position.set(50, -50);
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/extends/StaticSymbolView.ts





class StaticSymbolView extends SymbolView {
    constructor(data, reelIndex, symbolIndex) {
        var _a;
        super(data);
        (_a = this.multiplierStyle) !== null && _a !== void 0 ? _a : (this.multiplierStyle = dependency_container_instance.resolve(CommonTokenConstants.MULTIPLIER_STYLE));
        this.multiplier = intializeMultiplier(reelIndex, symbolIndex, this.multiplierStyle);
        if (this.multiplier) {
            this.addChild(this.multiplier);
            autoscaleText(this.multiplier, 60, this.spineAnim.width, this.spineAnim.height);
            this.multiplier.pivot.set(this.multiplier.width * 0.5, this.multiplier.height * 0.5);
        }
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/SymbolsList.ts




const SymbolsListNormal = [
    {
        id: 101,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-00',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-00',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-00',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_LOW_PAYOUT_1,
            volume: 0.15,
        },
    },
    {
        id: 102,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-01',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-01',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-01',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_LOW_PAYOUT_2,
            volume: 0.15,
        },
    },
    {
        id: 103,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-02',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-02',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-02',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_LOW_PAYOUT_3,
            volume: 0.15,
        },
    },
    {
        id: 104,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-03',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-03',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-03',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_LOW_PAYOUT_4,
            volume: 0.15,
        },
    },
    {
        id: 105,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-04',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-04',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-04',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_LOW_PAYOUT_5,
            volume: 0.15,
        },
    },
    {
        id: 201,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-05',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-05',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-05',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_HIGH_PAYOUT_1,
            volume: 0.15,
        },
    },
    {
        id: 202,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-06',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-06',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-06',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_HIGH_PAYOUT_2,
            volume: 0.15,
        },
    },
    {
        id: 203,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-07',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-07',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-07',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_HIGH_PAYOUT_3,
            volume: 0.15,
        },
    },
    {
        id: 204,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-08',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-08',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-08',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_HIGH_PAYOUT_4,
            volume: 0.15,
        },
    },
    {
        id: 301,
        specialViewClass: ChosenSymbolView,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-0',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-0',
            blurY: 40,
            blurX: 0,
        },
        spineAnimations: {
            spineAssetName: 'symbol-multiplier-0',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15
        },
    },
    {
        id: 0,
        specialViewClass: ChosenSymbolView,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-1',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-1',
            blurY: 40,
            blurX: 0,
        },
        spineAnimations: {
            spineAssetName: 'symbol-multiplier-1',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15
        },
    },
    {
        id: 1,
        specialViewClass: ChosenSymbolView,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-2',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-2',
            blurY: 40,
            blurX: 0,
        },
        spineAnimations: {
            spineAssetName: 'symbol-multiplier-2',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15
        },
    },
    {
        id: 3,
        specialViewClass: ChosenSymbolView,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-3',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-multiplier-3',
            blurY: 40,
            blurX: 0,
        },
        spineAnimations: {
            spineAssetName: 'symbol-multiplier-3',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15
        },
    },
];
const SymbolListWild = [
    // this symbol data is not available in api response
    // feature hold and spinner should replace all the symbol except 302 to this static symbol, but for some reason
    // we are getting normal symbols ( 105,201....) so in gameService there is a replacement
    {
        id: 1000,
        staticIcon: {
            sourceType: 'texture',
            assetName: 'symbol-hold-spinner-spin',
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'symbol-hold-spinner-spin',
            blurY: 40,
            blurX: 0,
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15
        },
    },
    {
        id: 25,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-scatter',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-scatter',
            blurY: 40,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-scatter',
            winAnimationName: 'win',
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15,
        },
        landSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER_LAND,
            volume: 0.15,
        },
    },
    {
        id: 302,
        specialViewClass: StaticSymbolView,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-hold-spinner',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-hold-spinner',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-hold-spinner',
            winAnimationName: 'win'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER,
            volume: 0.15
        },
        landSound: {
            id: sound_SoundListExtended.SYMBOL_SCATTER_LAND,
            volume: 0.15
        }
    },
    {
        id: 80,
        specialViewClass: WildSymbolView,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-wild',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'spine',
            assetName: 'symbol-wild',
            blurY: 40,
            blurX: 0,
            animationName: 'static'
        },
        spineAnimations: {
            spineAssetName: 'symbol-wild',
            winAnimationName: 'win',
            stopAnimationName: 'land'
        },
        winSound: {
            id: sound_SoundListExtended.SYMBOL_WILD,
            volume: 0.15,
        },
        landSound: {
            id: sound_SoundListExtended.SYMBOL_WILD_LAND,
            volume: 0.15,
        },
    },
];
//All Symbols
const SymbolsList = SymbolListWild.concat(SymbolsListNormal);

;// CONCATENATED MODULE: ./src/the-miner/view/FreespinView.ts
var FreespinView_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











class FreespinView extends FeatureView {
    constructor(le, reels, banner) {
        super(le, reels, banner);
        this.currentSpinWildSummary = 0;
        this.hooks = [];
        this.explosionsSpines = [];
        this.initializeHooksForEachReel();
        this.initializeExplosions();
    }
    initializeExplosions() {
        // create explosion spines for each symbol and do not reposition them, because update layout is not called at this moment in constructor
        // reposition should be done in first explosion animation
        const asset = assets_AssetsManager.spine.get('disappear');
        this.reels.getReelViews().forEach(reel => {
            reel.getVisibleSymbols().forEach(() => {
                const ex = new Spine(asset);
                this.addChild(ex);
                this.explosionsSpines.push(ex);
                this.resetSpine(ex);
            });
        });
    }
    initializeHooksForEachReel() {
        // hooks can appears on each reel and random amount at the same time
        const hookAsset = assets_AssetsManager.spine.get('hook');
        const hookYOffsetAdjustment = 225;
        // for each reel create hook, add to this view and reposition
        this.reels.getReelViews().forEach((reel) => {
            const hook = new Spine(hookAsset);
            hook.mask = this.hookMask;
            this.hooks.push(hook);
            this.addChild(hook);
            hook.y = -hookYOffsetAdjustment;
            hook.x = reel.x + reel.width / 2;
            this.resetSpine(hook);
        });
    }
    collectMultiplier(multiplierMap) {
        return FreespinView_awaiter(this, void 0, void 0, function* () {
            // reset multiplier value of wild in new spin
            this.currentSpinWildSummary = 0;
            const moveAnimations = [];
            // get wild from reel
            const wild = this.reels.getReelViews()[multiplierMap.wildPosition.x].getVisibleSymbols()[multiplierMap.wildPosition.y];
            // send each multiplier from reel to wild
            multiplierMap.featureSymbolMultiplierMap.forEach((symbol, index) => {
                const multiplierSymbol = this.reels.getReelViews()[symbol.x].getVisibleSymbols()[symbol.y];
                const multiplier = multiplierSymbol.multiplier;
                this.animateSymbol(multiplierSymbol, 'win', index);
                if (multiplier) {
                    moveAnimations.push(this.moveMultiplier(multiplier, wild, 30, index, wild, multiplierSymbol));
                }
            });
            yield Promise.all(moveAnimations);
            //if there is feature multiplier on wild and there is summary multiplied value then multiply it by summary values
            if (dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.featureMultiplier > 1 && wild.multiplier) {
                const wildM = wild.multiplier;
                yield this.moveMultiplier(wild.multiplier, wild.summaryMultiplier);
                yield this.multiplyWild(wild, wildM);
            }
            // Instead of emitter
            // send summary multiplier to freespin board
            if (dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.collectedCount <= 12 && wild.summaryMultiplier) {
                const nextCell = this.banner.getNextCell();
                if (nextCell) {
                    yield this.moveMultiplier(wild.summaryMultiplier, nextCell);
                }
            }
            // update freespin board
            yield this.banner.update();
        });
    }
    multiplyWild(wild, wildM) {
        return FreespinView_awaiter(this, void 0, void 0, function* () {
            // Check if summaryMultiplier exists before proceeding
            if (!wild.summaryMultiplier) {
                console.warn('FreespinView.multiplyWild: wild.summaryMultiplier is undefined, cannot multiply wild');
                return;
            }
            // Check if wildM exists and has text property
            if (!wildM || !wildM.text) {
                console.warn('FreespinView.multiplyWild: wildM is undefined or does not have text property');
                return;
            }
            const multiplierSummary = wild.summaryMultiplier.text;
            const summary = Number(parseFloat(multiplierSummary.slice(0, -1).replace('.', '').replace(',', '.')).toFixed(2));
            this.currentSpinWildSummary = summary * parseFloat(wildM.text.slice(1));
            wild.summaryMultiplier.text = `${this.currentSpinWildSummary.toLocaleString('de-DE')}${model_Wallet.currency.isoCode}`;
        });
    }
    handleWildSummary(text, style, wild, symbol) {
        return FreespinView_awaiter(this, void 0, void 0, function* () {
            // after sending multiplier to wild, recreate it on the same symbol
            yield this.createMultiplier(symbol, text, style);
            if (this.currentSpinWildSummary == 0 && !wild.summaryMultiplier) {
                // if wild don't have multiplier create new one
                this.currentSpinWildSummary += parseFloat(text.slice(0, -1).replace('.', '').replace(',', '.'));
                this.currentSpinWildSummary = Number(this.currentSpinWildSummary.toFixed(2));
                wild.summaryMultiplier = yield this.createMultiplier(wild, `${this.currentSpinWildSummary.toLocaleString('de-DE')}${model_Wallet.currency.isoCode}`, style);
            }
            else if (this.currentSpinWildSummary > 0) {
                // if wild has multiplier update the value
                this.currentSpinWildSummary += parseFloat(text.slice(0, -1).replace('.', '').replace(',', '.'));
                this.currentSpinWildSummary = Number(this.currentSpinWildSummary.toFixed(2));
                wild.summaryMultiplier.text = `${this.currentSpinWildSummary.toLocaleString('de-DE')}${model_Wallet.currency.isoCode}`;
            }
            // animate wild
            this.animateSymbol(wild, 'collect');
        });
    }
    moveMultiplier(multiplier, finalPos, offsetY = 0, delay = 0, wild, multiplierSymbol) {
        return FreespinView_awaiter(this, void 0, void 0, function* () {
            // detach multiplier from symbolView
            const multiplierOldPos = multiplier.getGlobalPosition();
            multiplier.setParent(this);
            multiplier.position = this.toLocal(multiplierOldPos);
            // Check if finalPos is valid before proceeding
            if (!finalPos || typeof finalPos.getGlobalPosition !== 'function') {
                console.warn('FreespinView.moveMultiplier: finalPos is undefined or does not have getGlobalPosition method');
                const text = multiplier.text;
                const style = multiplier.style;
                multiplier.destroy();
                if (wild)
                    yield this.handleWildSummary(text, style, wild, multiplierSymbol);
                return;
            }
            const time = 0.6;
            const point = finalPos.getGlobalPosition();
            point.y += offsetY;
            const transformation = {
                translation: this.toLocal(point),
                scale: new Point(1.8, 1.8)
            };
            // send multiplier to final Pos
            yield this._animationMoveStrategy.animate(multiplier, time, delay, transformation, !wild);
            const text = multiplier.text;
            const style = multiplier.style;
            multiplier.destroy();
            if (wild)
                yield this.handleWildSummary(text, style, wild, multiplierSymbol);
        });
    }
    pullReel(response) {
        return FreespinView_awaiter(this, void 0, void 0, function* () {
            const delayForEachHookPull = 750;
            const fitPullingToHookAnimationTime = 2300;
            const pullSpeed = 0.42;
            const offsetYForReelMask = 100;
            return new Promise((resolve) => {
                response.result.forEach((item, index) => {
                    const currentReel = this.reels.getReelViews()[item.reelId];
                    const currentHook = this.hooks[item.reelId];
                    currentHook.state.addListener({
                        start: () => {
                            currentHook.visible = true;
                            setTimeout(() => {
                                // after timeout -> pull reel
                                currentReel.pullReel(item.newReel, pullSpeed, offsetYForReelMask);
                            }, fitPullingToHookAnimationTime);
                        },
                        complete: () => {
                            this.resetSpine(currentHook);
                            if (index == response.result.length - 1)
                                resolve();
                        }
                    });
                    setTimeout(() => {
                        currentHook.state.setAnimation(0, 'active', false);
                    }, index * delayForEachHookPull);
                });
            });
        });
    }
    //instead of bazooka animation we have explosion animation
    explodeSymbols(result) {
        return FreespinView_awaiter(this, void 0, void 0, function* () {
            const reelSymbolsMap = [];
            // animations of explosions should be played from left to right in each row
            // but symbols are indexed by columns
            const reelsCount = this.reels.getReelViews().length;
            const rowsCount = this.reels.getReelViews()[0].getVisibleSymbols().length;
            const iteration = reelsCount * rowsCount;
            let wildSymbolId;
            for (let i = 0; i < iteration; i++) {
                const currentSymbol = this.reels.getReelViews()[i % reelsCount].getVisibleSymbols()[Math.floor(i / reelsCount)];
                reelSymbolsMap.push(currentSymbol);
                // get the id of wild symbol to avoid animating explosion on it
                if (currentSymbol.data.id == 302)
                    wildSymbolId = i;
            }
            // reposition explosions
            reelSymbolsMap.forEach((symbol, index) => {
                const ex = this.explosionsSpines[index];
                // don't reposition spines each bazooka feature if they already have good positions
                if (ex.position.x != 0 && ex.position.y != 0)
                    return;
                const point = symbol.getGlobalPosition();
                ex.position = this.toLocal(point);
            });
            return new Promise((resolve) => {
                // animate each explosion, except the one which is over wild symbol
                this.explosionsSpines.forEach((ex, index) => {
                    if (index == wildSymbolId)
                        return;
                    ignitionTween.Tweener.addCaller(this, {
                        count: 1,
                        delay: 0.12 * index,
                        onComplete: () => {
                            ex.state.addListener({
                                complete: () => {
                                    this.resetSpine(ex);
                                    if (index == this.explosionsSpines.length - 1)
                                        resolve();
                                }
                            });
                            ex.visible = true;
                            ex.state.setAnimation(0, 'disappear', false);
                            // swap all the symbols from response
                            const oldID = dependency_container_instance.resolve(SlotMachine).currentSpinResult.result[index % reelsCount][Math.floor(index / reelsCount)];
                            const newID = result.R[index % reelsCount][Math.floor(index / reelsCount)];
                            if (oldID !== newID) {
                                const symbolData = SymbolsList.find(s => s.id === newID);
                                let nS;
                                if (symbolData.specialViewClass) {
                                    nS = new symbolData.specialViewClass(symbolData, index % reelsCount, Math.floor(index / reelsCount));
                                }
                                else {
                                    nS = new SymbolView(symbolData);
                                }
                                this.reels.getReelViews()[index % reelsCount].swapSymbol(Math.floor(index / reelsCount), nS);
                            }
                        },
                    });
                });
            });
        });
    }
    createMultiplier(symbol, value, style) {
        const text = super.createMultiplier(symbol, value, style);
        ignitionTween.Tweener.pauseTweens(text);
        const scaleX = text.scale.x;
        const scaleY = text.scale.y;
        text.scale.set(1);
        autoscaleText(text, 60, symbol.spineAnim.width, symbol.spineAnim.height);
        text.pivot.set(text.width * 0.5, 0);
        text.scale.set(scaleX, scaleY);
        ignitionTween.Tweener.resumeTweens(text);
        return text;
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/HoldAndSpinnerView.ts
var HoldAndSpinnerView_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};













class HoldAndSpinnerView extends FeatureView {
    constructor(le, reels, winBanner) {
        super(le, reels, winBanner);
    }
    set mobileBanner(banner) {
        this._mobileBanner = banner;
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        if (desc.orientation == ScreenOrientation.VERTICAL)
            this.finalPos = this._mobileBanner.totalWinValue;
        else
            this.finalPos = this.banner;
    }
    restore(initializationRestoredMap, staticSymbolData) {
        initializationRestoredMap.forEach((item) => {
            const newSymbol = new SymbolView(staticSymbolData);
            dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.push({ x: item.x, y: item.y, symbol: newSymbol });
            this.reattachSymbol(newSymbol, item.x, item.y, item.multiplier);
        });
    }
    reattachSymbol(newSymbol, reelIndex, symbolIndex, multiplier = null) {
        const reels = this.reels.getReelViews();
        const oldChild = reels[reelIndex].getMainStripe().children[symbolIndex];
        // create multiplier for new reattached symbol
        if (multiplier)
            this.createMultiplier(newSymbol, dependency_container_instance.resolve(model_Wallet).getCurrencyValue((multiplier * dependency_container_instance.resolve(SlotMachine).totalBet)), dependency_container_instance.resolve(CommonTokenConstants.MULTIPLIER_STYLE));
        else
            this.recreateMultiplierFromSymbol(oldChild, newSymbol);
        const position = this.toLocal(oldChild.getGlobalPosition());
        this.addChild(newSymbol);
        newSymbol.position = position;
        oldChild.visible = false;
    }
    initializeHoldAndSpinnerView(staticSymbolId, movingSymbolId) {
        var _a;
        const reels = this.reels.getReelViews();
        if (dependency_container_instance.resolve(SlotMachine).currentSpinResult.currentTotalWinValue > 0)
            this.currentMultiplierSummary = dependency_container_instance.resolve(SlotMachine).currentSpinResult.currentTotalWinValue;
        else
            this.currentMultiplierSummary = 0;
        // get symbol data for each symbol ID
        const movingSymbolData = SymbolsList.find(s => s.id === movingSymbolId);
        const staticSymbolData = SymbolsList.find(s => s.id === staticSymbolId);
        const initializationRestoredMap = (_a = dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap) === null || _a === void 0 ? void 0 : _a.moneySymbolMultiplierMap.initialFixedMap;
        if (initializationRestoredMap) {
            // if the initialization map is not empty restore static symbols with information from this map
            this.restore(initializationRestoredMap, staticSymbolData);
            // all the rest of the symbols transform into moving symbols assets
            this.updateMovingSymbols(staticSymbolId, movingSymbolData);
        }
        else {
            this.banner['reset']();
            dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap = [];
            // all the rest of the symbols transform into moving symbols assets
            this.updateMovingSymbols(staticSymbolId, movingSymbolData);
            // pick every hold&spinner symbol from reel and place it in THIS view
            reels.forEach((reel, reelIndex) => {
                reel.getVisibleSymbols().forEach((symbol, symbolIndex) => {
                    if (symbol.data.id == staticSymbolId) {
                        const newSymbol = new SymbolView(staticSymbolData);
                        this.reattachSymbol(newSymbol, reelIndex, symbolIndex);
                        // push symbol as starting symbol
                        dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.push({ x: reelIndex, y: symbolIndex, symbol: newSymbol });
                    }
                });
            });
        }
    }
    updateMovingSymbols(staticSymbolId, movingSymbolData) {
        const reels = this.reels.getReelViews();
        reels.forEach((reel, reelIndex) => {
            reel.getVisibleSymbols().forEach((symbol, symbolIndex) => {
                // if the symbol has diff id then static symbol -> change it to moving symbol asset
                if (symbol.data.id !== staticSymbolId) {
                    this.reels.getReelViews()[reelIndex].swapSymbol(symbolIndex, new SymbolView(movingSymbolData));
                }
            });
        });
    }
    collectNewMultipliers(multiplierMap) {
        return HoldAndSpinnerView_awaiter(this, void 0, void 0, function* () {
            const newSymbolsArr = [];
            multiplierMap.moneySymbolMultiplierMap.newWinningsMap.forEach((symbol) => {
                const isSymbolInInitializedMap = dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.some(initSymbol => 
                // check if the multipliers map has new symbol ( diff x and y than starting symbols )
                symbol.x === initSymbol.x && symbol.y === initSymbol.y);
                // if there is new symbol get it's SymbolView and push it to array for animate
                if (!isSymbolInInitializedMap) {
                    const newSymbolView = this.reels.getReelViews()[symbol.x].getVisibleSymbols()[symbol.y];
                    newSymbolsArr.push(newSymbolView);
                }
            });
            // if there aren't any new symbols return
            if (!newSymbolsArr.length)
                return;
            // move all symbols' ( starting and new ones ) multipliers
            yield this.moveNewMultipliers(newSymbolsArr);
            yield this.collectInitializedMultipliers();
        });
    }
    moveNewMultipliers(newSymbolsArr) {
        return HoldAndSpinnerView_awaiter(this, void 0, void 0, function* () {
            const moveAnimations = [];
            newSymbolsArr.forEach((symbol, index) => {
                const multiplier = symbol.children.find((object) => object.name == 'multiplier');
                if (multiplier) {
                    moveAnimations.push(this.moveMultiplier(multiplier, this.finalPos.getGlobalPosition(), index * 0.8, MultiplierEvent.ON_MULTIPLIER_ANIMATION_END, symbol));
                }
            });
            yield Promise.all(moveAnimations);
        });
    }
    collectInitializedMultipliers() {
        return HoldAndSpinnerView_awaiter(this, void 0, void 0, function* () {
            const moveAnimations = [];
            //get multipliers from each starting symbol
            dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.forEach((map, index) => {
                const multiplier = map.symbol.children.find((object) => object.name == 'multiplier');
                if (multiplier) {
                    moveAnimations.push(this.moveMultiplier(multiplier, this.finalPos.getGlobalPosition(), index * 0.8, MultiplierEvent.ON_MULTIPLIER_ANIMATION_END, map.symbol));
                }
            });
            yield Promise.all(moveAnimations).then(() => {
                this.emit(MultiplierEvent.ON_ALL_MULTIPLIER_ANIMATION_END);
            });
        });
    }
    moveMultiplier(multiplier, point, delay = 0, eventName, symbol) {
        return HoldAndSpinnerView_awaiter(this, void 0, void 0, function* () {
            // reattach multiplier from symbol
            const multiplierOldPos = multiplier.getGlobalPosition();
            multiplier.setParent(this);
            multiplier.position = this.toLocal(multiplierOldPos);
            const time = 0.8;
            const transformation = {
                translation: this.toLocal(point),
                scale: new Point(1.8, 1.8)
            };
            // animate winning symbol
            this.animateSymbol(symbol, 'win', delay);
            yield this._animationMoveStrategy.animate(multiplier, time, delay, transformation);
            this.currentMultiplierSummary += (parseFloat(multiplier.text.slice(0, -1).replace('.', '').replace(',', '.'))) * model_Wallet.denomination;
            this.emit(eventName, this.currentMultiplierSummary);
            // recreate multiplier for same symbol after moving it to banner
            yield this.createMultiplier(symbol, multiplier.text, multiplier.style);
            multiplier.destroy();
        });
    }
    clearHoldAndSpinnerView() {
        // if there aren't any starting symbol return
        if (!dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.length)
            return;
        dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap.forEach((staticSymbol) => {
            // create new symbol from old symbol data
            const symbolCopy = new SymbolView(staticSymbol.symbol.data);
            // recreate multiplier from old symbol
            this.recreateMultiplierFromSymbol(staticSymbol.symbol, symbolCopy);
            // reattach symbol from this view to reel
            this.reels.getReelViews()[staticSymbol.x].swapSymbol(staticSymbol.y, symbolCopy);
            staticSymbol.symbol.destroy();
        });
        // clear starting symbols array
        dependency_container_instance.resolve(HoldAndSpinnerStaticSymbolMap).initializedSymbolsMap = [];
        this.banner['reset']();
    }
    recreateMultiplierFromSymbol(oldChild, newSymbol) {
        // get multiplier from old symbol and attach it to new one
        const multiplier = oldChild.children.find((object) => object.name == 'multiplier');
        if (multiplier) {
            const m = new Text(multiplier.text, multiplier.style);
            m.name = 'multiplier';
            m.pivot.set(m.width / 2, 0);
            newSymbol.addChild(m);
        }
    }
    createMultiplier(symbol, value, style) {
        const text = super.createMultiplier(symbol, value, style);
        ignitionTween.Tweener.pauseTweens(text);
        const scaleX = text.scale.x;
        const scaleY = text.scale.y;
        text.scale.set(1);
        autoscaleText(text, 60, symbol.spineAnim.width, symbol.spineAnim.height);
        text.pivot.set(text.width * 0.5, 0);
        text.scale.set(scaleX, scaleY);
        ignitionTween.Tweener.resumeTweens(text);
        return text;
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/Logo.ts




class Logo extends Container_Container {
    constructor() {
        super();
        const asset = assets_AssetsManager.spine.get('logo');
        this.spine = new Spine(asset);
        this.addChild(this.spine);
        this.spine.state.data.setMix('static', 'win', 0.15);
        this.spine.state.data.setMix('win', 'static', 0.15);
        this.spine.state.addListener({
            complete: (entry) => {
                ignitionTween.Tweener.addCaller(this, {
                    count: 1,
                    time: 0,
                    onComplete: () => {
                        this.playIdleAnimation(true);
                    }
                });
            }
        });
        this.playIdleAnimation(true);
    }
    playIdleAnimation(isLoop) {
        this.spine.state.setEmptyAnimations(0);
        this.spine.state.setAnimation(0, 'static', isLoop);
    }
    playWinAnimation() {
        this.spine.state.setAnimation(0, 'win', false);
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/MainScreenBackground.ts
var MainScreenBackground_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








class MainScreenBackground extends Container_Container {
    constructor(mainGameScreen) {
        super();
        this.mainGameScreen = mainGameScreen;
        const mainAnimationAsset = assets_AssetsManager.spine.get(MainScreenBackground_BackgroundType.NORMAL);
        const freegameAnimationAsset = assets_AssetsManager.spine.get(MainScreenBackground_BackgroundType.FREEGAME);
        this.mainAnimation = new Spine(mainAnimationAsset);
        this.freegameAnimation = new Spine(freegameAnimationAsset);
        const transitionAnimationAsset = assets_AssetsManager.spine.get('transition');
        this.transitionAnimation = new Spine(transitionAnimationAsset);
        this.transitionAnimation.pivot.set(this.transitionAnimation.width / 2, this.transitionAnimation.height / 2);
        this.updateBackgroundMusic();
    }
    getTheme() {
        return this._theme;
    }
    setTheme(type) {
        return MainScreenBackground_awaiter(this, void 0, void 0, function* () {
            if (this._theme === type) {
                return;
            }
            this._theme = type;
            switch (this._theme) {
                case MainScreenBackground_BackgroundType.NORMAL:
                    yield this.swap(MainScreenBackground_BackgroundType.NORMAL, this.mainAnimation);
                    break;
                case MainScreenBackground_BackgroundType.FREEGAME:
                    sound_SoundManager.play(sound_SoundList.TRANSITION);
                    yield this.swap(MainScreenBackground_BackgroundType.FREEGAME, this.freegameAnimation);
                    break;
                case MainScreenBackground_BackgroundType.BONUS:
                    sound_SoundManager.play(sound_SoundList.TRANSITION);
                    yield this.swap(MainScreenBackground_BackgroundType.BONUS, this.freegameAnimation);
                    break;
            }
        });
    }
    swap(theme, background) {
        const t = theme;
        return new Promise(resolve => {
            if (this.children.length == 0) {
                this.addChild(background);
                this.addChild(this.transitionAnimation);
                background.state.setAnimation(0, theme == MainScreenBackground_BackgroundType.NORMAL ? 'basegame' : 'freegame', true);
                this.mainGameScreen.changeMainUI(t);
                resolve();
                return;
            }
            const prevBackground = this.children[0];
            // Adjust the time for transition animation to cover the UI changes
            const transitionCoverTimeOut = 500;
            this.mainGameScreen.addChild(this.transitionAnimation);
            this.transitionAnimation.state.setEmptyAnimations(0);
            this.transitionAnimation.state.addListener({
                start: () => {
                    setTimeout(() => {
                        this.removeChild(prevBackground);
                        this.addChildAt(background, 0);
                        this.mainGameScreen.changeMainUI(t);
                    }, transitionCoverTimeOut);
                },
                complete: () => {
                    resolve();
                    this.transitionAnimation.state.clearListeners();
                }
            });
            this.transitionAnimation.state.setAnimation(0, 'transition', false);
            background.state.setAnimation(0, theme == MainScreenBackground_BackgroundType.NORMAL ? 'basegame' : 'freegame', true);
            if (this.backgroundMusic) {
                ignitionTween.Tweener.addTween(this.backgroundMusic, {
                    volume: 0,
                    time: 0.45,
                    transition: 'linear',
                    onComplete: () => {
                        this.backgroundMusic.stop();
                        this.updateBackgroundMusic();
                    }
                });
            }
        });
    }
    updateBackgroundMusic() {
        var _a;
        (_a = this.backgroundMusic) === null || _a === void 0 ? void 0 : _a.stop();
        this.backgroundMusic = sound_SoundManager.loop({
            id: this._theme === MainScreenBackground_BackgroundType.NORMAL ? sound_SoundListExtended.BASEGAME_BACKGROUND : sound_SoundListExtended.FREEGAME_BACKGROUND,
            volume: this._theme === MainScreenBackground_BackgroundType.NORMAL ? 0.1 : 0.2,
            channel: MainScreenBackground.DEFAULT_BACKGROUND_CHANNEL
        });
    }
    updateLayout(desc) {
        switch (desc.orientation) {
            case ScreenOrientation.HORIZONTAL:
                const xScale = desc.currentWidth / desc.baseWidth;
                const yScale = desc.currentHeight / desc.baseHeight;
                this.transitionAnimation.scale.set(xScale > yScale ? xScale : yScale);
                this.scale.set(xScale > yScale ? xScale : yScale);
                break;
            case ScreenOrientation.VERTICAL:
                // const offsetX = (desc.currentWidth - desc.baseWidth) / 2
                // const backgroundWidth = 1920
                // this.scale.set((desc.currentHeight / desc.baseHeight) * 2);
                // this.pivot.x = -(backgroundWidth / 2)
                // this.x = 0 - offsetX
                this.transitionAnimation.scale.set((desc.currentHeight / desc.baseHeight) * 2);
                this.scale.set((desc.currentHeight / desc.baseHeight) * 2);
                // Keep center after rescaling
                this.pivot.x = (desc.baseWidth / desc.currentWidth);
                // Ordinary offset
                this.x = 120;
                break;
        }
        this.transitionAnimation.position.set(this.x, this.y);
    }
}
MainScreenBackground.DEFAULT_BACKGROUND_CHANNEL = 'ambient';
/* harmony default export */ const view_MainScreenBackground = (MainScreenBackground);
var MainScreenBackground_BackgroundType;
(function (BackgroundType) {
    BackgroundType["NORMAL"] = "main-screen-background";
    BackgroundType["FREEGAME"] = "freegame-screen-background";
    BackgroundType["BONUS"] = "bonus-screen";
})(MainScreenBackground_BackgroundType || (MainScreenBackground_BackgroundType = {}));

;// CONCATENATED MODULE: ./src/the-miner/view/ReelHeader.ts



class ReelHeader extends Container_Container {
    // private tfText: Text;
    // private tfCurrentWinValue: ValueText;
    constructor(le) {
        super();
        LayoutBuilder.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        //     this.tfCurrentWinValue.renderValueFunction = (tfText: Text, value: number)=>{
        //         tfText.text = `${value.toFixed(2)} ${Wallet.currency.isoCode}`;
        //     }
        //     this.tfCurrentWinValue.setValue(0);
        //     this.tfCurrentWinValue.visible = false;
        //     const styleArr:Partial<TextStyle>[] =[
        //         {
        //             fontFamily: AssetsManager.webFonts.get('LuckiestGuy').family,
        //             fill:[
        //                 0xffffff
        //             ],
        //         },
        //         {
        //             fontFamily: AssetsManager.webFonts.get('LuckiestGuy').family,
        //             fill:[
        //                 0x60f6ff,
        //                 0x7efbff,
        //                 0x7ceaf5
        //             ],
        //             fillGradientType:1
        //         }, {
        //             fontFamily: AssetsManager.webFonts.get('LuckiestGuy').family,
        //             fill:[
        //                 0xffffff
        //             ],
        //         }
        //     ];
        //     multiStyledText(this.tfText,styleArr, ['O', 'X'] )
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ValueText':
                instance = new ValueText(le);
                break;
        }
        return instance;
    }
}

;// CONCATENATED MODULE: ./src/the-miner/view/MainGameScreen.ts
var MainGameScreen_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MainGameScreen_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var MainGameScreen_param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






























let MainGameScreen = class MainGameScreen extends AdjustableLayoutContainer {
    constructor(slotMachine) {
        super(assets_AssetsManager.layouts.get('main-screen'));
        this.currentLineWinIndex = -1;
        this.currentLineWinCycles = 0;
        this.maxLineWinCycles = 2;
        this.slotMachine = slotMachine;
        LayoutBuilder.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        // Lock be default - first call to onSlotMachineStateChanged will update it
        this.uiPanelMobileVertical.lock();
        this.uiPanelDesktop.lock();
        this.holdAndSpinnerView.mobileBanner = this.totalWinFrame;
        this.totalWinFrameBaseYPositions = {
            mobile: this.totalWinFrame.y,
        };
        this.onSlotMachineStateChanged(this.slotMachine.currentState);
        this.slotMachine.on(SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
        this.holdAndSpinnerView.on(MultiplierEvent.ON_MULTIPLIER_ANIMATION_END, this.featureWinBanner.setValue, this.featureWinBanner);
        this.holdAndSpinnerView.on(MultiplierEvent.ON_MULTIPLIER_ANIMATION_END, (val) => {
            this.totalWinFrame.setValue(val, true);
            this.uiPanelDesktop.totalWinFrame.setValue(val, true);
        }, this);
        this.freespinView.on(MultiplierEvent.ON_ALL_MULTIPLIER_ANIMATION_END, this.freespinMultiplier.update, this.freespinMultiplier);
        this.on('added', this.onAdded, this);
        this.addChild(new Sprite(assets_AssetsManager.textures.get('black-rect')));
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ReelsBackground':
                instance = new Sprite(assets_AssetsManager.textures.get('reel'));
                break;
            case 'ReelsView':
                instance = new view_ReelsView(le, this.slotMachine.description.reels.regular, SymbolsList, {
                    winFrameAnimation: {
                        animationPrefix: 'win-frame-win',
                        fps: 30
                    },
                    anticipationTime: 1.5,
                    symbolSize: new Point(212, 212),
                    fallingCascade: true,
                });
                break;
            case 'UIPanelMobileVertical':
                instance = new UIPanelMobileVertical({
                    UIMainConfiguration: {
                        buttonSpinConfig: {
                            useRotationInStartAnimation: true,
                        },
                    },
                });
                break;
            case 'UIPanelDesktop':
                instance = new UIPanelDesktop({
                    UIMainConfiguration: {
                        buttonSpinConfig: {
                            useRotationInStartAnimation: true,
                        },
                    },
                });
                break;
            case 'MainScreenBackground':
                instance = new view_MainScreenBackground(this);
                break;
            case 'TotalWinFrame':
                instance = new TotalWinFrame(le);
                break;
            case 'TotalWinFrameDesktop':
                instance = new TotalWinFrame(le);
                break;
            case 'Character':
                instance = new Character();
                break;
            case 'ReelHeader':
                instance = new ReelHeader(le);
                break;
            case 'Logo':
                instance = new Logo();
                break;
            case 'MultiplierFrame':
                instance = new FreespinMultiplierBoard(le);
                break;
            case 'FeatureWinBanner':
                instance = new FeatureWinBanner(le);
                break;
            case 'HoldAndSpinner':
                instance = new HoldAndSpinnerView(le, this.reels, this.featureWinBanner);
                break;
            case 'FreespinView':
                instance = new FreespinView(le, this.reels, this.freespinMultiplier);
                break;
        }
        return instance;
    }
    moveTotalWinFrame(basePos) {
    }
    changeMainUI(theme) {
        this.currentTheme = theme;
        this.freespinMultiplier.alpha = theme == MainScreenBackground_BackgroundType.FREEGAME ? 1 : 0;
        this.reelHeader.alpha = theme == MainScreenBackground_BackgroundType.FREEGAME ? 0 : 1;
        this.logoDesktop.alpha = theme == MainScreenBackground_BackgroundType.NORMAL ? 0 : 1;
        this.featureWinBanner.alpha = theme == MainScreenBackground_BackgroundType.BONUS ? 1 : 0;
        this.characterMobile.alpha = theme == MainScreenBackground_BackgroundType.FREEGAME ? 0 : 1;
        this.logoMobile.alpha = theme == MainScreenBackground_BackgroundType.FREEGAME ? 0 : 1;
        this.uiPanelMobileVertical.setFeatureButtonsVisibility(theme);
        this.uiPanelDesktop.setFeatureButtonsVisibility(theme);
        if (theme == MainScreenBackground_BackgroundType.FREEGAME || theme == MainScreenBackground_BackgroundType.BONUS) {
            this.moveTotalWinFrame(false);
        }
        else {
            this.moveTotalWinFrame(true);
        }
        if (theme == MainScreenBackground_BackgroundType.BONUS)
            this.holdAndSpinnerView.initializeHoldAndSpinnerView(302, 1000);
        else
            this.holdAndSpinnerView.clearHoldAndSpinnerView();
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        this.featureWinBanner.updateBackground(desc.orientation);
        this.holdAndSpinnerView.position = this.freespinView.position = this.reels;
    }
    onSlotMachineStateChanged(currentState) {
        var _a;
        const sm = this.slotMachine;
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const gs = dependency_container_instance.resolve(services_GameService);
        let gameSpeedLevel;
        switch (currentState) {
            case SlotMachineState.SPINNING:
                this.currentLineWinIndex = -1;
                this.currentLineWinCycles = 0;
                this.reels.off(ReelsViewEvent.WIN_ANIMATION_COMPLETE);
                if ((_a = sm.previousRoundResult) === null || _a === void 0 ? void 0 : _a.complete) {
                    this.totalWinFrame.setValue(0);
                    this.uiPanelDesktop.totalWinFrame.setValue(0);
                }
                this.uiPanelMobileVertical.lock();
                this.uiPanelDesktop.lock();
                gameSpeedLevel = sm.stopRequested ? 1 : this.slotMachine.currentGameSpeedLevel;
                this.reels.spin(sm.currentGameSpeedLevel, {
                    id: sound_SoundListExtended.UI_REEL_SPIN,
                    volume: 0.1,
                }, sm.options.gameSpeedLevels[sm.currentGameSpeedLevel]);
                break;
            case SlotMachineState.SPIN_END:
            case SlotMachineState.COMMUNICATION_ERROR:
                gameSpeedLevel = sm.stopRequested ? 1 : this.slotMachine.currentGameSpeedLevel;
                const spinResult = sm.currentSpinResult;
                const stopPromises = [
                    this.reels.stop(spinResult.result, {
                        stopSoundData: {
                            id: sound_SoundListExtended.UI_REEL_STOP,
                            volume: 0.2,
                        },
                        anticipationSoundData: {
                            id: sound_SoundListExtended.REEL_ANTICIPATION,
                            volume: 0.6,
                        },
                    }, gameSpeedLevel, this.getAnticipationReels(25, spinResult), sm.options.gameSpeedLevels[sm.currentGameSpeedLevel]),
                ];
                Promise.all(stopPromises).then(() => {
                    var _a;
                    if (sm.currentState != SlotMachineState.COMMUNICATION_ERROR) {
                        if (dependency_container_instance.resolve(SlotMachine).roundResult.hook) {
                            this.freespinView.pullReel(dependency_container_instance.resolve(SlotMachine).roundResult.hook).then(() => {
                                var _a;
                                if ((_a = dependency_container_instance.resolve(SlotMachine).roundResult.bazooka) === null || _a === void 0 ? void 0 : _a.active) {
                                    this.freespinView.explodeSymbols(dependency_container_instance.resolve(SlotMachine).roundResult.bazooka).then(() => {
                                        new ControlEvent(SlotGameEvent.REELS_STOPPED).dispatch();
                                    });
                                }
                                else
                                    new ControlEvent(SlotGameEvent.REELS_STOPPED).dispatch();
                            });
                        }
                        else {
                            if ((_a = sm.roundResult.bazooka) === null || _a === void 0 ? void 0 : _a.active) {
                                this.freespinView.explodeSymbols(sm.roundResult.bazooka).then(() => {
                                    new ControlEvent(SlotGameEvent.REELS_STOPPED).dispatch();
                                });
                            }
                            else
                                new ControlEvent(SlotGameEvent.REELS_STOPPED).dispatch();
                        }
                    }
                });
                break;
            case SlotMachineState.BIG_WIN_FREE_SPIN:
                this.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                this.uiPanelDesktop.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                break;
            case SlotMachineState.SPIN_RESULT_MULTI_WIN:
                this.showMultiWin();
                if (sm.currentSpinResult.winValue > 0) {
                    if (!dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinner) {
                        this.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                        this.uiPanelDesktop.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                    }
                    this.playMainElementsWinAnimations();
                }
                break;
            case SlotMachineState.SPIN_RESULT_SCATTER:
                new ControlEvent(SlotGameEvent.SCATTER_WIN_SHOWN).dispatch();
                break;
            case SlotMachineState.SPIN_RESULT_CASCADE:
                this.reels.cascade(sm.multiWinPattern(sm.previousSpinResult), sm.currentSpinResult.result)
                    .then(() => {
                    new ControlEvent(SlotGameEvent.CASCADE_WIN_SHOWN).dispatch();
                });
                break;
            case SlotMachineState.BONUS_GAME:
                if (dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.toCollect) {
                    this.holdAndSpinnerView.collectNewMultipliers(dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap).then(() => {
                        this.checkHoldAndSpinnerHealth();
                    });
                }
                else {
                    this.checkHoldAndSpinnerHealth();
                }
                break;
            case SlotMachineState.FREE_SPINS_ROUND_END:
                this.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                this.uiPanelDesktop.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                break;
            case SlotMachineState.IDLE:
                this.checkNextLineWin();
                this.uiPanelMobileVertical.unlock();
                this.uiPanelDesktop.unlock();
                break;
        }
    }
    checkHoldAndSpinnerHealth() {
        var _a, _b;
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (((_a = sm.roundResult.holdAndSpinner) === null || _a === void 0 ? void 0 : _a.remainingCount) == 4 && this.uiPanelDesktop.heartBanner.prevHeartLevel != 4) {
            const heartsPromises = [];
            [this.uiPanelDesktop.heartBanner, this.uiPanelMobileVertical.heartBanner].forEach((banner) => {
                heartsPromises.push(banner.resetHearts(true));
            });
            Promise.all(heartsPromises).then(() => {
                [this.uiPanelDesktop.heartBanner, this.uiPanelMobileVertical.heartBanner].forEach((banner) => {
                    banner.reduceHeart();
                });
                new ControlEvent(SlotGameEventExtension.HOLD_AND_SPINNER_START).dispatch();
            });
        }
        else if (((_b = sm.roundResult.holdAndSpinner) === null || _b === void 0 ? void 0 : _b.remainingCount) <= 4) {
            [this.uiPanelDesktop.heartBanner, this.uiPanelMobileVertical.heartBanner].forEach((banner) => {
                banner.restore(true);
                banner.reduceHeart();
            });
            new ControlEvent(SlotGameEventExtension.HOLD_AND_SPINNER_START).dispatch();
        }
    }
    showMultiWin() {
        var _a;
        const sm = this.slotMachine;
        this.reels.once(ReelsViewEvent.WIN_ANIMATION_COMPLETE, () => {
            new ControlEvent(SlotGameEvent.MULTI_WIN_SHOWN).dispatch();
        });
        const winPattern = this.slotMachine.multiWinPattern(this.slotMachine.currentSpinResult);
        sound_SoundManager.play(sound_SoundListExtended.WIN_FRAME);
        this.reels.animateWins(winPattern, 2, true);
        const lineWins = (_a = sm.currentSpinResult.win) === null || _a === void 0 ? void 0 : _a.lines;
        if (lineWins.length == 1)
            sm.currentLineWin = lineWins[0].winValue;
    }
    checkNextLineWin() {
        var _a;
        const sm = this.slotMachine;
        const combinationWins = (_a = sm.currentSpinResult.win) === null || _a === void 0 ? void 0 : _a.combinations;
        if (!combinationWins) {
            return;
        }
        if (this.currentLineWinIndex == -1) {
            this.currentLineWinIndex = 0;
        }
        else {
            this.currentLineWinIndex = (this.currentLineWinIndex + 1) % combinationWins.length;
            if (!this.currentLineWinIndex) {
                this.currentLineWinCycles++;
                if (this.currentLineWinCycles >= this.maxLineWinCycles) {
                    return;
                }
                else {
                    this.currentLineWinIndex = -1;
                    this.checkNextLineWin();
                    return;
                }
            }
        }
        this.showNextLineWin(combinationWins);
    }
    showNextLineWin(combinationWins) {
        const sm = this.slotMachine;
        const combinationWin = combinationWins[this.currentLineWinIndex];
        sm.currentLineWin = combinationWin.wayPayout;
        this.reels.once(ReelsViewEvent.WIN_ANIMATION_COMPLETE, () => {
            this.reels.off(ReelsViewEvent.WIN_ANIMATION_COMPLETE);
            new ControlEvent(SlotGameEvent.WINLINE_WIN_SHOWN, combinationWin).dispatch();
            if (sm.currentState == SlotMachineState.IDLE) {
                this.checkNextLineWin();
            }
        });
        this.reels.animateWins(combinationWin.pattern, 1, true);
    }
    getWinningSymbols(output, winPattern) {
        const winingSymbols = new Map();
        for (let i = 0; i < output.length; i++) {
            for (let j = 0; j < output[i].length; j++) {
                if (winPattern[i][j] == 1) {
                    if (winingSymbols.has(output[i][j])) {
                        const prevValue = winingSymbols.get(output[i][j]);
                        winingSymbols.set(output[i][j], prevValue + 1);
                    }
                    else {
                        winingSymbols.set(output[i][j], 1);
                    }
                }
            }
        }
        return winingSymbols;
    }
    getAnticipationReels(scatterId, spinResult) {
        let scattersCount = 0;
        const anticipationReelIds = [];
        spinResult.result.forEach((reel, id) => {
            if (scattersCount >= 2)
                anticipationReelIds.push(id);
            if (reel.includes(scatterId))
                scattersCount++;
        });
        return anticipationReelIds;
    }
    playMainElementsWinAnimations() {
        this.logoDesktop.playWinAnimation();
        this.logoMobile.playWinAnimation();
        this.character.playWinAnimation();
    }
    onAdded() {
        //Restore previous freespin state
        if (this.slotMachine.roundResult.nextType === 10 || this.slotMachine.roundResult.nextType === 31) {
            this.totalWinFrame.setValue(this.slotMachine.currentSpinResult.currentTotalWinValue);
            //this.totalWinFrameDesktop.setValue(this.slotMachine.currentSpinResult.currentTotalWinValue);
            this.slotMachine.showFreeSpinsPopup = false;
            this.slotMachine.currentState = SlotMachineState.FREE_SPINS_ROUND_START;
            this.freespinMultiplier.restore();
        }
        else if (this.slotMachine.roundResult.nextType === 11) {
            this.slotMachine.currentState = SlotMachineState.SPIN_RESULT_BONUS_GAME;
            this.totalWinFrame.setValue(this.slotMachine.currentSpinResult.currentTotalWinValue);
            this.featureWinBanner.setValue(this.slotMachine.currentSpinResult.currentTotalWinValue);
            this.uiPanelDesktop.heartBanner.restore(true);
            this.uiPanelMobileVertical.heartBanner.restore(true);
        }
    }
};
MainGameScreen = MainGameScreen_decorate([
    decorators_injectable(),
    MainGameScreen_param(0, decorators_inject(SlotMachine)),
    MainGameScreen_metadata("design:paramtypes", [SlotMachine])
], MainGameScreen);
/* harmony default export */ const view_MainGameScreen = (MainGameScreen);

;// CONCATENATED MODULE: ./src/the-miner/tsyringe/defaults.ts









dependency_container_instance.register(PopupFactoryTokenConstants.PAYTABLE_CONFIG, {
    useFactory: () => {
        const wallet = dependency_container_instance.resolve(model_Wallet);
        const slotMachine = dependency_container_instance.resolve(SlotMachine);
        return {
            multiplierList: [5, 4, 3, 2],
            symbolsList: SymbolsList,
            symbolsPerPage: [
                {
                    rows: [5, 5],
                },
            ],
            excludedSymbols: [25, 302, 0, 1, 2, 3].concat((SymbolListWild).map((symbolData) => symbolData.id)),
            symbolsWithDescription: [
                {
                    itemId: 2,
                    symbolId: 80,
                },
                {
                    itemId: 3,
                    symbolId: 25,
                },
            ],
            minBet: wallet.getCurrencyValue(slotMachine.description.betLimits[0] * slotMachine.numLines, true),
            maxBet: wallet.getCurrencyValue(slotMachine.description.betLimits[slotMachine.description.betLimits.length - 1] * slotMachine.numLines, true)
        };
    }
});
dependency_container_instance.register(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_HORIZONTAL, {
    useFactory: () => new Text('', {
        fontFamily: assets_AssetsManager.webFonts.get('Anton').family,
        fill: [
            0xfff7ce
        ],
        fontSize: 150,
        lineJoin: 'round',
    })
});
dependency_container_instance.register(PopupFactoryTokenConstants.CELEBRATION_WIN_TEXT_VERTICAL, {
    useFactory: () => new Text('', {
        fontFamily: assets_AssetsManager.webFonts.get('Anton').family,
        fill: [
            0xfff7ce
        ],
        fontSize: 120,
        lineJoin: 'round',
        stroke: '#271C19',
        strokeThickness: 6
    })
});
dependency_container_instance.register(PopupFactoryTokenConstants.CONGRATULATION_FEATURE_TEXT_HORIZONTAL, {
    useFactory: () => multiStyledText(new Text('HOLD&\nSPINNER', { fontSize: 130 }), [
        {
            fill: [
                0x0a2d55
            ]
        },
        {
            fill: [
                0x0a2d55
            ]
        },
        {
            fill: [
                0x14bded
            ]
        }
    ], ['D', '&'])
});
dependency_container_instance.register(PopupFactoryTokenConstants.CONGRATULATION_FEATURE_TEXT_VERTICAL, {
    useFactory: () => multiStyledText(new Text('HOLD&\nSPINNER', { fontSize: 130 }), [
        {
            fill: [
                0x0a2d55
            ]
        },
        {
            fill: [
                0x0a2d55
            ]
        },
        {
            fill: [
                0x0a2d55
            ]
        }
    ], ['D', '&'])
});
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_TURBO_POSITION_Y_HORIZONTAL, {
    useValue: 380
});
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_TURBO_POSITION_Y_VERTICAL, {
    useValue: 520
});
dependency_container_instance.register(CommonTokenConstants.HOLD_AND_SPINNER_MULTI_STYLED_TEXT, {
    useFactory: () => [
        {
            fontFamily: assets_AssetsManager.webFonts.get('Anton').family,
            fill: [
                0xFFF7CE
            ],
            stroke: 0x271C19,
            strokeThickness: 5
        },
        {
            fontFamily: assets_AssetsManager.webFonts.get('Anton').family,
            fill: [
                0xFFFFFF
            ],
            stroke: 0x271C19,
            strokeThickness: 5
        }, {
            fontFamily: assets_AssetsManager.webFonts.get('Anton').family,
            fill: [
                0xF0C315
            ],
            stroke: 0x271C19,
            strokeThickness: 5
        }
    ]
});
dependency_container_instance.register(CommonTokenConstants.PAYTABEL_PANEL_SYMBOL_CELL_SPACING, {
    useValue: {
        desktop: { x: 35, y: 210 },
        mobile: { x: 20, y: 20 }
    }
});
dependency_container_instance.register(CommonTokenConstants.MULTIPLIER_STYLE, {
    useFactory: () => new TextStyle({
        fontFamily: assets_AssetsManager.webFonts.get('LuckiestGuy').family,
        fontSize: 60,
        fill: [
            0xffe600,
            0xff8300,
            0xffff00,
            0xff9300
        ],
        fillGradientStops: [
            0.1,
            0.5,
            0.5,
            0.8
        ],
        stroke: 0x271C19,
        strokeThickness: 5,
    }),
});
dependency_container_instance.register(CommonTokenConstants.WILD_MULTIPLIER_STYLE, {
    useFactory: () => new TextStyle({
        fontFamily: assets_AssetsManager.webFonts.get('LuckiestGuy').family,
        fontSize: 50,
        fill: [
            0xA8A8A6,
            0x696969,
            0xF9F8F6,
            0xD4D4D4,
            0x7F7F7F
        ],
        stroke: 0x271C19,
        strokeThickness: 5,
    }),
});
dependency_container_instance.register(CommonTokenConstants.PAYTABLE_PANEL_SYMBOL_DESCRIPTION_SPACING, {
    useValue: {
        desktop: 0,
        mobile: 20
    }
});

;// CONCATENATED MODULE: ./src/the-miner/tsyringe/popupsConfig.ts







dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_0, { useValue: BigWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_1, { useValue: MegaWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_2, { useValue: SuperWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_BIG_WIN_CONFIG_3, { useValue: GrandWinConfiguration });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_FREESPINS_CONFIG, { useValue: PopupFreespinsConfig });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_CONGRATULATIONS_CONFIG, { useValue: PopupCongratulationsConfig });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_HOLD_AND_SPINNER_CONFIG, { useValue: PopupHoldAndSpinnerConfig });
dependency_container_instance.register(PopupFactoryTokenConstants.POPUP_EXTRA_FREESPIN_CONFIG, { useValue: PopupExtraFreespinConfig });

;// CONCATENATED MODULE: ./src/the-miner/TheMiner.ts
var TheMiner_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

 // required by tsyringe












































































class TheMiner extends BrowserApplication {
    constructor(gameContainer, config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (config.mobileLog && isMobile_isMobile.any) {
            new MobileBrowserLog();
        }
        if (isMobile_isMobile.any) {
            window.onblur = () => {
                // pause when window focus lost
                sound_SoundManager.mute = true;
            };
            window.onfocus = () => {
                // Unpause when window gains focus
                sound_SoundManager.mute = false;
            };
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Ticker.shared.stop();
                    sound_SoundManager.mute = false;
                }
                else {
                    // Ticker.shared.start();
                    sound_SoundManager.mute = true;
                }
            });
        }
        utils_Logger.info(`Gammastack - The Miner [${"1.0.8"}]`);
        utils_Logger.info(`Ignition-Interactive - Core Engine [${IgnitionCore_VERSION}]`);
        utils_Logger.info(`Ignition-Interactive - Slots Engine [${IgnitionSlots_VERSION}]`);
        utils_Logger.info(`Ignition-Interactive - Common Engine [${ExaGamingCommonEngine4_VERSION}]`);
        utils_Logger.logLevel = config.logLevel;
        super(gameContainer, {
            id: 'game',
            container: gameContainer,
            resizeMethod: ResizeMethod.SHOW_ALL,
            backgroundColor: 0x000000,
            baseWidth: 1920,
            baseHeight: 1080,
            autoUpdateSizeToOrientation: true,
            debug: config.debug,
            fps: ((_b = (_a = getFromLocalStorage('settings')) === null || _a === void 0 ? void 0 : _a.batterySaver) !== null && _b !== void 0 ? _b : false) == true ? 20 : 60,
            backgroundAlpha: 0
        });
        this.currentWidth = 0;
        this.currentHeight = 0;
        this.assetsBaseUrl = './assets';
        utils_Logger.warning(`FPS VALUE - ${((_d = (_c = getFromLocalStorage('settings')) === null || _c === void 0 ? void 0 : _c.batterySaver) !== null && _d !== void 0 ? _d : false) == true ? 20 : 60}`);
        // PixiJS Chrome extension support
        globalThis.__PIXI_APP__ = this.pixi;
        this.gameService = new services_GameService(config.serverApiUrl, config.historyApiUrl, config.jwtToken, config.gameCode, (_e = config.userLoginUrl) !== null && _e !== void 0 ? _e : '');
        this.container.style.display = 'none';
        // this.gameService = new DummyGameService(config.lobbyUrl ?? '',config.startingBalance ?? 0);
        dependency_container_instance.registerInstance(services_GameService, this.gameService);
        this.frontController = new SlotGameFrontController();
        this.frontController.addCommand(UIPanelEvent.OPEN_SETTINGS, ChangeUISettingsStateCommand);
        this.frontController.addCommand(UIPanelEvent.CLOSE_SETTINGS, ChangeUISettingsStateCommand);
        this.frontController.addCommand(UIPanelEvent.OPEN_PANEL, OpenPanelCommand);
        this.frontController.addCommand(UIPanelEvent.CLOSE_PANEL, ClosePanelCommand);
        this.frontController.removeCommand(SlotGameEvent.ROUND_COMPLETE, CompleteRoundCommand);
        this.frontController.addCommand(SlotGameEvent.ROUND_COMPLETE, CompleteRoundCommandOverride);
        this.frontController.addCommand(UIPanelEvent.SHOW_POPUP, ShowPopupCommand);
        this.frontController.addCommand(UIPanelEvent.HIDE_POPUP, HidePopupCommand);
        this.frontController.addCommand(UIEventExtension.BET_QUANTITY_UP, AdjustBetQuantityCommand);
        this.frontController.addCommand(UIEventExtension.BET_QUANTITY_DOWN, AdjustBetQuantityCommand);
        this.frontController.addCommand(UIEventExtension.BET_QUANTITY_MAX, AdjustBetQuantityCommand);
        this.frontController.addCommand(UIEventExtension.TOTAL_BET_DOWN, AdjustTotalBetCommand);
        this.frontController.addCommand(UIEventExtension.TOTAL_BET_UP, AdjustTotalBetCommand);
        this.frontController.removeCommand(SlotGameEvent.SPIN_START, SpinStartCommand);
        this.frontController.addCommand(SlotGameEvent.SPIN_START, SpinStartCommandOverride);
        this.frontController.addCommand(SlotGameEventExtension.BUY_FREESPINS, BuyFeatureCommandOverride);
        this.frontController.addCommand(SlotGameEventExtension.BUY_HOLD_AND_SPINNER, BuyFeatureCommandOverride);
        this.frontController.removeCommand(SlotGameEvent.FREE_SPIN_ROUND_COMPLETE, ConfirmFreeSpinsRoundCompleteCommand);
        this.frontController.addCommand(SlotGameEvent.FREE_SPIN_ROUND_COMPLETE, ConfirmFreeSpinsRoundCompleteCommandOverride);
        this.frontController.addCommand(SlotGameEvent.FREE_SPIN_RESULT_READY, ConfirmFreeSpinResultCommand);
        this.frontController.addCommand(SlotGameEventExtension.HOLD_AND_SPINNER_START, HoldAndSpinnerCommand);
        this.frontController.addCommand(SlotGameEventExtension.HOLD_AND_SPINNER_ROUND_COMPLETE, ConfirmHoldAndSpinnerRoundCompleteCommand);
        this.frontController.addCommand(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, AdjustBetSettingsCommand);
        this.frontController.removeCommand(UIEvent.GAME_SPEED_LEVEL_DOWN, AdjustGameSpeedCommand);
        this.frontController.removeCommand(UIEvent.GAME_SPEED_LEVEL_UP, AdjustGameSpeedCommand);
        this.frontController.addCommand(UIEventExtension.GAME_SPEED_LEVEL_SELECT, AdjustGameSpeedCommandOverride);
        this.frontController.addCommand(AdjustBetSettingsStateEvent.CURRENT_BET_ID_UPDATE, AdjustBetSettingsCommand);
        this.frontController.addCommand(SpeedSettingsStateEvent.CURRENT_SPEED_LEVEL_SET, AdjustSpeedSettingsCommand);
        //this.frontController.addCommand(UIEventExtension.)
        dependency_container_instance.registerSingleton(UIState);
        dependency_container_instance.registerSingleton(PopupState);
        dependency_container_instance.registerSingleton(History);
        dependency_container_instance.registerSingleton(HoldAndSpinnerStaticSymbolMap);
        dependency_container_instance.registerSingleton(AutospinSettings);
        dependency_container_instance.registerSingleton(AdjustBetSettingsState);
        dependency_container_instance.registerSingleton(SpeedSettingsState);
        this.popupManager = new popup_PopupManager();
        this.popupManager.position.set(this.baseWidth / 2, this.baseHeight / 2);
        this.stage.addChild(this.popupManager);
        if (config.assetsBaseUrl)
            this.assetsBaseUrl = config.assetsBaseUrl;
        const loadingScreenAssetsLoader = new load_AssetsConfigLoader(`${this.assetsBaseUrl}/loading-screen-assets-config.json`, this.pixi.renderer);
        loadingScreenAssetsLoader.on(load_AssetsConfigLoader.EVENT_LOADING_COMPLETE, this.onLoadingScreenAssetsLoaded, this);
        sound_SoundManager.getChannel('default').mute = !((_g = (_f = getFromLocalStorage('settings')) === null || _f === void 0 ? void 0 : _f.soundFx) !== null && _g !== void 0 ? _g : true);
        sound_SoundManager.getChannel('ambient').mute = !((_j = (_h = getFromLocalStorage('settings')) === null || _h === void 0 ? void 0 : _h.ambientMusic) !== null && _j !== void 0 ? _j : true);
        this.getTranslationFile((_k = config.language) !== null && _k !== void 0 ? _k : 'en').then(() => {
            loadingScreenAssetsLoader.load();
        });
    }
    getTranslationFile(lang) {
        return TheMiner_awaiter(this, void 0, void 0, function* () {
            // fetch json file
            const response = yield fetch(`${this.assetsBaseUrl}/translations/${lang}.json`);
            const data = yield response.json();
            translations_Translation.addLanguageData(lang, data);
            translations_Translation.setCurrentLanguage(lang);
        });
    }
    set activeMainGameView(value) {
        if (this._activeMainGameView == value) {
            return;
        }
        const oldView = this._activeMainGameView;
        this._activeMainGameView = value;
        this.onWindowResize();
        //
        // const w: number = Math.ceil(this.width);
        // const h: number = Math.ceil(this.height);
        const w = 4000;
        const h = 4000;
        const x = -(w - this.baseWidth) / 2;
        const y = -(h - this.baseHeight) / 2;
        const fadeSize = new Rectangle(x, y, w, h);
        if (oldView) {
            const swapEffect = new SwapViewsEffectFadeToBlack(fadeSize);
            // let swapEffect: ISwapViewsEffect = new SwapViewsEffectFadeOut();
            swapEffect.apply(oldView, this._activeMainGameView, this.stage, () => {
                if (oldView == this.loadingScreen) {
                    oldView.destroy({
                        children: true,
                    });
                }
            });
        }
        else {
            this.stage.addChildAt(this._activeMainGameView, 0);
        }
    }
    onLoadingScreenAssetsLoaded() {
        utils_Logger.info('Loading screen assets loaded');
        this.container.style.display = 'block';
        this.loadingScreen = new LoadingScreen(() => {
            var _a, _b;
            this.onAllAssetsLoaded();
            return;
            if (((_b = (_a = getFromLocalStorage('settings')) === null || _a === void 0 ? void 0 : _a.introScreen) !== null && _b !== void 0 ? _b : true) == false) {
            }
            this.introScreen = new IntroScreen();
            this.introScreen.on(IntroScreenEvent.ON_GET_STARTED_CLICKED, this.onAllAssetsLoaded, this);
            this.activeMainGameView = this.introScreen;
        });
        this.activeMainGameView = this.loadingScreen;
        const gameAssetsLoader = new load_AssetsConfigLoader(`${this.assetsBaseUrl}/main-game-assets-config.json`, this.pixi.renderer);
        gameAssetsLoader.on(load_AssetsConfigLoader.EVENT_LOADING_PROGRESS, (progress) => {
            this.loadingScreen.setProgress(progress);
        }, this);
        gameAssetsLoader.on(load_AssetsConfigLoader.EVENT_LOADING_COMPLETE, this.onGameAssetsLoaded, this);
        gameAssetsLoader.load();
        new ControlEvent(ApplicationEvent.INIT).dispatch();
    }
    onGameAssetsLoaded() {
        return TheMiner_awaiter(this, void 0, void 0, function* () {
            utils_Logger.info('Game assets loaded');
            GraphicUtils.init(this.pixi.renderer);
            yield GraphicUtils.processSymbolsData(SymbolsList);
            this.loadingScreen.stop();
        });
    }
    onAllAssetsLoaded() {
        // check config complete
        if (!dependency_container_instance.isRegistered(SlotMachine)) {
            ignitionTween.Tweener.addCaller(this, {
                count: 1,
                time: 0.1,
                onComplete: () => {
                    this.onAllAssetsLoaded();
                },
            });
            return;
        }
        this.slotMachine = dependency_container_instance.resolve(SlotMachine);
        this.slotMachine.on(SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
        const uiState = dependency_container_instance.resolve(UIState);
        uiState.on(UIStateEvent.ACTIVE_PANEL_CHANGED, this.onUiActivePanelChanged, this);
        const popupState = dependency_container_instance.resolve(PopupState);
        popupState.on(UIStateEvent.ACTIVE_POPUP_CHANGED, this.onActivePopupChanged, this);
        // TODO: uncomment these and remove the bottom line for feature presentation screen
        // this.featurePresentationScreen = new FeaturePresentationScreen();
        // this.featurePresentationScreen.on('continue', this.onFeaturePresentationScreenContinue, this);
        // this.activeMainGameView = this.featurePresentationScreen;
        PopupFactory.initialize();
        new ControlEvent(ApplicationEvent.LOADING_COMPLETE).dispatch();
    }
    onFeaturePresentationScreenContinue() {
        new ControlEvent(ApplicationEvent.LOADING_COMPLETE).dispatch();
    }
    onSlotMachineStateChanged(currentState, previousState) {
        const skipScreens = dependency_container_instance.resolve(AutospinSettings).skipScreens;
        // callbacks for all onPopupHidden types
        const onHiddenFreespinsStart = () => TheMiner_awaiter(this, void 0, void 0, function* () {
            yield this.mainGameScreen.background.setTheme(MainScreenBackground_BackgroundType.FREEGAME).then(() => {
                new ControlEvent(SlotGameEvent.FREE_SPIN_ROUND_STARTED).dispatch();
            });
        });
        const onHiddenFreespinsEnd = () => TheMiner_awaiter(this, void 0, void 0, function* () {
            yield this.mainGameScreen.background.setTheme(MainScreenBackground_BackgroundType.NORMAL).then(() => {
                new ControlEvent(SlotGameEvent.FREE_SPIN_ROUND_COMPLETE).dispatch();
                this.mainGameScreen.freespinMultiplier.deactivateCells();
            });
        });
        const onHiddenHoldAndSpinnerStart = () => TheMiner_awaiter(this, void 0, void 0, function* () {
            yield this.mainGameScreen.background.setTheme(MainScreenBackground_BackgroundType.BONUS);
            this.mainGameScreen.holdAndSpinnerView.collectInitializedMultipliers().then(() => {
                new ControlEvent(SlotGameEvent.BONUS_GAME_WIN_SHOWN).dispatch();
            });
        });
        const onHiddenHoldAndSpinnerEnd = () => TheMiner_awaiter(this, void 0, void 0, function* () {
            yield this.mainGameScreen.background.setTheme(MainScreenBackground_BackgroundType.NORMAL);
            new ControlEvent(SlotGameEventExtension.HOLD_AND_SPINNER_ROUND_COMPLETE).dispatch();
        });
        const sm = dependency_container_instance.resolve(SlotMachine);
        switch (currentState) {
            case SlotMachineState.IDLE:
                if (!this.mainGameScreen) {
                    this.mainGameScreen = dependency_container_instance.resolve(view_MainGameScreen);
                    dependency_container_instance.resolve(model_Wallet).on(WalletEvent.NOT_ENOUGH_BALANCE, this.onNotEnoughBalance, this);
                }
                this.activeMainGameView = this.mainGameScreen;
                if (this.mainGameScreen.background.getTheme() == null)
                    this.mainGameScreen.background.setTheme(MainScreenBackground_BackgroundType.NORMAL);
                break;
            case SlotMachineState.BIG_WIN_FREE_SPIN:
                if (skipScreens) {
                    setTimeout(() => new ControlEvent(SlotGameEvent.FREE_SPIN_START).dispatch(), 0);
                }
                else {
                    this.onShowPopup(PopupFactoryType.BIG_WIN_FREESPIN_HORIZONTAL, PopupFactoryType.BIG_WIN_FREESPIN_VERTICAL, () => { new ControlEvent(SlotGameEvent.FREE_SPIN_START).dispatch(); }, this.getProperWinSound(sm.bigWinLevel(sm.roundResult)));
                }
                break;
            case SlotMachineState.BIG_WIN:
                if (skipScreens) {
                    setTimeout(() => new ControlEvent(SlotGameEvent.BIG_WIN_SHOWN).dispatch(), 0);
                }
                else {
                    this.onShowPopup(PopupFactoryType.BIG_WIN_HORIZONTAL, PopupFactoryType.BIG_WIN_VERTICAL, () => { new ControlEvent(SlotGameEvent.BIG_WIN_SHOWN).dispatch(); }, this.getProperWinSound(sm.bigWinLevel(sm.roundResult)));
                }
                break;
            case SlotMachineState.FREE_SPINS_ROUND_START:
                if (!this.slotMachine.showFreeSpinsPopup) {
                    this.slotMachine.showFreeSpinsPopup = true;
                    onHiddenFreespinsStart();
                    return;
                }
                if (skipScreens) {
                    setTimeout(() => onHiddenFreespinsStart(), 0);
                }
                else {
                    this.onShowPopup(PopupFactoryType.FREESPIN_POPUP_HORIZONTAL, PopupFactoryType.FREESPIN_POPUP_VERTICAL, onHiddenFreespinsStart, sound_SoundList.FREESPIN_WIN);
                }
                break;
            case SlotMachineState.FREE_SPINS_ROUND_END:
                this.handleFreepinsResult(onHiddenFreespinsEnd);
                break;
            case SlotMachineState.COMMUNICATION_ERROR:
                const data = {
                    type: PopupType.CONNECTION_LOST,
                    hideOnClick: false,
                    duration: -1,
                    callbacks: null,
                };
                new ControlEvent(UIPanelEvent.SHOW_POPUP, data).dispatch();
                break;
            case SlotMachineState.SPIN_RESULT_BONUS_GAME:
                if (sm.currentSpinResult.bonus.bonusGameShown) {
                    this.mainGameScreen.background.setTheme(MainScreenBackground_BackgroundType.BONUS).then(() => {
                        new ControlEvent(SlotGameEventExtension.HOLD_AND_SPINNER_START).dispatch();
                    });
                    return;
                }
                if (skipScreens) {
                    setTimeout(() => onHiddenHoldAndSpinnerStart(), 0);
                }
                else {
                    this.onShowPopup(PopupFactoryType.HOLD_SPINNER_POPUP_HORIZONTAL, PopupFactoryType.HOLD_SPINNER_POPUP_VERTICAL, onHiddenHoldAndSpinnerStart, sound_SoundList.FREESPIN_AWARD);
                }
                break;
            case SlotMachineState.BONUS_GAME:
                // end of BONUS GAME
                if (sm.roundResult.nextType !== TransactionType.HOLD_AND_SPINNER) {
                    if (skipScreens) {
                        setTimeout(() => onHiddenHoldAndSpinnerEnd(), 0);
                    }
                    else {
                        this.onShowPopup(PopupFactoryType.CONGRATULATIONS_POPUP_HORIZONTAL, PopupFactoryType.CONGRATULATIONS_POPUP_VERTICAL, onHiddenHoldAndSpinnerEnd, sound_SoundList.FREESPIN_WIN);
                    }
                }
                break;
            case SlotMachineState.FREE_SPINS:
                // freespin banner should update even if there is only 1 wild and 0 multipliers
                if (sm.roundResult.holdAndSpinnerMultiplierMap.wildPosition && sm.roundResult.holdAndSpinnerMultiplierMap.toCollect) {
                    this.mainGameScreen.freespinView.collectMultiplier(sm.roundResult.holdAndSpinnerMultiplierMap).then(() => {
                        if (sm.currentSpinResult.freespins.moreAwarded > 0) {
                            sm.bigWinShown = true;
                            this.onShowPopup(PopupFactoryType.EXTRA_FREESPIN_POPUP_HORIZONTAL, PopupFactoryType.EXTRA_FREESPIN_POPUP_VERTICAL, () => {
                                setTimeout(() => new ControlEvent(SlotGameEvent.FREE_SPIN_RESULT_READY).dispatch(), 0);
                                this.mainGameScreen.uiPanelMobileVertical.btnFreeSpin.moreAwarded();
                                this.mainGameScreen.uiPanelDesktop.btnFreeSpin.moreAwarded();
                                this.mainGameScreen.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                                this.mainGameScreen.uiPanelDesktop.totalWinFrame.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                            }, sound_SoundList.FREESPIN_WIN);
                        }
                        else
                            setTimeout(() => { new ControlEvent(SlotGameEvent.FREE_SPIN_RESULT_READY).dispatch(); }, 0);
                    });
                }
                else {
                    setTimeout(() => { new ControlEvent(SlotGameEvent.FREE_SPIN_RESULT_READY).dispatch(); }, 0);
                }
                break;
        }
    }
    handleFreepinsResult(onHiddenFreespinsEnd) {
        const skipScreens = dependency_container_instance.resolve(AutospinSettings).skipScreens;
        const sm = dependency_container_instance.resolve(SlotMachine);
        if (sm.roundResult.holdAndSpinnerMultiplierMap.wildPosition && dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap.toCollect) {
            this.mainGameScreen.freespinView.collectMultiplier(dependency_container_instance.resolve(SlotMachine).roundResult.holdAndSpinnerMultiplierMap).then(() => {
                if (skipScreens) {
                    setTimeout(() => onHiddenFreespinsEnd(), 0);
                }
                else {
                    this.onShowPopup(PopupFactoryType.CONGRATULATIONS_POPUP_HORIZONTAL, PopupFactoryType.CONGRATULATIONS_POPUP_VERTICAL, onHiddenFreespinsEnd, sound_SoundList.FREESPIN_AWARD);
                }
            });
        }
        else {
            if (skipScreens) {
                setTimeout(() => onHiddenFreespinsEnd(), 0);
            }
            else {
                this.onShowPopup(PopupFactoryType.CONGRATULATIONS_POPUP_HORIZONTAL, PopupFactoryType.CONGRATULATIONS_POPUP_VERTICAL, onHiddenFreespinsEnd, sound_SoundList.FREESPIN_AWARD);
            }
        }
    }
    onShowPopup(popupTypeHorizontal, popupTypeVertical, onHidden, showSound) {
        const popupHorizontal = PopupFactory.retrieve(popupTypeHorizontal, this.updateLayoutDescription);
        const popupVertical = PopupFactory.retrieve(popupTypeVertical, this.updateLayoutDescription);
        this.popupManager.show(popupHorizontal, popupVertical, 5.5, true, {
            onPopupHidden: () => {
                onHidden();
            },
        }, () => popup_PopupManager.jumpAnimationConfiguration, {
            showSound: {
                id: showSound,
                volume: 0.6,
            },
            hideSound: {
                id: sound_SoundListExtended.UI_POPUP_HIDE,
            },
        });
    }
    resize(availableWidth, availableHeight, resizeMethod) {
        super.resize(availableWidth, availableHeight, resizeMethod);
        if (!this.stage) {
            return;
        }
        this.stage.x = (availableWidth - this.baseWidth * this.stage.scale.x) / 2;
        this.stage.y = (availableHeight - this.baseHeight * this.stage.scale.y) / 2;
        this.currentWidth = availableWidth / this.stage.scale.x;
        this.currentHeight = availableHeight / this.stage.scale.y;
        if (this._activeMainGameView) {
            this._activeMainGameView.updateLayout(this.updateLayoutDescription);
        }
        if (this.popupManager) {
            this.popupManager.updateLayout(this.updateLayoutDescription);
            this.popupManager.position.set(this.baseWidth / 2, this.baseHeight / 2);
        }
    }
    onUiActivePanelChanged() {
        const uiState = dependency_container_instance.resolve(UIState);
        let mobilePanel = null;
        let desktopPanel = null;
        switch (uiState.activePanel) {
            case UIPanelType.HISTORY:
                mobilePanel = PopupFactory.retrieve(PopupFactoryType.HISTORY_VERTICAL, this.updateLayoutDescription);
                desktopPanel = PopupFactory.retrieve(PopupFactoryType.HISTORY_HORIZONTAL, this.updateLayoutDescription);
                break;
            case UIPanelType.AUTOSPIN_SETTINGS:
                mobilePanel = PopupFactory.retrieve(PopupFactoryType.AUTOSPIN_SETTINGS_VERTICAL, this.updateLayoutDescription);
                desktopPanel = PopupFactory.retrieve(PopupFactoryType.AUTOSPIN_SETTINGS_HORIZONTAL, this.updateLayoutDescription);
                break;
            case UIPanelType.BET_SETTINGS:
                mobilePanel = PopupFactory.retrieve(PopupFactoryType.ADJUST_BET_VERTICAL, this.updateLayoutDescription);
                desktopPanel = PopupFactory.retrieve(PopupFactoryType.ADJUST_BET_HORIZONTAL, this.updateLayoutDescription);
                break;
            case UIPanelType.PAYTABLE:
                mobilePanel = PopupFactory.retrieve(PopupFactoryType.PAYTABLE_VERTICAL, this.updateLayoutDescription);
                desktopPanel = PopupFactory.retrieve(PopupFactoryType.PAYTABLE_HORIZONTAL, this.updateLayoutDescription);
                break;
            case UIPanelType.MENU_SETTINGS:
                mobilePanel = PopupFactory.retrieve(PopupFactoryType.MENU_SETTINGS_VERTICAL, this.updateLayoutDescription);
                desktopPanel = PopupFactory.retrieve(PopupFactoryType.MENU_SETTINGS_HORIZONTAL, this.updateLayoutDescription);
                break;
            default:
                this.popupManager.hide();
                return;
        }
        this.popupManager.show(desktopPanel, mobilePanel, -1, false, null, () => this.orientation == ScreenOrientation.VERTICAL
            ? popup_PopupManager.slideAnimationConfiguration
            : popup_PopupManager.defaultAnimationConfiguration, {
            showSound: {
                id: sound_SoundListExtended.UI_POPUP_COMMON_WINDOW
            },
            hideSound: {
                id: sound_SoundListExtended.UI_POPUP_HIDE
            }
        });
    }
    get updateLayoutDescription() {
        return {
            orientation: this.orientation,
            baseWidth: this.baseWidth,
            baseHeight: this.baseHeight,
            currentWidth: this.currentWidth,
            currentHeight: this.currentHeight,
        };
    }
    onActivePopupChanged() {
        const popupState = dependency_container_instance.resolve(PopupState);
        if (popupState.activePopup === null) {
            this.popupManager.hide();
            return;
        }
        let popupHorizontal = null;
        let popupVertical = null;
        let showSound = sound_SoundListExtended.UI_POPUP_COMMON_WINDOW;
        switch (popupState.activePopup.type) {
            case PopupType.NOT_ENOUGH_BALANCE:
                popupHorizontal = PopupFactory.retrieve(PopupFactoryType.BALANCE_HORIZONTAL, this.updateLayoutDescription);
                popupVertical = PopupFactory.retrieve(PopupFactoryType.BALANCE_VERTICAL, this.updateLayoutDescription);
                showSound = sound_SoundListExtended.UI_ERROR_APPEARANCE;
                break;
            case PopupType.CONNECTION_LOST:
                popupHorizontal = PopupFactory.retrieve(PopupFactoryType.CONNECTION_LOST_HORIZONTAL, this.updateLayoutDescription);
                popupVertical = PopupFactory.retrieve(PopupFactoryType.CONNECTION_LOST_VERTICAL, this.updateLayoutDescription);
                showSound = sound_SoundListExtended.UI_ERROR_APPEARANCE;
                break;
            case PopupType.FREESPIN_BUY:
                popupHorizontal = PopupFactory.retrieve(PopupFactoryType.FREESPIN_BUY_HORIZONTAL, this.updateLayoutDescription);
                popupVertical = PopupFactory.retrieve(PopupFactoryType.FREESPIN_BUY_VERTICAL, this.updateLayoutDescription);
                break;
            case PopupType.HOLD_AND_SPINNER_BUY:
                popupHorizontal = PopupFactory.retrieve(PopupFactoryType.HOLD_AND_SPINNER_BUY_HORIZONTAL, this.updateLayoutDescription);
                popupVertical = PopupFactory.retrieve(PopupFactoryType.HOLD_AND_SPINNER_BUY_VERTICAL, this.updateLayoutDescription);
                break;
            case PopupType.TURBO_ACTIVATE:
                popupHorizontal = PopupFactory.retrieve(PopupFactoryType.TURBO_ACTIVATE_HORIZONTAL, this.updateLayoutDescription);
                popupVertical = PopupFactory.retrieve(PopupFactoryType.TURBO_ACTIVATE_VERTICAL, this.updateLayoutDescription);
                break;
        }
        this.popupManager.show(popupHorizontal, popupVertical, popupState.activePopup.duration, popupState.activePopup.hideOnClick, popupState.activePopup.callbacks, () => this.resolveAnimation(), {
            showSound: {
                id: showSound
            },
            hideSound: {
                id: sound_SoundListExtended.UI_POPUP_HIDE
            }
        });
    }
    resolveAnimation() {
        var _a;
        const popupState = dependency_container_instance.resolve(PopupState);
        let animation;
        if (((_a = popupState.activePopup) === null || _a === void 0 ? void 0 : _a.type) == PopupType.TURBO_ACTIVATE) {
            animation = popup_PopupTurboActivate.turboPopupAnimationConfiguration;
        }
        else {
            if (this.orientation == ScreenOrientation.VERTICAL)
                animation = popup_PopupManager.slideAnimationConfiguration;
            else
                animation = popup_PopupManager.defaultAnimationConfiguration;
        }
        return animation;
    }
    onNotEnoughBalance() {
        const data = {
            type: PopupType.NOT_ENOUGH_BALANCE,
            hideOnClick: false,
            duration: -1,
            callbacks: null,
        };
        new ControlEvent(UIPanelEvent.SHOW_POPUP, data).dispatch();
    }
    getProperWinSound(winLevel) {
        if (winLevel === 1)
            return sound_SoundListExtended.GREAT_WIN;
        else if (winLevel === 2)
            return sound_SoundListExtended.HUGE_WIN;
        else if (winLevel === 3)
            return sound_SoundListExtended.INSANE_WIN;
        return sound_SoundListExtended.GOOD_WIN;
    }
}

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=game.bundle.js.map